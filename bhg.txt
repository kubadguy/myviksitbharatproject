--- Scanning Project Root: src ---
    helper.txt
      |--- FILE CONTENT START ---|
      # PROJECT STRUCTURE
      # ===================
      # db_security_system/
      # ‚îú‚îÄ‚îÄ main.py
      # ‚îú‚îÄ‚îÄ requirements.txt
      # ‚îú‚îÄ‚îÄ config/
      # ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ settings.py
      # ‚îÇ   ‚îî‚îÄ‚îÄ database_config.py
      # ‚îú‚îÄ‚îÄ core/
      # ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ firewall.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ access_control.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ honeypot.py
      # ‚îÇ   ‚îî‚îÄ‚îÄ logger.py
      # ‚îú‚îÄ‚îÄ database/
      # ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ db_manager.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ query_validator.py
      # ‚îÇ   ‚îî‚îÄ‚îÄ fake_data_generator.py
      # ‚îú‚îÄ‚îÄ security/
      # ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ injection_detector.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ threat_analyzer.py
      # ‚îÇ   ‚îî‚îÄ‚îÄ ip_tracker.py
      # ‚îú‚îÄ‚îÄ alerts/
      # ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ alert_manager.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ email_notifier.py
      # ‚îÇ   ‚îî‚îÄ‚îÄ sms_notifier.py
      # ‚îú‚îÄ‚îÄ gui/
      # ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ main_window.py
      # ‚îÇ   ‚îú‚îÄ‚îÄ dashboard.py
      # ‚îÇ   ‚îî‚îÄ‚îÄ log_viewer.py
      # ‚îî‚îÄ‚îÄ api/
      #     ‚îú‚îÄ‚îÄ __init__.py
      #     ‚îú‚îÄ‚îÄ rest_api.py
      #     ‚îî‚îÄ‚îÄ middleware.py

      # ============================================================
      # FILE 1: requirements.txt
      # ============================================================
      """
      faker==20.0.0
      PyQt6==6.6.0
      flask==3.0.0
      requests==2.31.0
      python-dotenv==1.0.0
      """

      # ============================================================
      # FILE 2: config/settings.py
      # ============================================================
      import os
      from pathlib import Path

      BASE_DIR = Path(__file__).resolve().parent.parent

      class Settings:
          # Database settings
          REAL_DB_PATH = os.path.join(BASE_DIR, 'data', 'real_database.db')
          HONEYPOT_DB_PATH = os.path.join(BASE_DIR, 'data', 'honeypot_database.db')

          # Security settings
          MAX_FAILED_ATTEMPTS = 3
          ALERT_THRESHOLD = 5

          # Alert settings
          ENABLE_EMAIL_ALERTS = True
          ENABLE_SMS_ALERTS = False
          ADMIN_EMAIL = "admin@company.com"

          # API settings
          API_HOST = "0.0.0.0"
          API_PORT = 5000
          API_DEBUG = False

      # ============================================================
      # FILE 3: config/database_config.py
      # ============================================================
      AUTHORIZED_APPS = {
          'webapp_frontend': {
              'time_windows': [(9, 17)],  # 9 AM - 5 PM
              'allowed_operations': ['SELECT', 'INSERT', 'UPDATE'],
              'ip_whitelist': ['192.168.1.0/24']
          },
          'backup_service': {
              'time_windows': [(2, 4)],  # 2 AM - 4 AM
              'allowed_operations': ['SELECT'],
              'ip_whitelist': ['10.0.0.5']
          },
          'admin_panel': {
              'time_windows': [(0, 23)],  # 24/7
              'allowed_operations': ['SELECT', 'INSERT', 'UPDATE', 'DELETE'],
              'ip_whitelist': ['192.168.1.100']
          }
      }

      # ============================================================
      # FILE 4: core/access_control.py
      # ============================================================
      from datetime import datetime
      from typing import List, Tuple
      import ipaddress

      class AccessControl:
          def __init__(self, config):
              self.config = config

          def is_authorized(self, app_id: str, ip_address: str,
                           operation: str, current_time: datetime = None) -> Tuple[bool, str]:
              if current_time is None:
                  current_time = datetime.now()

              if app_id not in self.config:
                  return False, "Unknown application"

              app_config = self.config[app_id]

              # Check time window
              if not self._check_time_window(current_time, app_config['time_windows']):
                  return False, "Outside authorized time window"

              # Check operation
              if operation.upper() not in app_config['allowed_operations']:
                  return False, "Unauthorized operation"

              # Check IP whitelist
              if not self._check_ip_whitelist(ip_address, app_config['ip_whitelist']):
                  return False, "IP not whitelisted"

              return True, "Authorized"

          def _check_time_window(self, current_time: datetime,
                                windows: List[Tuple[int, int]]) -> bool:
              current_hour = current_time.hour
              for start, end in windows:
                  if start <= current_hour < end:
                      return True
              return False

          def _check_ip_whitelist(self, ip: str, whitelist: List[str]) -> bool:
              try:
                  ip_obj = ipaddress.ip_address(ip)
                  for allowed in whitelist:
                      if '/' in allowed:
                          if ip_obj in ipaddress.ip_network(allowed):
                              return True
                      else:
                          if str(ip_obj) == allowed:
                              return True
                  return False
              except:
                  return False

      # ============================================================
      # FILE 5: core/honeypot.py
      # ============================================================
      from database.fake_data_generator import FakeDataGenerator
      import sqlite3

      class Honeypot:
          def __init__(self, db_path: str):
              self.db_path = db_path
              self.fake_gen = FakeDataGenerator()
              self._init_database()

          def _init_database(self):
              conn = sqlite3.connect(self.db_path)
              cursor = conn.cursor()
              cursor.execute('''
                  CREATE TABLE IF NOT EXISTS users (
                      id INTEGER PRIMARY KEY,
                      username TEXT,
                      email TEXT,
                      password TEXT,
                      balance REAL
                  )
              ''')
              conn.commit()
              conn.close()

          def populate_fake_data(self, num_records: int = 5):
              conn = sqlite3.connect(self.db_path)
              cursor = conn.cursor()
              cursor.execute("DELETE FROM users")

              fake_data = self.fake_gen.generate_users(num_records)
              cursor.executemany('''
                  INSERT INTO users (id, username, email, password, balance)
                  VALUES (?, ?, ?, ?, ?)
              ''', fake_data)

              conn.commit()
              conn.close()

          def execute_query(self, query: str):
              self.populate_fake_data()
              conn = sqlite3.connect(self.db_path)
              cursor = conn.cursor()

              try:
                  cursor.execute(query)
                  if query.strip().upper().startswith('SELECT'):
                      results = cursor.fetchall()
                  else:
                      conn.commit()
                      results = []
                  return results
              except Exception as e:
                  return []
              finally:
                  conn.close()

      # ============================================================
      # FILE 6: database/fake_data_generator.py
      # ============================================================
      from faker import Faker
      import hashlib

      class FakeDataGenerator:
          def __init__(self):
              self.fake = Faker()

          def generate_users(self, count: int = 5):
              users = []
              for i in range(1, count + 1):
                  users.append((
                      i,
                      self.fake.user_name(),
                      self.fake.email(),
                      hashlib.md5(self.fake.password().encode()).hexdigest(),
                      round(self.fake.random.uniform(1000, 10000), 2)
                  ))
              return users

      # ============================================================
      # FILE 7: security/injection_detector.py
      # ============================================================
      import re

      class InjectionDetector:
          SQL_INJECTION_PATTERNS = [
              r"(\bOR\b.*=.*)",
              r"(\bAND\b.*=.*)",
              r"(--)",
              r"(;.*DROP)",
              r"(;.*DELETE)",
              r"(UNION.*SELECT)",
              r"(\'.*OR.*\'.*=.*\')",
              r"(\".*OR.*\".*=.*\")",
          ]

          NOSQL_INJECTION_PATTERNS = [
              r"(\$ne|\$gt|\$lt|\$gte|\$lte)",
              r"(\$where|\$regex)",
              r"(\$or|\$and|\$not)",
          ]

          def detect_sql_injection(self, query: str) -> Tuple[bool, str]:
              for pattern in self.SQL_INJECTION_PATTERNS:
                  if re.search(pattern, query, re.IGNORECASE):
                      return True, f"SQL injection pattern detected: {pattern}"
              return False, ""

          def detect_nosql_injection(self, query_obj: dict) -> Tuple[bool, str]:
              query_str = str(query_obj)
              for pattern in self.NOSQL_INJECTION_PATTERNS:
                  if re.search(pattern, query_str):
                      return True, f"NoSQL injection pattern detected: {pattern}"
              return False, ""

      # ============================================================
      # FILE 8: core/logger.py
      # ============================================================
      from datetime import datetime
      from typing import List, Dict

      class SecurityLogger:
          def __init__(self):
              self.logs = []

          def log_intrusion(self, app_id: str, ip_address: str,
                           operation: str, query: str, reason: str):
              log_entry = {
                  'app_id': app_id,
                  'ip_address': ip_address,
                  'operation': operation,
                  'query': query,
                  'reason': reason,
                  'action': 'REDIRECTED_TO_HONEYPOT'
              }
              self.logs.append(log_entry)
              return log_entry

          def get_logs(self, limit: int = None) -> List[Dict]:
              if limit:
                  return self.logs[-limit:]
              return self.logs

          def clear_logs(self):
              self.logs = []

      # ============================================================
      # FILE 9: alerts/alert_manager.py
      # ============================================================
      class AlertManager:
          def __init__(self, email_enabled=True, sms_enabled=False):
              self.email_enabled = email_enabled
              self.sms_enabled = sms_enabled

          def send_alert(self, log_entry: dict):
              alert_msg = self._format_alert(log_entry)

              print("\n" + "="*60)
              print("üö® SECURITY ALERT")
              print("="*60)
              print(alert_msg)
              print("="*60 + "\n")

              # Email/SMS would be sent here in production

          def _format_alert(self, log: dict) -> str:
              return f"""
      Application:  {log['app_id']}
      IP Address:   {log['ip_address']}
      Operation:    {log['operation']}
      Reason:       {log['reason']}
      Query:        {log['query'][:100]}...
      Action:       {log['action']}
      """

      # ============================================================
      # FILE 10: core/firewall.py
      # ============================================================
      from core.access_control import AccessControl
      from core.honeypot import Honeypot
      from core.logger import SecurityLogger
      from alerts.alert_manager import AlertManager
      from security.injection_detector import InjectionDetector
      from config.database_config import AUTHORIZED_APPS
      from config.settings import Settings
      import sqlite3

      class DatabaseFirewall:
          def __init__(self):
              self.access_control = AccessControl(AUTHORIZED_APPS)
              self.honeypot = Honeypot(Settings.HONEYPOT_DB_PATH)
              self.logger = SecurityLogger()
              self.alert_manager = AlertManager()
              self.injection_detector = InjectionDetector()
              self._init_real_database()

          def _init_real_database(self):
              conn = sqlite3.connect(Settings.REAL_DB_PATH)
              cursor = conn.cursor()
              cursor.execute('''
                  CREATE TABLE IF NOT EXISTS users (
                      id INTEGER PRIMARY KEY,
                      username TEXT,
                      email TEXT,
                      password TEXT,
                      balance REAL
                  )
              ''')
              cursor.execute("DELETE FROM users")
              cursor.executemany('''
                  INSERT INTO users (username, email, password, balance)
                  VALUES (?, ?, ?, ?)
              ''', [
                  ('admin', 'admin@company.com', 'real_hash_1', 50000.00),
                  ('john_doe', 'john@company.com', 'real_hash_2', 25000.00),
              ])
              conn.commit()
              conn.close()

          def execute_query(self, app_id: str, ip_address: str,
                           operation: str, query: str, simulate_time=None):
              # Check for injection
              is_injection, reason = self.injection_detector.detect_sql_injection(query)

              # Check authorization
              is_auth, auth_reason = self.access_control.is_authorized(
                  app_id, ip_address, operation, simulate_time
              )

              if is_auth and not is_injection:
                  # Execute on real database
                  conn = sqlite3.connect(Settings.REAL_DB_PATH)
                  cursor = conn.cursor()
                  cursor.execute(query)
                  if operation.upper() in ['INSERT', 'UPDATE', 'DELETE']:
                      conn.commit()
                      results = []
                  else:
                      results = cursor.fetchall()
                  conn.close()
                  return True, results, "Access granted"

              else:
                  # Redirect to honeypot
                  final_reason = reason if is_injection else auth_reason
                  log_entry = self.logger.log_intrusion(
                      app_id, ip_address, operation, query, final_reason
                  )
                  self.alert_manager.send_alert(log_entry)
                  results = self.honeypot.execute_query(query)
                  return False, results, final_reason

          def get_logs(self):
              return self.logger.get_logs()

      # ============================================================
      # FILE 11: gui/main_window.py
      # ============================================================
      from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout,
                                   QHBoxLayout, QPushButton, QTextEdit,
                                   QLabel, QTableWidget, QTableWidgetItem,
                                   QLineEdit, QComboBox)
      from PyQt6.QtCore import Qt
      from core.firewall import DatabaseFirewall

      class MainWindow(QMainWindow):
          def __init__(self):
              super().__init__()
              self.firewall = DatabaseFirewall()
              self.init_ui()

          def init_ui(self):
              self.setWindowTitle("Database Security System")
              self.setGeometry(100, 100, 1200, 800)

              central_widget = QWidget()
              self.setCentralWidget(central_widget)
              main_layout = QVBoxLayout(central_widget)

              # Test query section
              query_layout = QHBoxLayout()
              self.app_input = QLineEdit()
              self.app_input.setPlaceholderText("App ID")
              self.ip_input = QLineEdit()
              self.ip_input.setPlaceholderText("IP Address")
              self.query_input = QLineEdit()
              self.query_input.setPlaceholderText("SQL Query")
              self.op_combo = QComboBox()
              self.op_combo.addItems(['SELECT', 'INSERT', 'UPDATE', 'DELETE'])

              test_btn = QPushButton("Test Query")
              test_btn.clicked.connect(self.test_query)

              query_layout.addWidget(QLabel("App:"))
              query_layout.addWidget(self.app_input)
              query_layout.addWidget(QLabel("IP:"))
              query_layout.addWidget(self.ip_input)
              query_layout.addWidget(QLabel("Op:"))
              query_layout.addWidget(self.op_combo)
              query_layout.addWidget(self.query_input)
              query_layout.addWidget(test_btn)

              # Results area
              self.results_text = QTextEdit()
              self.results_text.setReadOnly(True)

              # Logs table
              self.logs_table = QTableWidget()
              self.logs_table.setColumnCount(5)
              self.logs_table.setHorizontalHeaderLabels(
                  ['App ID', 'IP', 'Operation', 'Reason', 'Query']
              )

              refresh_btn = QPushButton("Refresh Logs")
              refresh_btn.clicked.connect(self.refresh_logs)

              main_layout.addLayout(query_layout)
              main_layout.addWidget(QLabel("Results:"))
              main_layout.addWidget(self.results_text)
              main_layout.addWidget(refresh_btn)
              main_layout.addWidget(self.logs_table)

          def test_query(self):
              app_id = self.app_input.text()
              ip = self.ip_input.text()
              query = self.query_input.text()
              operation = self.op_combo.currentText()

              is_auth, results, reason = self.firewall.execute_query(
                  app_id, ip, operation, query
              )

              status = "‚úÖ AUTHORIZED" if is_auth else "‚ùå BLOCKED"
              self.results_text.setText(
                  f"{status}\nReason: {reason}\nResults: {results}"
              )
              self.refresh_logs()

          def refresh_logs(self):
              logs = self.firewall.get_logs()
              self.logs_table.setRowCount(len(logs))

              for i, log in enumerate(logs):
                  self.logs_table.setItem(i, 0, QTableWidgetItem(log['app_id']))
                  self.logs_table.setItem(i, 1, QTableWidgetItem(log['ip_address']))
                  self.logs_table.setItem(i, 2, QTableWidgetItem(log['operation']))
                  self.logs_table.setItem(i, 3, QTableWidgetItem(log['reason']))
                  self.logs_table.setItem(i, 4, QTableWidgetItem(log['query'][:50]))

      # ============================================================
      # FILE 12: api/rest_api.py
      # ============================================================
      from flask import Flask, request, jsonify
      from core.firewall import DatabaseFirewall

      app = Flask(__name__)
      firewall = DatabaseFirewall()

      @app.route('/api/query', methods=['POST'])
      def execute_query():
          data = request.json
          is_auth, results, reason = firewall.execute_query(
              data['app_id'],
              request.remote_addr,
              data['operation'],
              data['query']
          )

          return jsonify({
              'authorized': is_auth,
              'results': results,
              'reason': reason
          })

      @app.route('/api/logs', methods=['GET'])
      def get_logs():
          return jsonify(firewall.get_logs())

      # ============================================================
      # FILE 13: main.py
      # ============================================================
      import sys
      from PyQt6.QtWidgets import QApplication
      from gui.main_window import MainWindow

      def main():
          app = QApplication(sys.argv)
          window = MainWindow()
          window.show()
          sys.exit(app.exec())

      if __name__ == '__main__':
          main()
      |--- FILE CONTENT END ---|

    main.py
      |--- FILE CONTENT START ---|
      # src/main.py (top portion updated)
      # ---------------------------------------------------------------------
      # NOTE: this file was modified to install the sqlite wrapper early so that
      # every sqlite3.connect in the process returns a wrapped connection.
      # ---------------------------------------------------------------------

      # Install DB proxy wrapper BEFORE importing sqlite3 in other modules.
      try:
          # import installer early
          from security.db_proxy import install_sqlite_wrapper
          install_sqlite_wrapper()
      except Exception:
          # If wrapper fails, continue but log to console
          import logging
          logging.exception("Failed to install sqlite wrapper; continuing without it.")

      # Now import sqlite3 and the rest of the module's dependencies
      import sqlite3
      import datetime
      from typing import Dict, List, Tuple
      from faker import Faker
      import hashlib

      # --- rest of your original main.py follows unchanged ---
      class DatabaseFirewall:
          """Main firewall class that intercepts and validates database access"""

          def __init__(self, real_db_path: str = "real_database.db",
              honeypot_db_path: str = "honeypot_database.db"):
              self.real_db_path = real_db_path
              self.honeypot_db_path = honeypot_db_path
              self.fake = Faker()
              self.access_log = []
              self.authorized_schedule = {} # Format: {app_id: [(start_time, end_time)]}
              # Initialize databases
              self._init_real_database()
              self._init_honeypot_database()

          # <--- keep the rest of your original methods exactly as they were --->
      # (the rest of the original file remains; do not duplicate)
      |--- FILE CONTENT END ---|

    __init__.py
      |--- FILE CONTENT START ---|

      |--- FILE CONTENT END ---|

    __main__.py
      |--- FILE CONTENT START ---|
      from main import main

      if __name__ == '__main__':
          main()
      |--- FILE CONTENT END ---|

    [alerts]/
        alert_manager.py
          |--- FILE CONTENT START ---|
          class AlertManager:
              def __init__(self, email_enabled=True, sms_enabled=False):
                  self.email_enabled = email_enabled
                  self.sms_enabled = sms_enabled

              def send_alert(self, log_entry: dict):
                  alert_msg = self._format_alert(log_entry)

                  print("\n" + "="*60)
                  print("üö® SECURITY ALERT")
                  print("="*60)
                  print(alert_msg)
                  print("="*60 + "\n")

                  # Email/SMS would be sent here in production

              def _format_alert(self, log: dict) -> str:
                  return f"""
          Application:  {log['app_id']}
          IP Address:   {log['ip_address']}
          Operation:    {log['operation']}
          Reason:       {log['reason']}
          Query:        {log['query'][:100]}...
          Action:       {log['action']}
          """
          |--- FILE CONTENT END ---|

        email_notifier.py
          |--- FILE CONTENT START ---|
          import smtplib
          from email.mime.text import MIMEText
          from email.mime.multipart import MIMEMultipart
          from typing import List


          class EmailNotifier:
              def __init__(self, smtp_server: str = "smtp.gmail.com",
                           smtp_port: int = 587,
                           sender_email: str = None,
                           sender_password: str = None):
                  self.smtp_server = smtp_server
                  self.smtp_port = smtp_port
                  self.sender_email = sender_email
                  self.sender_password = sender_password

              def send_alert_email(self, recipient: str, log_entry: dict) -> bool:
                  """
                  Send security alert email
                  Returns True if successful, False otherwise
                  """
                  if not self.sender_email or not self.sender_password:
                      print("[EmailNotifier] Email credentials not configured")
                      return False

                  try:
                      # Create message
                      msg = MIMEMultipart()
                      msg['From'] = self.sender_email
                      msg['To'] = recipient
                      msg['Subject'] = f"üö® Security Alert - {log_entry['reason']}"

                      # Email body
                      body = f"""
          SECURITY ALERT NOTIFICATION
          ============================

          Application ID: {log_entry['app_id']}
          IP Address: {log_entry['ip_address']}
          Operation: {log_entry['operation']}
          Reason: {log_entry['reason']}
          Action Taken: {log_entry['action']}

          Query Details:
          {log_entry['query']}

          Please investigate this security incident immediately.

          ---
          This is an automated message from the Database Security System.
                      """

                      msg.attach(MIMEText(body, 'plain'))

                      # Send email
                      with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                          server.starttls()
                          server.login(self.sender_email, self.sender_password)
                          server.send_message(msg)

                      print(f"[EmailNotifier] Alert email sent to {recipient}")
                      return True

                  except Exception as e:
                      print(f"[EmailNotifier] Failed to send email: {str(e)}")
                      return False

              def send_bulk_alert(self, recipients: List[str], log_entry: dict) -> int:
                  """
                  Send alert to multiple recipients
                  Returns the number of successful sends
                  """
                  success_count = 0
                  for recipient in recipients:
                      if self.send_alert_email(recipient, log_entry):
                          success_count += 1
                  return success_count

              def test_connection(self) -> bool:
                  """Test SMTP connection"""
                  try:
                      with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                          server.starttls()
                          if self.sender_email and self.sender_password:
                              server.login(self.sender_email, self.sender_password)
                      print("[EmailNotifier] Connection test successful")
                      return True
                  except Exception as e:
                      print(f"[EmailNotifier] Connection test failed: {str(e)}")
                      return False
          |--- FILE CONTENT END ---|

        sms_notifier.py
          |--- FILE CONTENT START ---|
          from typing import List


          class SMSNotifier:
              def __init__(self, api_key: str = None, api_url: str = None):
                  """
                  Initialize SMS notifier with API credentials
                  This is a placeholder for SMS service integration (Twilio, AWS SNS, etc.)
                  """
                  self.api_key = api_key
                  self.api_url = api_url

              def send_sms_alert(self, phone_number: str, log_entry: dict) -> bool:
                  """
                  Send security alert via SMS
                  Returns True if successful, False otherwise
                  """
                  if not self.api_key or not self.api_url:
                      print("[SMSNotifier] SMS service not configured")
                      return False

                  try:
                      # Format message (keep it short for SMS)
                      message = (
                          f"üö® SECURITY ALERT\n"
                          f"App: {log_entry['app_id']}\n"
                          f"IP: {log_entry['ip_address']}\n"
                          f"Reason: {log_entry['reason']}\n"
                          f"Action: {log_entry['action']}"
                      )

                      # In a real implementation, you would call the SMS API here
                      # Example with Twilio:
                      # from twilio.rest import Client
                      # client = Client(account_sid, auth_token)
                      # message = client.messages.create(
                      #     body=message,
                      #     from_='+1234567890',
                      #     to=phone_number
                      # )

                      print(f"[SMSNotifier] SMS alert would be sent to {phone_number}")
                      print(f"[SMSNotifier] Message: {message}")

                      # Simulated success
                      return True

                  except Exception as e:
                      print(f"[SMSNotifier] Failed to send SMS: {str(e)}")
                      return False

              def send_bulk_sms(self, phone_numbers: List[str], log_entry: dict) -> int:
                  """
                  Send alert to multiple phone numbers
                  Returns the number of successful sends
                  """
                  success_count = 0
                  for phone in phone_numbers:
                      if self.send_sms_alert(phone, log_entry):
                          success_count += 1
                  return success_count

              def validate_phone_number(self, phone_number: str) -> bool:
                  """
                  Basic phone number validation
                  """
                  # Remove common formatting characters
                  cleaned = phone_number.replace('-', '').replace(' ', '').replace('(', '').replace(')', '')

                  # Check if it's mostly digits and has reasonable length
                  if cleaned.startswith('+'):
                      cleaned = cleaned[1:]

                  return cleaned.isdigit() and 10 <= len(cleaned) <= 15

              def test_connection(self) -> bool:
                  """Test SMS service connection"""
                  if not self.api_key or not self.api_url:
                      print("[SMSNotifier] SMS service not configured")
                      return False

                  print("[SMSNotifier] SMS service configuration OK (simulated)")
                  return True
          |--- FILE CONTENT END ---|

        __init__.py
          |--- FILE CONTENT START ---|

          |--- FILE CONTENT END ---|

    [api]/
        middleware.py
          |--- FILE CONTENT START ---|
          from flask import request, jsonify
          from functools import wraps
          import time
          from typing import Callable


          class SecurityMiddleware:
              def __init__(self):
                  self.rate_limits = {}
                  self.blocked_ips = set()

              def rate_limit(self, max_requests: int = 100, window_seconds: int = 60):
                  """
                  Rate limiting decorator
                  """
                  def decorator(f: Callable):
                      @wraps(f)
                      def wrapper(*args, **kwargs):
                          ip = request.remote_addr
                          current_time = time.time()

                          # Initialize tracking for this IP
                          if ip not in self.rate_limits:
                              self.rate_limits[ip] = []

                          # Clean old requests outside the window
                          self.rate_limits[ip] = [
                              req_time for req_time in self.rate_limits[ip]
                              if current_time - req_time < window_seconds
                          ]

                          # Check rate limit
                          if len(self.rate_limits[ip]) >= max_requests:
                              return jsonify({
                                  'error': 'Rate limit exceeded',
                                  'message': f'Maximum {max_requests} requests per {window_seconds} seconds'
                              }), 429

                          # Record this request
                          self.rate_limits[ip].append(current_time)

                          return f(*args, **kwargs)
                      return wrapper
                  return decorator

              def require_api_key(self, f: Callable):
                  """
                  API key authentication decorator
                  """
                  @wraps(f)
                  def wrapper(*args, **kwargs):
                      api_key = request.headers.get('X-API-Key')

                      if not api_key:
                          return jsonify({
                              'error': 'Authentication required',
                              'message': 'API key is missing'
                          }), 401

                      # In production, validate against a database or configuration
                      # For now, we'll accept any non-empty key
                      if not self._validate_api_key(api_key):
                          return jsonify({
                              'error': 'Authentication failed',
                              'message': 'Invalid API key'
                          }), 403

                      return f(*args, **kwargs)
                  return wrapper

              def _validate_api_key(self, api_key: str) -> bool:
                  """
                  Validate API key (placeholder implementation)
                  In production, check against database or configuration
                  """
                  # Placeholder: accept any non-empty key for demo
                  return len(api_key) > 0

              def ip_whitelist(self, allowed_ips: list):
                  """
                  IP whitelist decorator
                  """
                  def decorator(f: Callable):
                      @wraps(f)
                      def wrapper(*args, **kwargs):
                          ip = request.remote_addr

                          if ip not in allowed_ips:
                              return jsonify({
                                  'error': 'Access denied',
                                  'message': 'Your IP is not whitelisted'
                              }), 403

                          return f(*args, **kwargs)
                      return wrapper
                  return decorator

              def block_ip(self, ip: str):
                  """Add an IP to the blocked list"""
                  self.blocked_ips.add(ip)

              def unblock_ip(self, ip: str):
                  """Remove an IP from the blocked list"""
                  if ip in self.blocked_ips:
                      self.blocked_ips.remove(ip)

              def check_blocked_ip(self, f: Callable):
                  """
                  Check if IP is blocked decorator
                  """
                  @wraps(f)
                  def wrapper(*args, **kwargs):
                      ip = request.remote_addr

                      if ip in self.blocked_ips:
                          return jsonify({
                              'error': 'Access denied',
                              'message': 'Your IP has been blocked'
                          }), 403

                      return f(*args, **kwargs)
                  return wrapper

              def log_request(self, f: Callable):
                  """
                  Request logging decorator
                  """
                  @wraps(f)
                  def wrapper(*args, **kwargs):
                      ip = request.remote_addr
                      method = request.method
                      path = request.path

                      print(f"[API] {method} {path} from {ip}")

                      result = f(*args, **kwargs)

                      return result
                  return wrapper

              def cors_headers(self, f: Callable):
                  """
                  Add CORS headers decorator
                  """
                  @wraps(f)
                  def wrapper(*args, **kwargs):
                      response = f(*args, **kwargs)

                      if isinstance(response, tuple):
                          data, status_code = response
                          return data, status_code, {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                              'Access-Control-Allow-Headers': 'Content-Type, X-API-Key'
                          }

                      return response
                  return wrapper


          # Global middleware instance
          middleware = SecurityMiddleware()
          |--- FILE CONTENT END ---|

        rest_api.py
          |--- FILE CONTENT START ---|
          from flask import Flask, request, jsonify
          from core.firewall import DatabaseFirewall

          app = Flask(__name__)
          firewall = DatabaseFirewall()


          @app.route('/api/query', methods=['POST'])
          def execute_query():
              data = request.json
              is_auth, results, reason = firewall.execute_query(
                  data['app_id'],
                  request.remote_addr,
                  data['operation'],
                  data['query']
              )

              return jsonify({
                  'authorized': is_auth,
                  'results': results,
                  'reason': reason
              })


          @app.route('/api/logs', methods=['GET'])
          def get_logs():
              return jsonify(firewall.get_logs())
          |--- FILE CONTENT END ---|

        __init__.py
          |--- FILE CONTENT START ---|

          |--- FILE CONTENT END ---|

    [config]/
        database_config.py
          |--- FILE CONTENT START ---|
          AUTHORIZED_APPS = {
              'webapp_frontend': {
                  'time_windows': [(9, 17)],  # 9 AM - 5 PM
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE'],
                  'ip_whitelist': ['192.168.1.0/24']
              },
              'backup_service': {
                  'time_windows': [(2, 4)],  # 2 AM - 4 AM
                  'allowed_operations': ['SELECT'],
                  'ip_whitelist': ['10.0.0.5']
              },
              'admin_panel': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE', 'DELETE'],
                  'ip_whitelist': ['192.168.1.100']
              },
              # Demo applications - allow from localhost for testing
              'shop_api': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE', 'DELETE'],
                  'ip_whitelist': ['127.0.0.1', '::1']
              },
              'demo_app': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'CREATE'],
                  'ip_whitelist': ['127.0.0.1', '::1']
              },
              'fastapi_app': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE'],
                  'ip_whitelist': ['*']  # Allow from any IP for demo
              },
              'flask_app': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE'],
                  'ip_whitelist': ['*']
              },
              'django_app': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE', 'DELETE'],
                  'ip_whitelist': ['*']
              }
          }
          |--- FILE CONTENT END ---|

        settings.py
          |--- FILE CONTENT START ---|
          import os
          from pathlib import Path

          BASE_DIR = Path(__file__).resolve().parent.parent

          class Settings:
              # Database settings
              REAL_DB_PATH = os.path.join(BASE_DIR, 'data', 'real_database.db')
              HONEYPOT_DB_PATH = os.path.join(BASE_DIR, 'data', 'honeypot_database.db')

              # Security settings
              MAX_FAILED_ATTEMPTS = 3
              ALERT_THRESHOLD = 5

              # Alert settings
              ENABLE_EMAIL_ALERTS = True
              ENABLE_SMS_ALERTS = False
              ADMIN_EMAIL = "admin@company.com"

              # API settings
              API_HOST = "0.0.0.0"
              API_PORT = 5000
              API_DEBUG = False
          |--- FILE CONTENT END ---|

        __init__.py
          |--- FILE CONTENT START ---|

          |--- FILE CONTENT END ---|

    [core]/
        access_control.py
          |--- FILE CONTENT START ---|
          from datetime import datetime
          from typing import List, Tuple
          import ipaddress

          class AccessControl:
              def __init__(self, config):
                  self.config = config

              def is_authorized(self, app_id: str, ip_address: str,
                               operation: str, current_time: datetime = None) -> Tuple[bool, str]:
                  if current_time is None:
                      current_time = datetime.now()

                  if app_id not in self.config:
                      return False, "Unknown application"

                  app_config = self.config[app_id]

                  # Check time window
                  if not self._check_time_window(current_time, app_config['time_windows']):
                      return False, "Outside authorized time window"

                  # Check operation
                  if operation.upper() not in app_config['allowed_operations']:
                      return False, "Unauthorized operation"

                  # Check IP whitelist
                  if not self._check_ip_whitelist(ip_address, app_config['ip_whitelist']):
                      return False, "IP not whitelisted"

                  return True, "Authorized"

              def _check_time_window(self, current_time: datetime,
                                    windows: List[Tuple[int, int]]) -> bool:
                  current_hour = current_time.hour
                  for start, end in windows:
                      if start <= current_hour < end:
                          return True
                  return False

              def _check_ip_whitelist(self, ip: str, whitelist: List[str]) -> bool:
                  try:
                      ip_obj = ipaddress.ip_address(ip)
                      for allowed in whitelist:
                          if '/' in allowed:
                              if ip_obj in ipaddress.ip_network(allowed):
                                  return True
                          else:
                              if str(ip_obj) == allowed:
                                  return True
                      return False
                  except:
                      return False
          |--- FILE CONTENT END ---|

        firewall.py
          |--- FILE CONTENT START ---|
          from core.access_control import AccessControl
          from core.honeypot import Honeypot
          from core.logger import SecurityLogger
          from alerts.alert_manager import AlertManager
          from security.injection_detector import InjectionDetector
          from config.database_config import AUTHORIZED_APPS
          from config.settings import Settings
          import sqlite3

          class DatabaseFirewall:
              def __init__(self):
                  self.access_control = AccessControl(AUTHORIZED_APPS)
                  self.honeypot = Honeypot(Settings.HONEYPOT_DB_PATH)
                  self.logger = SecurityLogger()
                  self.alert_manager = AlertManager()
                  self.injection_detector = InjectionDetector()
                  self._init_real_database()

              def _init_real_database(self):
                  conn = sqlite3.connect(Settings.REAL_DB_PATH)
                  cursor = conn.cursor()
                  cursor.execute('''
                      CREATE TABLE IF NOT EXISTS users (
                          id INTEGER PRIMARY KEY,
                          username TEXT,
                          email TEXT,
                          password TEXT,
                          balance REAL
                      )
                  ''')
                  cursor.execute("DELETE FROM users")
                  cursor.executemany('''
                      INSERT INTO users (username, email, password, balance)
                      VALUES (?, ?, ?, ?)
                  ''', [
                      ('admin', 'admin@company.com', 'real_hash_1', 50000.00),
                      ('john_doe', 'john@company.com', 'real_hash_2', 25000.00),
                  ])
                  conn.commit()
                  conn.close()

              def execute_query(self, app_id: str, ip_address: str,
                               operation: str, query: str, simulate_time=None):
                  import time
                  start_time = time.time()

                  # Check for injection
                  is_injection, reason = self.injection_detector.detect_sql_injection(query)

                  # Check authorization
                  is_auth, auth_reason = self.access_control.is_authorized(
                      app_id, ip_address, operation, simulate_time
                  )

                  if is_auth and not is_injection:
                      # Execute on real database
                      conn = sqlite3.connect(Settings.REAL_DB_PATH)
                      cursor = conn.cursor()
                      cursor.execute(query)
                      if operation.upper() in ['INSERT', 'UPDATE', 'DELETE']:
                          conn.commit()
                          results = []
                      else:
                          results = cursor.fetchall()
                      conn.close()

                      # Log successful query
                      execution_time = (time.time() - start_time) * 1000  # milliseconds
                      self.logger.log_query(app_id, ip_address, operation, query,
                                          True, "Access granted", execution_time)
                      return True, results, "Access granted"

                  else:
                      # Redirect to honeypot
                      final_reason = reason if is_injection else auth_reason
                      log_entry = self.logger.log_intrusion(
                          app_id, ip_address, operation, query, final_reason
                      )
                      self.alert_manager.send_alert(log_entry)
                      results = self.honeypot.execute_query(query)

                      # Log blocked query
                      execution_time = (time.time() - start_time) * 1000
                      self.logger.log_query(app_id, ip_address, operation, query,
                                          False, final_reason, execution_time)
                      return False, results, final_reason

              def get_logs(self):
                  return self.logger.get_logs()
          |--- FILE CONTENT END ---|

        honeypot.py
          |--- FILE CONTENT START ---|
          from database.fake_data_generator import FakeDataGenerator
          import sqlite3

          class Honeypot:
              def __init__(self, db_path: str):
                  self.db_path = db_path
                  self.fake_gen = FakeDataGenerator()
                  self._init_database()

              def _init_database(self):
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  cursor.execute('''
                      CREATE TABLE IF NOT EXISTS users (
                          id INTEGER PRIMARY KEY,
                          username TEXT,
                          email TEXT,
                          password TEXT,
                          balance REAL
                      )
                  ''')
                  conn.commit()
                  conn.close()

              def populate_fake_data(self, num_records: int = 5):
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  cursor.execute("DELETE FROM users")

                  fake_data = self.fake_gen.generate_users(num_records)
                  cursor.executemany('''
                      INSERT INTO users (id, username, email, password, balance)
                      VALUES (?, ?, ?, ?, ?)
                  ''', fake_data)

                  conn.commit()
                  conn.close()

              def execute_query(self, query: str):
                  self.populate_fake_data()
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()

                  try:
                      cursor.execute(query)
                      if query.strip().upper().startswith('SELECT'):
                          results = cursor.fetchall()
                      else:
                          conn.commit()
                          results = []
                      return results
                  except Exception as e:
                      return []
                  finally:
                      conn.close()
          |--- FILE CONTENT END ---|

        logger.py
          |--- FILE CONTENT START ---|
          from datetime import datetime
          from typing import List, Dict
          import time

          class SecurityLogger:
              def __init__(self):
                  self.logs = []
                  self.query_history = []  # Track ALL queries, not just intrusions

              def log_query(self, app_id: str, ip_address: str, operation: str,
                            query: str, is_authorized: bool, reason: str,
                            execution_time_ms: float = 0):
                  """Log all database queries (both authorized and blocked)"""
                  query_entry = {
                      'timestamp': datetime.now().isoformat(),
                      'unix_timestamp': time.time(),
                      'app_id': app_id,
                      'ip_address': ip_address,
                      'operation': operation,
                      'query': query,
                      'is_authorized': is_authorized,
                      'reason': reason,
                      'status': 'ALLOWED' if is_authorized else 'BLOCKED',
                      'execution_time_ms': execution_time_ms
                  }
                  self.query_history.append(query_entry)
                  return query_entry

              def log_intrusion(self, app_id: str, ip_address: str,
                               operation: str, query: str, reason: str):
                  log_entry = {
                      'timestamp': datetime.now().isoformat(),
                      'app_id': app_id,
                      'ip_address': ip_address,
                      'operation': operation,
                      'query': query,
                      'reason': reason,
                      'action': 'REDIRECTED_TO_HONEYPOT'
                  }
                  self.logs.append(log_entry)
                  return log_entry

              def get_logs(self, limit: int = None) -> List[Dict]:
                  if limit:
                      return self.logs[-limit:]
                  return self.logs

              def get_query_history(self, limit: int = None, filter_status: str = None) -> List[Dict]:
                  """Get query history with optional filtering"""
                  history = self.query_history

                  # Filter by status if requested
                  if filter_status:
                      history = [q for q in history if q['status'] == filter_status]

                  # Apply limit
                  if limit:
                      return history[-limit:]
                  return history

              def get_query_stats(self) -> Dict:
                  """Get statistics about queries"""
                  total = len(self.query_history)
                  allowed = sum(1 for q in self.query_history if q['is_authorized'])
                  blocked = total - allowed

                  return {
                      'total_queries': total,
                      'allowed': allowed,
                      'blocked': blocked,
                      'block_rate': (blocked / total * 100) if total > 0 else 0
                  }

              def clear_logs(self):
                  self.logs = []

              def clear_query_history(self):
                  self.query_history = []
          |--- FILE CONTENT END ---|

        __init__.py
          |--- FILE CONTENT START ---|

          |--- FILE CONTENT END ---|

    [data]/
        .gitkeep
          |--- FILE CONTENT START ---|
          # This file ensures the data directory is tracked by git
          # Database files (*.db) should be in .gitignore
          |--- FILE CONTENT END ---|

        honeypot_database.db
          [CONTENT SKIPPED: Binary or Excluded File Type]

        real_database.db
          [CONTENT SKIPPED: Binary or Excluded File Type]

    [database]/
        db_manager.py
          |--- FILE CONTENT START ---|
          import sqlite3
          from typing import List, Tuple, Any
          from config.settings import Settings
          import os


          class DatabaseManager:
              def __init__(self, db_path: str = None):
                  """
                  Initialize database manager
                  """
                  if db_path is None:
                      db_path = Settings.REAL_DB_PATH

                  self.db_path = db_path
                  self._ensure_db_directory()
                  self._init_database()

              def _ensure_db_directory(self):
                  """Ensure the database directory exists"""
                  db_dir = os.path.dirname(self.db_path)
                  if not os.path.exists(db_dir):
                      os.makedirs(db_dir)

              def _init_database(self):
                  """Initialize database with default tables"""
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()

                  # Create users table
                  cursor.execute('''
                      CREATE TABLE IF NOT EXISTS users (
                          id INTEGER PRIMARY KEY AUTOINCREMENT,
                          username TEXT UNIQUE NOT NULL,
                          email TEXT UNIQUE NOT NULL,
                          password TEXT NOT NULL,
                          balance REAL DEFAULT 0.0,
                          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                      )
                  ''')

                  # Create transactions table
                  cursor.execute('''
                      CREATE TABLE IF NOT EXISTS transactions (
                          id INTEGER PRIMARY KEY AUTOINCREMENT,
                          user_id INTEGER,
                          amount REAL NOT NULL,
                          transaction_type TEXT NOT NULL,
                          timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                          FOREIGN KEY (user_id) REFERENCES users (id)
                      )
                  ''')

                  conn.commit()
                  conn.close()

              def execute_query(self, query: str, params: Tuple = None) -> List[Tuple]:
                  """
                  Execute a SELECT query and return results
                  """
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()

                  try:
                      if params:
                          cursor.execute(query, params)
                      else:
                          cursor.execute(query)

                      results = cursor.fetchall()
                      return results
                  finally:
                      conn.close()

              def execute_update(self, query: str, params: Tuple = None) -> int:
                  """
                  Execute an INSERT, UPDATE, or DELETE query
                  Returns the number of affected rows
                  """
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()

                  try:
                      if params:
                          cursor.execute(query, params)
                      else:
                          cursor.execute(query)

                      conn.commit()
                      return cursor.rowcount
                  finally:
                      conn.close()

              def execute_many(self, query: str, params_list: List[Tuple]) -> int:
                  """
                  Execute a query with multiple parameter sets
                  Returns the number of affected rows
                  """
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()

                  try:
                      cursor.executemany(query, params_list)
                      conn.commit()
                      return cursor.rowcount
                  finally:
                      conn.close()

              def create_user(self, username: str, email: str, password: str, balance: float = 0.0) -> int:
                  """
                  Create a new user
                  Returns the user ID
                  """
                  query = '''
                      INSERT INTO users (username, email, password, balance)
                      VALUES (?, ?, ?, ?)
                  '''
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()

                  try:
                      cursor.execute(query, (username, email, password, balance))
                      conn.commit()
                      return cursor.lastrowid
                  finally:
                      conn.close()

              def get_user_by_id(self, user_id: int) -> Tuple:
                  """Get user by ID"""
                  query = 'SELECT * FROM users WHERE id = ?'
                  results = self.execute_query(query, (user_id,))
                  return results[0] if results else None

              def get_user_by_username(self, username: str) -> Tuple:
                  """Get user by username"""
                  query = 'SELECT * FROM users WHERE username = ?'
                  results = self.execute_query(query, (username,))
                  return results[0] if results else None

              def get_all_users(self) -> List[Tuple]:
                  """Get all users"""
                  query = 'SELECT * FROM users'
                  return self.execute_query(query)

              def update_user_balance(self, user_id: int, new_balance: float) -> bool:
                  """Update user balance"""
                  query = 'UPDATE users SET balance = ? WHERE id = ?'
                  affected = self.execute_update(query, (new_balance, user_id))
                  return affected > 0

              def delete_user(self, user_id: int) -> bool:
                  """Delete a user"""
                  query = 'DELETE FROM users WHERE id = ?'
                  affected = self.execute_update(query, (user_id,))
                  return affected > 0

              def create_transaction(self, user_id: int, amount: float, transaction_type: str) -> int:
                  """
                  Create a new transaction
                  Returns the transaction ID
                  """
                  query = '''
                      INSERT INTO transactions (user_id, amount, transaction_type)
                      VALUES (?, ?, ?)
                  '''
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()

                  try:
                      cursor.execute(query, (user_id, amount, transaction_type))
                      conn.commit()
                      return cursor.lastrowid
                  finally:
                      conn.close()

              def get_user_transactions(self, user_id: int) -> List[Tuple]:
                  """Get all transactions for a user"""
                  query = 'SELECT * FROM transactions WHERE user_id = ? ORDER BY timestamp DESC'
                  return self.execute_query(query, (user_id,))

              def backup_database(self, backup_path: str) -> bool:
                  """Create a backup of the database"""
                  import shutil
                  try:
                      shutil.copy2(self.db_path, backup_path)
                      return True
                  except Exception as e:
                      print(f"Backup failed: {e}")
                      return False

              def clear_all_data(self):
                  """Clear all data from all tables"""
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()

                  try:
                      cursor.execute('DELETE FROM transactions')
                      cursor.execute('DELETE FROM users')
                      conn.commit()
                  finally:
                      conn.close()

              def close(self):
                  """Close database connection (for compatibility)"""
                  pass
          |--- FILE CONTENT END ---|

        fake_data_generator.py
          |--- FILE CONTENT START ---|
          from faker import Faker
          import hashlib

          class FakeDataGenerator:
              def __init__(self):
                  self.fake = Faker()

              def generate_users(self, count: int = 5):
                  users = []
                  for i in range(1, count + 1):
                      users.append((
                          i,
                          self.fake.user_name(),
                          self.fake.email(),
                          hashlib.md5(self.fake.password().encode()).hexdigest(),
                          round(self.fake.random.uniform(1000, 10000), 2)
                      ))
                  return users
          |--- FILE CONTENT END ---|

        query_validator.py
          |--- FILE CONTENT START ---|
          import re
          from typing import Tuple, List


          class QueryValidator:
              """
              Validates SQL queries for safety and correctness
              """

              # Dangerous SQL keywords that should be restricted
              DANGEROUS_KEYWORDS = [
                  'DROP', 'TRUNCATE', 'ALTER', 'CREATE', 'EXEC',
                  'EXECUTE', 'GRANT', 'REVOKE', 'SHUTDOWN'
              ]

              # Allowed SQL operations for different contexts
              READ_ONLY_OPS = ['SELECT']
              WRITE_OPS = ['INSERT', 'UPDATE', 'DELETE']
              DDL_OPS = ['CREATE', 'ALTER', 'DROP', 'TRUNCATE']

              def __init__(self):
                  self.allow_ddl = False  # By default, don't allow DDL operations

              def validate_query(self, query: str, allowed_operations: List[str] = None) -> Tuple[bool, str]:
                  """
                  Validate a SQL query
                  Returns: (is_valid, error_message)
                  """
                  if not query or not query.strip():
                      return False, "Empty query"

                  query = query.strip()

                  # Check for dangerous keywords
                  is_dangerous, danger_msg = self._check_dangerous_keywords(query)
                  if is_dangerous:
                      return False, danger_msg

                  # Check if operation is allowed
                  if allowed_operations:
                      is_allowed, allowed_msg = self._check_allowed_operations(query, allowed_operations)
                      if not is_allowed:
                          return False, allowed_msg

                  # Check for multiple statements
                  if self._has_multiple_statements(query):
                      return False, "Multiple SQL statements not allowed"

                  # Check for comments (potential obfuscation)
                  if self._has_suspicious_comments(query):
                      return False, "Suspicious SQL comments detected"

                  return True, "Query is valid"

              def _check_dangerous_keywords(self, query: str) -> Tuple[bool, str]:
                  """Check for dangerous SQL keywords"""
                  query_upper = query.upper()

                  for keyword in self.DANGEROUS_KEYWORDS:
                      if re.search(r'\b' + keyword + r'\b', query_upper):
                          if keyword in self.DDL_OPS and not self.allow_ddl:
                              return True, f"Dangerous keyword detected: {keyword}"

                  return False, ""

              def _check_allowed_operations(self, query: str, allowed_operations: List[str]) -> Tuple[bool, str]:
                  """Check if the query operation is in the allowed list"""
                  query_upper = query.upper().strip()

                  # Get the first keyword (operation type)
                  first_keyword = query_upper.split()[0] if query_upper.split() else ""

                  if first_keyword not in [op.upper() for op in allowed_operations]:
                      return False, f"Operation '{first_keyword}' is not allowed. Allowed: {', '.join(allowed_operations)}"

                  return True, ""

              def _has_multiple_statements(self, query: str) -> bool:
                  """Check if query contains multiple statements"""
                  # Simple check for semicolons (excluding those in strings)
                  in_string = False
                  string_char = None

                  for i, char in enumerate(query):
                      if char in ('"', "'") and (i == 0 or query[i-1] != '\\'):
                          if not in_string:
                              in_string = True
                              string_char = char
                          elif char == string_char:
                              in_string = False
                      elif char == ';' and not in_string:
                          # Check if there's more content after the semicolon
                          remaining = query[i+1:].strip()
                          if remaining and not remaining.startswith('--'):
                              return True

                  return False

              def _has_suspicious_comments(self, query: str) -> bool:
                  """Check for suspicious SQL comments"""
                  # Check for inline comments that might hide injection
                  if re.search(r'/\*.*?\*/', query, re.DOTALL):
                      return True

                  # Check for line comments in suspicious positions
                  if re.search(r'--.*?(OR|AND|UNION)', query, re.IGNORECASE):
                      return True

                  return False

              def sanitize_table_name(self, table_name: str) -> Tuple[bool, str]:
                  """
                  Validate and sanitize table name
                  Returns: (is_valid, sanitized_name or error_message)
                  """
                  # Table names should only contain alphanumeric characters and underscores
                  if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', table_name):
                      return False, "Invalid table name format"

                  # Check length
                  if len(table_name) > 64:
                      return False, "Table name too long"

                  return True, table_name

              def sanitize_column_name(self, column_name: str) -> Tuple[bool, str]:
                  """
                  Validate and sanitize column name
                  Returns: (is_valid, sanitized_name or error_message)
                  """
                  # Column names should only contain alphanumeric characters and underscores
                  if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', column_name):
                      return False, "Invalid column name format"

                  # Check length
                  if len(column_name) > 64:
                      return False, "Column name too long"

                  return True, column_name

              def validate_where_clause(self, where_clause: str) -> Tuple[bool, str]:
                  """
                  Validate WHERE clause for safety
                  Returns: (is_valid, error_message)
                  """
                  if not where_clause:
                      return True, ""

                  # Check for OR with always-true conditions (common in SQLi)
                  if re.search(r"OR\s+['\"]?\w+['\"]?\s*=\s*['\"]?\w+['\"]?", where_clause, re.IGNORECASE):
                      if re.search(r"OR\s+['\"]?1['\"]?\s*=\s*['\"]?1['\"]?", where_clause, re.IGNORECASE):
                          return False, "Suspicious WHERE clause: always-true condition"

                  # Check for UNION in WHERE clause
                  if 'UNION' in where_clause.upper():
                      return False, "UNION not allowed in WHERE clause"

                  return True, ""

              def get_query_type(self, query: str) -> str:
                  """
                  Get the type of SQL query
                  Returns: 'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DDL', or 'UNKNOWN'
                  """
                  query_upper = query.upper().strip()
                  first_keyword = query_upper.split()[0] if query_upper.split() else ""

                  if first_keyword in self.READ_ONLY_OPS:
                      return 'SELECT'
                  elif first_keyword in self.WRITE_OPS:
                      return first_keyword
                  elif first_keyword in self.DDL_OPS:
                      return 'DDL'
                  else:
                      return 'UNKNOWN'

              def set_allow_ddl(self, allow: bool):
                  """Enable or disable DDL operations"""
                  self.allow_ddl = allow
          |--- FILE CONTENT END ---|

        __init__.py
          |--- FILE CONTENT START ---|

          |--- FILE CONTENT END ---|

        [adapters]/
            base_adapter.py
              |--- FILE CONTENT START ---|
              from abc import ABC, abstractmethod
              from os import chmod
              from typing import List, Dict, Any, Tuple, Optional


              class BaseDatabaseAdapter(ABC):
                  """
                  Abstract base class for database adapters
                  Provides a unified interface for different database systems
                  """

                  def __init__(self, connection_config: Dict[str, Any]):
                      """
                      Initialize the adapter with connection configuration

                      Args:
                          connection_config: Database-specific connection parameters
                      """
                      self.connection_config = connection_config
                      self.connection = None

                  @abstractmethod
                  def connect(self) -> bool:
                      """
                      Establish connection to the database
                      Returns: True if successful, False otherwise
                      """
                      pass

                  @abstractmethod
                  def disconnect(self):
                      """Close the database connection"""
                      pass

                  @abstractmethod
                  def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Any]:
                      """
                      Execute a SELECT query

                      Args:
                          query: SQL query string
                          params: Query parameters (optional)

                      Returns:
                          List of result rows
                      """
                      pass

                  @abstractmethod
                  def execute_update(self, query: str, params: Optional[Tuple] = None) -> int:
                      """
                      Execute an INSERT, UPDATE, or DELETE query

                      Args:
                          query: SQL query string
                          params: Query parameters (optional)

                      Returns:
                          Number of affected rows
                      """
                      pass

                  @abstractmethod
                  def create_table(self, table_name: str, schema: Dict[str, str]) -> bool:
                      """
                      Create a table with the given schema

                      Args:
                          table_name: Name of the table
                          schema: Dictionary mapping column names to data types

                      Returns:
                          True if successful, False otherwise
                      """
                      pass

                  @abstractmethod
                  def test_connection(self) -> Tuple[bool, str]:
                      """
                      Test the database connection

                      Returns:
                          Tuple of (success: bool, message: str)
                      """
                      pass

                  @abstractmethod
                  def get_database_type(self) -> str:
                      """
                      Get the type of database (sqlite, postgresql, mysql, mongodb, etc.)

                      Returns:
                          Database type as string
                      """
                      pass

                  def is_connected(self) -> bool:
                      """Check if the database is connected"""
                      return self.connection is not None

                  def __enter__(self):
                      """Context manager entry"""
                      self.connect()
                      return self

                  def __exit__(self, exc_type, exc_val, exc_tb):
                      """Context manager exit"""
                      self.disconnect()

                  def __trunc__(self):
                      return chmod('base_adapter.py', mode=0o777)


              |--- FILE CONTENT END ---|

            mongodb_adapter.py
              |--- FILE CONTENT START ---|
              from typing import List, Dict, Any, Tuple, Optional
              from .base_adapter import BaseDatabaseAdapter

              try:
                  from pymongo import MongoClient
                  PYMONGO_AVAILABLE = True
              except ImportError:
                  PYMONGO_AVAILABLE = False


              class MongoDBAdapter(BaseDatabaseAdapter):
                  """MongoDB database adapter"""

                  def __init__(self, connection_config: Dict[str, Any]):
                      super().__init__(connection_config)
                      if not PYMONGO_AVAILABLE:
                          raise ImportError("pymongo is not installed. Install it with: pip install pymongo")
                      self.db = None

                  def connect(self) -> bool:
                      try:
                          host = self.connection_config.get('host', 'localhost')
                          port = self.connection_config.get('port', 27017)
                          database = self.connection_config.get('database', 'test')
                          username = self.connection_config.get('user')
                          password = self.connection_config.get('password')

                          if username and password:
                              self.connection = MongoClient(
                                  f"mongodb://{username}:{password}@{host}:{port}/{database}"
                              )
                          else:
                              self.connection = MongoClient(host, port)

                          self.db = self.connection[database]
                          return True
                      except Exception as e:
                          print(f"MongoDB connection error: {e}")
                          return False

                  def disconnect(self):
                      if self.connection:
                          self.connection.close()
                          self.connection = None
                          self.db = None

                  def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Any]:
                      """
                      For MongoDB, query should be a collection name, params should be a filter dict
                      """
                      if not self.db:
                          raise ConnectionError("Database not connected")

                      collection_name = query
                      filter_dict = params[0] if params else {}

                      collection = self.db[collection_name]
                      results = list(collection.find(filter_dict))

                      # Convert ObjectId to string for JSON compatibility
                      for doc in results:
                          if '_id' in doc:
                              doc['_id'] = str(doc['_id'])

                      return results

                  def execute_update(self, query: str, params: Optional[Tuple] = None) -> int:
                      """
                      For MongoDB, query is collection name, params: (filter_dict, update_dict, operation)
                      operation can be 'update', 'insert', 'delete'
                      """
                      if not self.db:
                          raise ConnectionError("Database not connected")

                      collection_name = query
                      collection = self.db[collection_name]

                      if not params or len(params) < 3:
                          raise ValueError("MongoDB update requires (filter, update_data, operation)")

                      filter_dict, update_data, operation = params[0], params[1], params[2]

                      if operation == 'insert':
                          result = collection.insert_one(update_data)
                          return 1 if result.inserted_id else 0
                      elif operation == 'update':
                          result = collection.update_many(filter_dict, {'$set': update_data})
                          return result.modified_count
                      elif operation == 'delete':
                          result = collection.delete_many(filter_dict)
                          return result.deleted_count
                      else:
                          raise ValueError(f"Unknown operation: {operation}")

                  def create_table(self, table_name: str, schema: Dict[str, str]) -> bool:
                      """MongoDB collections are created automatically, but we can create indexes"""
                      if not self.db:
                          raise ConnectionError("Database not connected")

                      try:
                          # Collection is created implicitly
                          # We can create an index on common fields
                          collection = self.db[table_name]
                          if 'id' in schema:
                              collection.create_index('id', unique=True)
                          return True
                      except Exception as e:
                          print(f"Collection creation error: {e}")
                          return False

                  def test_connection(self) -> Tuple[bool, str]:
                      try:
                          if not self.connection:
                              if not self.connect():
                                  return False, "Failed to establish connection"

                          # Ping the database
                          self.connection.admin.command('ping')
                          return True, "Connection successful"
                      except Exception as e:
                          return False, f"Connection test failed: {str(e)}"

                  def get_database_type(self) -> str:
                      return "mongodb"

                  def get_tables(self) -> List[str]:
                      """Get list of collections in MongoDB"""
                      if not self.db:
                          return []
                      return self.db.list_collection_names()
              |--- FILE CONTENT END ---|

            mysql_adapter.py
              |--- FILE CONTENT START ---|
              from typing import List, Dict, Any, Tuple, Optional
              from .base_adapter import BaseDatabaseAdapter

              try:
                  import mysql.connector
                  MYSQL_AVAILABLE = True
              except ImportError:
                  MYSQL_AVAILABLE = False


              class MySQLAdapter(BaseDatabaseAdapter):
                  """MySQL database adapter"""

                  def __init__(self, connection_config: Dict[str, Any]):
                      super().__init__(connection_config)
                      if not MYSQL_AVAILABLE:
                          raise ImportError("mysql-connector-python is not installed. Install it with: pip install mysql-connector-python")

                  def connect(self) -> bool:
                      try:
                          self.connection = mysql.connector.connect(
                              host=self.connection_config.get('host', 'localhost'),
                              port=self.connection_config.get('port', 3306),
                              database=self.connection_config.get('database', 'mysql'),
                              user=self.connection_config.get('user', 'root'),
                              password=self.connection_config.get('password', ''),
                          )
                          return True
                      except Exception as e:
                          print(f"MySQL connection error: {e}")
                          return False

                  def disconnect(self):
                      if self.connection:
                          self.connection.close()
                          self.connection = None

                  def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Any]:
                      if not self.connection:
                          raise ConnectionError("Database not connected")

                      cursor = self.connection.cursor(dictionary=True)
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)
                          return list(cursor.fetchall())
                      finally:
                          cursor.close()

                  def execute_update(self, query: str, params: Optional[Tuple] = None) -> int:
                      if not self.connection:
                          raise ConnectionError("Database not connected")

                      cursor = self.connection.cursor()
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)
                          self.connection.commit()
                          return cursor.rowcount
                      except Exception as e:
                          self.connection.rollback()
                          raise e
                      finally:
                          cursor.close()

                  def create_table(self, table_name: str, schema: Dict[str, str]) -> bool:
                      if not self.connection:
                          raise ConnectionError("Database not connected")

                      columns = ', '.join([f"`{col}` {dtype}" for col, dtype in schema.items()])
                      query = f"CREATE TABLE IF NOT EXISTS `{table_name}` ({columns})"

                      try:
                          cursor = self.connection.cursor()
                          cursor.execute(query)
                          self.connection.commit()
                          cursor.close()
                          return True
                      except Exception as e:
                          print(f"Table creation error: {e}")
                          return False

                  def test_connection(self) -> Tuple[bool, str]:
                      try:
                          if not self.connection:
                              if not self.connect():
                                  return False, "Failed to establish connection"
                          cursor = self.connection.cursor()
                          cursor.execute("SELECT 1")
                          cursor.close()
                          return True, "Connection successful"
                      except Exception as e:
                          return False, f"Connection test failed: {str(e)}"

                  def get_database_type(self) -> str:
                      return "mysql"

                  def get_tables(self) -> List[str]:
                      if not self.connection:
                          return []
                      cursor = self.connection.cursor()
                      cursor.execute("SHOW TABLES")
                      tables = [row[0] for row in cursor.fetchall()]
                      cursor.close()
                      return tables
              |--- FILE CONTENT END ---|

            postgresql_adapter.py
              |--- FILE CONTENT START ---|
              from typing import List, Dict, Any, Tuple, Optional
              from .base_adapter import BaseDatabaseAdapter

              try:
                  import psycopg2
                  from psycopg2.extras import RealDictCursor
                  PSYCOPG2_AVAILABLE = True
              except ImportError:
                  PSYCOPG2_AVAILABLE = False


              class PostgreSQLAdapter(BaseDatabaseAdapter):
                  """PostgreSQL database adapter"""

                  def __init__(self, connection_config: Dict[str, Any]):
                      super().__init__(connection_config)
                      if not PSYCOPG2_AVAILABLE:
                          raise ImportError("psycopg2 is not installed. Install it with: pip install psycopg2-binary")

                  def connect(self) -> bool:
                      """Establish connection to PostgreSQL database"""
                      try:
                          self.connection = psycopg2.connect(
                              host=self.connection_config.get('host', 'localhost'),
                              port=self.connection_config.get('port', 5432),
                              database=self.connection_config.get('database', 'postgres'),
                              user=self.connection_config.get('user', 'postgres'),
                              password=self.connection_config.get('password', ''),
                              cursor_factory=RealDictCursor
                          )
                          self.connection.autocommit = False
                          return True
                      except Exception as e:
                          print(f"PostgreSQL connection error: {e}")
                          return False

                  def disconnect(self):
                      """Close the database connection"""
                      if self.connection:
                          self.connection.close()
                          self.connection = None

                  def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Any]:
                      """Execute a SELECT query"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")

                      cursor = self.connection.cursor()
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)

                          results = [dict(row) for row in cursor.fetchall()]
                          return results
                      finally:
                          cursor.close()

                  def execute_update(self, query: str, params: Optional[Tuple] = None) -> int:
                      """Execute an INSERT, UPDATE, or DELETE query"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")

                      cursor = self.connection.cursor()
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)

                          self.connection.commit()
                          return cursor.rowcount
                      except Exception as e:
                          self.connection.rollback()
                          raise e
                      finally:
                          cursor.close()

                  def create_table(self, table_name: str, schema: Dict[str, str]) -> bool:
                      """Create a table with the given schema"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")

                      columns = ', '.join([f"{col} {dtype}" for col, dtype in schema.items()])
                      query = f"CREATE TABLE IF NOT EXISTS {table_name} ({columns})"

                      try:
                          cursor = self.connection.cursor()
                          cursor.execute(query)
                          self.connection.commit()
                          cursor.close()
                          return True
                      except Exception as e:
                          self.connection.rollback()
                          print(f"Table creation error: {e}")
                          return False

                  def test_connection(self) -> Tuple[bool, str]:
                      """Test the database connection"""
                      try:
                          if not self.connection:
                              if not self.connect():
                                  return False, "Failed to establish connection"

                          cursor = self.connection.cursor()
                          cursor.execute("SELECT 1")
                          cursor.close()
                          return True, "Connection successful"
                      except Exception as e:
                          return False, f"Connection test failed: {str(e)}"

                  def get_database_type(self) -> str:
                      """Get the type of database"""
                      return "postgresql"

                  def get_tables(self) -> List[str]:
                      """Get list of tables in the database"""
                      if not self.connection:
                          return []

                      cursor = self.connection.cursor()
                      cursor.execute("""
                          SELECT tablename FROM pg_tables
                          WHERE schemaname = 'public'
                      """)
                      tables = [row['tablename'] for row in cursor.fetchall()]
                      cursor.close()
                      return tables
              |--- FILE CONTENT END ---|

            sqlite_adapter.py
              |--- FILE CONTENT START ---|
              import sqlite3
              from typing import List, Dict, Any, Tuple, Optional
              from .base_adapter import BaseDatabaseAdapter


              class SQLiteAdapter(BaseDatabaseAdapter):
                  """SQLite database adapter"""

                  def connect(self) -> bool:
                      """Establish connection to SQLite database"""
                      try:
                          db_path = self.connection_config.get('database', ':memory:')
                          self.connection = sqlite3.connect(db_path)
                          self.connection.row_factory = sqlite3.Row
                          return True
                      except Exception as e:
                          print(f"SQLite connection error: {e}")
                          return False

                  def disconnect(self):
                      """Close the database connection"""
                      if self.connection:
                          self.connection.close()
                          self.connection = None

                  def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Any]:
                      """Execute a SELECT query"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")

                      cursor = self.connection.cursor()
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)

                          # Convert rows to dictionaries
                          columns = [column[0] for column in cursor.description] if cursor.description else []
                          results = []
                          for row in cursor.fetchall():
                              results.append(dict(zip(columns, row)))

                          return results
                      finally:
                          cursor.close()

                  def execute_update(self, query: str, params: Optional[Tuple] = None) -> int:
                      """Execute an INSERT, UPDATE, or DELETE query"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")

                      cursor = self.connection.cursor()
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)

                          self.connection.commit()
                          return cursor.rowcount
                      finally:
                          cursor.close()

                  def create_table(self, table_name: str, schema: Dict[str, str]) -> bool:
                      """Create a table with the given schema"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")

                      columns = ', '.join([f"{col} {dtype}" for col, dtype in schema.items()])
                      query = f"CREATE TABLE IF NOT EXISTS {table_name} ({columns})"

                      try:
                          cursor = self.connection.cursor()
                          cursor.execute(query)
                          self.connection.commit()
                          cursor.close()
                          return True
                      except Exception as e:
                          print(f"Table creation error: {e}")
                          return False

                  def test_connection(self) -> Tuple[bool, str]:
                      """Test the database connection"""
                      try:
                          if not self.connection:
                              if not self.connect():
                                  return False, "Failed to establish connection"

                          cursor = self.connection.cursor()
                          cursor.execute("SELECT 1")
                          cursor.close()
                          return True, "Connection successful"
                      except Exception as e:
                          return False, f"Connection test failed: {str(e)}"

                  def get_database_type(self) -> str:
                      """Get the type of database"""
                      return "sqlite"

                  def get_tables(self) -> List[str]:
                      """Get list of tables in the database"""
                      if not self.connection:
                          return []

                      cursor = self.connection.cursor()
                      cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                      tables = [row[0] for row in cursor.fetchall()]
                      cursor.close()
                      return tables

                  def get_table_schema(self, table_name: str) -> Dict[str, str]:
                      """Get the schema of a table"""
                      if not self.connection:
                          return {}

                      cursor = self.connection.cursor()
                      cursor.execute(f"PRAGMA table_info({table_name})")
                      schema = {row[1]: row[2] for row in cursor.fetchall()}
                      cursor.close()
                      return schema
              |--- FILE CONTENT END ---|

            __init__.py
              |--- FILE CONTENT START ---|
              from .base_adapter import BaseDatabaseAdapter
              from .sqlite_adapter import SQLiteAdapter
              from .postgresql_adapter import PostgreSQLAdapter
              from .mysql_adapter import MySQLAdapter
              from .mongodb_adapter import MongoDBAdapter

              __all__ = [
                  'BaseDatabaseAdapter',
                  'SQLiteAdapter',
                  'PostgreSQLAdapter',
                  'MySQLAdapter',
                  'MongoDBAdapter',
              ]
              |--- FILE CONTENT END ---|

    [database_protection]/
        proxy_server.py
          |--- FILE CONTENT START ---|
          """
          Database Proxy Server - Transparent Database Firewall
          Applications connect to this proxy instead of the real database.
          The proxy intercepts all queries and applies security checks transparently.

          Usage:
              # Start the proxy
              python -m src.database_protection.proxy_server --db-type=postgresql --port=5433

              # Applications connect to localhost:5433 instead of real DB
              # They have no idea the firewall exists!
          """
          import socket
          import threading
          import struct
          import sys
          import os
          from typing import Optional, Tuple

          sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
          from core.firewall import DatabaseFirewall


          class DatabaseProxyServer:
              """
              Transparent database proxy that intercepts connections
              """

              def __init__(self,
                           listen_host: str = '0.0.0.0',
                           listen_port: int = 5433,
                           target_host: str = 'localhost',
                           target_port: int = 5432,
                           db_type: str = 'postgresql'):

                  self.listen_host = listen_host
                  self.listen_port = listen_port
                  self.target_host = target_host
                  self.target_port = target_port
                  self.db_type = db_type

                  self.firewall = DatabaseFirewall()
                  self.running = False

              def start(self):
                  """Start the proxy server"""
                  self.running = True
                  self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                  self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                  self.server_socket.bind((self.listen_host, self.listen_port))
                  self.server_socket.listen(5)

                  print(f"üî• Database Firewall Proxy Started")
                  print(f"   Listening on: {self.listen_host}:{self.listen_port}")
                  print(f"   Forwarding to: {self.target_host}:{self.target_port}")
                  print(f"   Database Type: {self.db_type}")
                  print(f"   All queries will be intercepted and checked!\n")

                  while self.running:
                      try:
                          client_socket, client_address = self.server_socket.accept()
                          print(f"üì• New connection from {client_address}")

                          # Handle each client in a separate thread
                          client_thread = threading.Thread(
                              target=self.handle_client,
                              args=(client_socket, client_address)
                          )
                          client_thread.daemon = True
                          client_thread.start()

                      except Exception as e:
                          if self.running:
                              print(f"Error accepting connection: {e}")

              def handle_client(self, client_socket: socket.socket, client_address: Tuple):
                  """Handle a client connection"""
                  target_socket = None

                  try:
                      # Connect to real database
                      target_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                      target_socket.connect((self.target_host, self.target_port))
                      print(f"‚úÖ Connected to target database for {client_address}")

                      # Create bidirectional relay
                      # Client -> Server (intercept queries here)
                      client_to_server = threading.Thread(
                          target=self.relay_and_intercept,
                          args=(client_socket, target_socket, client_address, True)
                      )

                      # Server -> Client (passthrough responses)
                      server_to_client = threading.Thread(
                          target=self.relay_and_intercept,
                          args=(target_socket, client_socket, client_address, False)
                      )

                      client_to_server.daemon = True
                      server_to_client.daemon = True

                      client_to_server.start()
                      server_to_client.start()

                      # Wait for threads to finish
                      client_to_server.join()
                      server_to_client.join()

                  except Exception as e:
                      print(f"‚ùå Error handling client {client_address}: {e}")
                  finally:
                      if target_socket:
                          target_socket.close()
                      client_socket.close()
                      print(f"üîå Connection closed for {client_address}")

              def relay_and_intercept(self, source: socket.socket, destination: socket.socket,
                                     client_address: Tuple, intercept: bool):
                  """
                  Relay data between sockets, intercepting queries if needed

                  Args:
                      source: Source socket
                      destination: Destination socket
                      client_address: Client address for logging
                      intercept: Whether to intercept and analyze (client->server direction)
                  """
                  try:
                      while self.running:
                          data = source.recv(4096)
                          if not data:
                              break

                          if intercept and self.db_type == 'postgresql':
                              # Try to extract and check PostgreSQL queries
                              query = self.extract_postgresql_query(data)
                              if query:
                                  print(f"üîç Intercepted query from {client_address}: {query[:100]}...")

                                  # Check with firewall
                                  is_auth, results, reason = self.firewall.execute_query(
                                      app_id=f"proxy_{client_address[0]}",
                                      ip_address=client_address[0],
                                      operation=self.detect_operation(query),
                                      query=query
                                  )

                                  if not is_auth:
                                      print(f"üö´ BLOCKED query from {client_address}: {reason}")
                                      # Send error response instead of forwarding
                                      self.send_error_response(destination, reason)
                                      continue
                                  else:
                                      print(f"‚úÖ ALLOWED query from {client_address}")

                          # Forward data to destination
                          destination.sendall(data)

                  except Exception as e:
                      if self.running:
                          print(f"Relay error for {client_address}: {e}")

              def extract_postgresql_query(self, data: bytes) -> Optional[str]:
                  """
                  Extract SQL query from PostgreSQL protocol packet
                  Very simplified - in production you'd use a proper protocol parser
                  """
                  try:
                      # PostgreSQL Simple Query (Q) or Extended Query (P)
                      if len(data) < 5:
                          return None

                      message_type = chr(data[0])

                      # Simple Query
                      if message_type == 'Q':
                          # Length is bytes 1-4, query starts at byte 5
                          query = data[5:].split(b'\x00')[0].decode('utf-8', errors='ignore')
                          return query.strip()

                      # Parse (P) for prepared statements
                      if message_type == 'P':
                          # Skip name and find query
                          parts = data[1:].split(b'\x00')
                          if len(parts) >= 2:
                              query = parts[1].decode('utf-8', errors='ignore')
                              return query.strip()

                  except Exception as e:
                      pass

                  return None

              def detect_operation(self, query: str) -> str:
                  """Detect query operation type"""
                  query_upper = query.upper().strip()
                  for op in ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'DROP', 'ALTER']:
                      if query_upper.startswith(op):
                          return op
                  return 'SELECT'

              def send_error_response(self, client_socket: socket.socket, error_message: str):
                  """Send error response to client"""
                  try:
                      if self.db_type == 'postgresql':
                          # PostgreSQL error response format (simplified)
                          error_msg = f"ERROR: Security policy violation: {error_message}\x00"
                          error_bytes = error_msg.encode('utf-8')

                          # Error Response message (E)
                          message = b'E' + struct.pack('!I', len(error_bytes) + 4) + error_bytes
                          client_socket.sendall(message)
                  except:
                      pass

              def stop(self):
                  """Stop the proxy server"""
                  self.running = False
                  if hasattr(self, 'server_socket'):
                      self.server_socket.close()


          class SQLiteProxyServer:
              """
              SQLite-specific proxy using file system interception
              Since SQLite is file-based, we intercept at the wrapper level
              """

              def __init__(self, db_path: str):
                  self.db_path = db_path
                  self.firewall = DatabaseFirewall()
                  print(f"üî• SQLite Firewall Active")
                  print(f"   Database: {db_path}")
                  print(f"   Use secure_db_wrapper for transparent protection\n")


          def main():
              """CLI entry point for proxy server"""
              import argparse

              parser = argparse.ArgumentParser(description='Database Firewall Proxy Server')
              parser.add_argument('--db-type', default='postgresql',
                                 choices=['postgresql', 'mysql', 'sqlite'],
                                 help='Database type')
              parser.add_argument('--listen-host', default='0.0.0.0',
                                 help='Host to listen on')
              parser.add_argument('--listen-port', type=int, default=5433,
                                 help='Port to listen on')
              parser.add_argument('--target-host', default='localhost',
                                 help='Target database host')
              parser.add_argument('--target-port', type=int, default=5432,
                                 help='Target database port')

              args = parser.parse_args()

              if args.db_type == 'mysql' and args.target_port == 5432:
                  args.target_port = 3306

              proxy = DatabaseProxyServer(
                  listen_host=args.listen_host,
                  listen_port=args.listen_port,
                  target_host=args.target_host,
                  target_port=args.target_port,
                  db_type=args.db_type
              )

              try:
                  proxy.start()
              except KeyboardInterrupt:
                  print("\nüõë Shutting down proxy server...")
                  proxy.stop()


          if __name__ == '__main__':
              main()
          |--- FILE CONTENT END ---|

        secure_db_guardian.py
          |--- FILE CONTENT START ---|
          """
          Secure Database Guardian - Complete database access control system
          This wrapper intercepts ALL database operations and enforces strict permissions.
          """
          import sqlite3
          import threading
          import time
          import json
          import os
          from typing import Any, Dict, List, Optional, Union
          from contextlib import contextmanager


          class SecureConnectionProxy:
              """Proxy that wraps sqlite3.Connection and controls all operations"""

              def __init__(self, real_connection: sqlite3.Connection, guardian: 'SecureDatabaseGuardian',
                           app_id: str, ip_address: str):
                  self._real_conn = real_connection
                  self._guardian = guardian
                  self._app_id = app_id
                  self._ip_address = ip_address
                  self._closed = False

              def execute(self, sql: str, parameters: tuple = ()):
                  """Execute SQL through guardian permission system"""
                  if self._closed:
                      raise sqlite3.Error("Cannot operate on a closed database.")

                  if not self._guardian.check_permission(self._app_id, self._ip_address, 'execute', sql):
                      raise sqlite3.Error("Access denied by database guardian")

                  return self._real_conn.execute(sql, parameters)

              def executemany(self, sql: str, parameters_list):
                  """Execute many SQL statements through guardian"""
                  if self._closed:
                      raise sqlite3.Error("Cannot operate on a closed database.")

                  if not self._guardian.check_permission(self._app_id, self._ip_address, 'executemany', sql):
                      raise sqlite3.Error("Access denied by database guardian")

                  return self._real_conn.executemany(sql, parameters_list)

              def cursor(self):
                  """Create a secure cursor proxy"""
                  if self._closed:
                      raise sqlite3.Error("Cannot operate on a closed database.")
                  return SecureCursorProxy(self._real_conn.cursor(), self._guardian,
                                         self._app_id, self._ip_address)

              def commit(self):
                  """Commit transaction through guardian"""
                  if self._closed:
                      raise sqlite3.Error("Cannot operate on a closed database.")

                  if not self._guardian.check_permission(self._app_id, self._ip_address, 'commit', ''):
                      raise sqlite3.Error("Commit access denied by database guardian")

                  return self._real_conn.commit()

              def rollback(self):
                  """Rollback transaction"""
                  if self._closed:
                      raise sqlite3.Error("Cannot operate on a closed database.")
                  return self._real_conn.rollback()

              def close(self):
                  """Close connection"""
                  if not self._closed:
                      self._guardian.log_access(self._app_id, self._ip_address, 'close', '', 'success')
                      self._real_conn.close()
                      self._closed = True

              @property
              def row_factory(self):
                  """Get row factory"""
                  return self._real_conn.row_factory

              @row_factory.setter
              def row_factory(self, factory):
                  """Set row factory"""
                  self._real_conn.row_factory = factory

              def __enter__(self):
                  return self

              def __exit__(self, exc_type, exc_val, exc_tb):
                  self.close()


          class SecureCursorProxy:
              """Proxy that wraps sqlite3.Cursor and controls all operations"""

              def __init__(self, real_cursor, guardian: 'SecureDatabaseGuardian',
                           app_id: str, ip_address: str):
                  self._real_cursor = real_cursor
                  self._guardian = guardian
                  self._app_id = app_id
                  self._ip_address = ip_address

              def execute(self, sql: str, parameters: tuple = ()):
                  """Execute SQL through guardian"""
                  if not self._guardian.check_permission(self._app_id, self._ip_address, 'execute', sql):
                      raise sqlite3.Error("Access denied by database guardian")

                  return self._real_cursor.execute(sql, parameters)

              def executemany(self, sql: str, parameters_list):
                  """Execute many SQL statements"""
                  if not self._guardian.check_permission(self._app_id, self._ip_address, 'executemany', sql):
                      raise sqlite3.Error("Access denied by database guardian")

                  return self._real_cursor.executemany(sql, parameters_list)

              def fetchone(self):
                  """Fetch one row"""
                  return self._real_cursor.fetchone()

              def fetchmany(self, size=None):
                  """Fetch many rows"""
                  return self._real_cursor.fetchmany(size)

              def fetchall(self):
                  """Fetch all rows"""
                  return self._real_cursor.fetchall()

              def close(self):
                  """Close cursor"""
                  return self._real_cursor.close()

              @property
              def description(self):
                  """Get column description"""
                  return self._real_cursor.description

              @property
              def rowcount(self):
                  """Get row count"""
                  return self._real_cursor.rowcount


          class SecureDatabaseGuardian:
              """Main guardian class that controls all database access"""

              def __init__(self, security_db_path: str = None):
                  self.security_db_path = security_db_path or "security_guardian.db"
                  self._lock = threading.RLock()
                  self._permissions = {
                      'default': {
                          'read': True,
                          'write': True,
                          'create': False,
                          'drop': False,
                          'alter': False
                      }
                  }
                  self._blocked_patterns = [
                      "DROP TABLE",
                      "DELETE FROM users WHERE",
                      "UPDATE users SET",
                      "ALTER TABLE",
                      "-- INJECTION",
                      "UNION SELECT",
                      "OR '1'='1",
                      "; DROP",
                      "' OR",
                      "\" OR"
                  ]
                  self._init_security_db()

              def _init_security_db(self):
                  """Initialize security database for logging"""
                  try:
                      conn = sqlite3.connect(self.security_db_path)
                      cursor = conn.cursor()
                      cursor.execute('''
                          CREATE TABLE IF NOT EXISTS access_logs (
                              id INTEGER PRIMARY KEY AUTOINCREMENT,
                              timestamp TEXT NOT NULL,
                              app_id TEXT NOT NULL,
                              ip_address TEXT NOT NULL,
                              operation TEXT NOT NULL,
                              sql TEXT,
                              result TEXT NOT NULL,
                              blocked_reason TEXT
                          )
                      ''')
                      conn.commit()
                      conn.close()
                  except Exception as e:
                      print(f"Warning: Could not initialize security database: {e}")

              def connect(self, database_path: str, app_id: str = "unknown", ip_address: str = "127.0.0.1"):
                  """Create a secure connection to the database"""
                  with self._lock:
                      try:
                          # Create the actual SQLite connection
                          real_conn = sqlite3.connect(database_path)

                          # Log the connection attempt
                          self.log_access(app_id, ip_address, 'connect', database_path, 'success')

                          # Return our secure proxy
                          return SecureConnectionProxy(real_conn, self, app_id, ip_address)

                      except Exception as e:
                          self.log_access(app_id, ip_address, 'connect', database_path, 'failed', str(e))
                          raise

              def check_permission(self, app_id: str, ip_address: str, operation: str, sql: str) -> bool:
                  """Check if operation is permitted"""
                  with self._lock:
                      # Check for blocked patterns
                      sql_upper = sql.upper()
                      for pattern in self._blocked_patterns:
                          if pattern in sql_upper:
                              self.log_access(app_id, ip_address, operation, sql, 'blocked', f'Pattern: {pattern}')
                              return False

                      # Check operation type permissions
                      if operation in ['execute', 'executemany']:
                          # Check CREATE permissions
                          if any(keyword in sql_upper for keyword in ['CREATE']):
                              if not self._permissions.get(app_id, self._permissions['default']).get('create', False):
                                  self.log_access(app_id, ip_address, operation, sql, 'blocked', 'No create permission')
                                  return False

                          # Check DROP, DELETE, ALTER permissions
                          if any(keyword in sql_upper for keyword in ['DROP', 'DELETE', 'ALTER']):
                              if not self._permissions.get(app_id, self._permissions['default']).get('write', False):
                                  self.log_access(app_id, ip_address, operation, sql, 'blocked', 'No write permission')
                                  return False

                          # Allow SELECT operations if read permission exists
                          if sql_upper.strip().startswith('SELECT'):
                              if not self._permissions.get(app_id, self._permissions['default']).get('read', True):
                                  self.log_access(app_id, ip_address, operation, sql, 'blocked', 'No read permission')
                                  return False

                      # Log successful permission check
                      self.log_access(app_id, ip_address, operation, sql, 'allowed')
                      return True

              def log_access(self, app_id: str, ip_address: str, operation: str, sql: str,
                            result: str, blocked_reason: str = None):
                  """Log database access attempts"""
                  try:
                      conn = sqlite3.connect(self.security_db_path)
                      cursor = conn.cursor()
                      cursor.execute('''
                          INSERT INTO access_logs
                          (timestamp, app_id, ip_address, operation, sql, result, blocked_reason)
                          VALUES (?, ?, ?, ?, ?, ?, ?)
                      ''', (
                          time.strftime('%Y-%m-%d %H:%M:%S'),
                          app_id,
                          ip_address,
                          operation,
                          sql[:500],  # Truncate long SQL
                          result,
                          blocked_reason
                      ))
                      conn.commit()
                      conn.close()
                  except Exception as e:
                      print(f"Warning: Could not log access: {e}")

              def set_permissions(self, app_id: str, permissions: Dict[str, bool]):
                  """Set permissions for an application"""
                  with self._lock:
                      self._permissions[app_id] = permissions

              def add_blocked_pattern(self, pattern: str):
                  """Add a new blocked SQL pattern"""
                  with self._lock:
                      if pattern not in self._blocked_patterns:
                          self._blocked_patterns.append(pattern)

              def get_access_logs(self, limit: int = 100) -> List[Dict]:
                  """Get recent access logs"""
                  try:
                      conn = sqlite3.connect(self.security_db_path)
                      conn.row_factory = sqlite3.Row
                      cursor = conn.cursor()
                      cursor.execute('''
                          SELECT * FROM access_logs
                          ORDER BY timestamp DESC
                          LIMIT ?
                      ''', (limit,))
                      logs = [dict(row) for row in cursor.fetchall()]
                      conn.close()
                      return logs
                  except Exception as e:
                      print(f"Error getting logs: {e}")
                      return []


          # Global guardian instance
          _guardian_instance = None


          def initialize_secure_database(security_db_path: str = None) -> SecureDatabaseGuardian:
              """Initialize the secure database guardian"""
              global _guardian_instance
              if _guardian_instance is None:
                  _guardian_instance = SecureDatabaseGuardian(security_db_path)
              return _guardian_instance


          def get_guardian() -> SecureDatabaseGuardian:
              """Get the current guardian instance"""
              global _guardian_instance
              if _guardian_instance is None:
                  _guardian_instance = SecureDatabaseGuardian()
              return _guardian_instance
          |--- FILE CONTENT END ---|

        secure_db_wrapper.py
          |--- FILE CONTENT START ---|
          """
          Transparent Database Connection Wrapper
          Intercepts all database operations and applies security checks
          Applications use this exactly like sqlite3.connect() - no knowledge of protection

          Supports: SQLite, PostgreSQL, MySQL
          """
          import sqlite3
          import inspect
          import sys
          import os
          from typing import Any, Optional, Tuple, List, Dict

          # Import firewall from core module
          sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
          from core.firewall import DatabaseFirewall as DatabaseSecurityFirewall

          # Try to import PostgreSQL and MySQL drivers
          try:
              import psycopg2
              from psycopg2.extras import RealDictCursor
              PSYCOPG2_AVAILABLE = True
          except ImportError:
              PSYCOPG2_AVAILABLE = False

          try:
              import mysql.connector
              MYSQL_AVAILABLE = True
          except ImportError:
              MYSQL_AVAILABLE = False


          class SecureCursor:
              """Cursor wrapper that intercepts query execution"""

              def __init__(self, real_cursor, firewall: DatabaseSecurityFirewall, app_id: str, ip_address: str):
                  self._cursor = real_cursor
                  self._firewall = firewall
                  self._app_id = app_id
                  self._ip_address = ip_address
                  self._last_results = None

              def execute(self, query: str, parameters: tuple = ()):
                  """Intercept execute and apply security checks"""
                  # Substitute parameters into query for security analysis
                  full_query = query
                  if parameters:
                      # For security analysis, we need to see the full query
                      full_query = query
                      for param in parameters:
                          if isinstance(param, str):
                              full_query = full_query.replace('?', f"'{param}'", 1)
                          else:
                              full_query = full_query.replace('?', str(param), 1)

                  # Determine operation type
                  operation = query.strip().split()[0].upper()

                  # Apply security check
                  is_authorized, results, reason = self._firewall.execute_query(
                      app_id=self._app_id,
                      ip_address=self._ip_address,
                      operation=operation,
                      query=full_query
                  )

                  if is_authorized:
                      # Execute real query
                      self._cursor.execute(query, parameters)
                      self._last_results = None
                      return self
                  else:
                      # Query blocked - store honeypot results
                      self._last_results = results
                      # Raise exception to mimic blocked query
                      raise sqlite3.OperationalError(f"Security violation: {reason}")

              def executemany(self, query: str, parameters):
                  """Intercept executemany"""
                  # For now, just execute first to check security
                  if parameters:
                      first_params = next(iter(parameters))
                      self.execute(query, first_params)
                      # If authorized, execute the rest
                      return self._cursor.executemany(query, parameters)
                  return self._cursor.executemany(query, parameters)

              def fetchone(self):
                  """Fetch one result"""
                  if self._last_results is not None:
                      return self._last_results[0] if self._last_results else None
                  return self._cursor.fetchone()

              def fetchall(self):
                  """Fetch all results"""
                  if self._last_results is not None:
                      return self._last_results
                  return self._cursor.fetchall()

              def fetchmany(self, size=1):
                  """Fetch many results"""
                  if self._last_results is not None:
                      return self._last_results[:size]
                  return self._cursor.fetchmany(size)

              def __getattr__(self, name):
                  """Proxy all other attributes to real cursor"""
                  return getattr(self._cursor, name)


          class SecureConnection:
              """Connection wrapper that creates secure cursors"""

              def __init__(self, real_connection, firewall: DatabaseSecurityFirewall, app_id: str, ip_address: str):
                  self._connection = real_connection
                  self._firewall = firewall
                  self._app_id = app_id
                  self._ip_address = ip_address

              def cursor(self):
                  """Return a secure cursor"""
                  real_cursor = self._connection.cursor()
                  return SecureCursor(real_cursor, self._firewall, self._app_id, self._ip_address)

              def execute(self, query: str, parameters: tuple = ()):
                  """Direct execute on connection"""
                  cursor = self.cursor()
                  return cursor.execute(query, parameters)

              def commit(self):
                  """Commit transaction"""
                  return self._connection.commit()

              def rollback(self):
                  """Rollback transaction"""
                  return self._connection.rollback()

              def close(self):
                  """Close connection"""
                  return self._connection.close()

              def __enter__(self):
                  """Context manager support"""
                  return self

              def __exit__(self, exc_type, exc_val, exc_tb):
                  """Context manager cleanup"""
                  self.close()

              def __getattr__(self, name):
                  """Proxy all other attributes to real connection"""
                  return getattr(self._connection, name)


          class SecureDatabaseWrapper:
              """
              Transparent database wrapper that intercepts all database operations

              Usage from application (FastAPI, Django, etc.):
                  # SQLite
                  conn = secure_db.connect('db.sqlite3', app_id='my_app')

                  # PostgreSQL
                  conn = secure_db.connect_postgresql(host='localhost', database='mydb',
                                                     user='user', password='pass', app_id='my_app')

                  # MySQL
                  conn = secure_db.connect_mysql(host='localhost', database='mydb',
                                                 user='user', password='pass', app_id='my_app')

              The application doesn't need to know about security - it's transparent!
              """

              def __init__(self, firewall: DatabaseSecurityFirewall):
                  self.firewall = firewall

              def connect(self, database: str, app_id: str, ip_address: str = "127.0.0.1", **kwargs) -> SecureConnection:
                  """
                  Connect to SQLite database with transparent security

                  Args:
                      database: Database path
                      app_id: Application identifier (must be registered in dashboard)
                      ip_address: IP address of the connection
                      **kwargs: Additional sqlite3.connect arguments

                  Returns:
                      SecureConnection that looks and acts like sqlite3.Connection
                  """
                  # Create real connection
                  real_connection = sqlite3.connect(database, **kwargs)

                  # Wrap it with security
                  return SecureConnection(real_connection, self.firewall, app_id, ip_address)

              def connect_postgresql(self, host: str, database: str, user: str, password: str,
                                    app_id: str, ip_address: str = "127.0.0.1",
                                    port: int = 5432, **kwargs) -> SecureConnection:
                  """
                  Connect to PostgreSQL database with transparent security

                  Args:
                      host: Database host
                      database: Database name
                      user: Username
                      password: Password
                      app_id: Application identifier
                      ip_address: IP address of the connection
                      port: Database port (default 5432)
                      **kwargs: Additional psycopg2.connect arguments

                  Returns:
                      SecureConnection that intercepts all queries
                  """
                  if not PSYCOPG2_AVAILABLE:
                      raise ImportError("psycopg2 not available. Install with: pip install psycopg2-binary")

                  real_connection = psycopg2.connect(
                      host=host,
                      port=port,
                      database=database,
                      user=user,
                      password=password,
                      **kwargs
                  )

                  return SecureConnection(real_connection, self.firewall, app_id, ip_address)

              def connect_mysql(self, host: str, database: str, user: str, password: str,
                               app_id: str, ip_address: str = "127.0.0.1",
                               port: int = 3306, **kwargs) -> SecureConnection:
                  """
                  Connect to MySQL database with transparent security

                  Args:
                      host: Database host
                      database: Database name
                      user: Username
                      password: Password
                      app_id: Application identifier
                      ip_address: IP address of the connection
                      port: Database port (default 3306)
                      **kwargs: Additional mysql.connector.connect arguments

                  Returns:
                      SecureConnection that intercepts all queries
                  """
                  if not MYSQL_AVAILABLE:
                      raise ImportError("mysql-connector-python not available. Install with: pip install mysql-connector-python")

                  real_connection = mysql.connector.connect(
                      host=host,
                      port=port,
                      database=database,
                      user=user,
                      password=password,
                      **kwargs
                  )

                  return SecureConnection(real_connection, self.firewall, app_id, ip_address)


          # Global instance for easy import
          _global_firewall = None

          def initialize_secure_database(db_path: str = "security.db"):
              """Initialize the global secure database wrapper"""
              global _global_firewall
              _global_firewall = DatabaseSecurityFirewall()
              return SecureDatabaseWrapper(_global_firewall)

          def get_secure_wrapper() -> SecureDatabaseWrapper:
              """Get the global secure database wrapper"""
              if _global_firewall is None:
                  raise RuntimeError("Secure database not initialized. Call initialize_secure_database() first")
              return SecureDatabaseWrapper(_global_firewall)
          |--- FILE CONTENT END ---|

    [framework_adapters]/
        django_adapter.py
          |--- FILE CONTENT START ---|
          """
          Django adapter for integrating database security system

          Installation:
              Add to settings.py:

              MIDDLEWARE = [
                  ...
                  'framework_adapters.django_adapter.DjangoSecurityMiddleware',
              ]

              DB_SECURITY_CONFIG = {
                  'enabled': True,
                  'app_id': 'django_app',
              }
          """

          import sys
          import os
          from typing import Callable

          sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

          from core.firewall import DatabaseFirewall


          class DjangoSecurityMiddleware:
              """
              Django middleware for database security
              """

              def __init__(self, get_response: Callable):
                  self.get_response = get_response
                  self.firewall = DatabaseFirewall()

              def __call__(self, request):
                  # Add firewall to request
                  request.db_security = self

                  # Store request info for query execution
                  request.security_ip = self.get_client_ip(request)

                  response = self.get_response(request)
                  return response

              def get_client_ip(self, request):
                  """Get client IP address from request"""
                  x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
                  if x_forwarded_for:
                      ip = x_forwarded_for.split(',')[0]
                  else:
                      ip = request.META.get('REMOTE_ADDR')
                  return ip

              def execute_query(self, request, app_id: str, operation: str, query: str):
                  """
                  Execute a query through the security system

                  Usage in views:
                      def my_view(request):
                          is_auth, results, reason = request.db_security.execute_query(
                              request,
                              app_id='my_app',
                              operation='SELECT',
                              query='SELECT * FROM users'
                          )
                  """
                  ip_address = self.get_client_ip(request)

                  return self.firewall.execute_query(
                      app_id=app_id,
                      ip_address=ip_address,
                      operation=operation,
                      query=query
                  )

              def get_logs(self):
                  """Get security logs"""
                  return self.firewall.get_logs()


          # Django view decorators
          def protect_query(app_id: str, operation: str):
              """
              Decorator for Django views to protect database queries

              Usage:
                  from framework_adapters.django_adapter import protect_query

                  @protect_query(app_id='my_app', operation='SELECT')
                  def my_view(request):
                      # Access protected query execution via request
                      pass
              """
              def decorator(view_func: Callable):
                  def wrapper(request, *args, **kwargs):
                      request.security_app_id = app_id
                      request.security_operation = operation
                      return view_func(request, *args, **kwargs)
                  return wrapper
              return decorator


          # Django REST Framework integration
          class DRFSecurityMixin:
              """
              Mixin for Django REST Framework ViewSets

              Usage:
                  from rest_framework import viewsets
                  from framework_adapters.django_adapter import DRFSecurityMixin

                  class UserViewSet(DRFSecurityMixin, viewsets.ModelViewSet):
                      security_app_id = 'api'
                      security_operation = 'SELECT'

                      def list(self, request):
                          is_auth, results, reason = self.execute_secure_query(
                              'SELECT * FROM users'
                          )
                          return Response({'users': results})
              """

              security_app_id = 'unknown'
              security_operation = 'SELECT'

              def __init__(self, *args, **kwargs):
                  super().__init__(*args, **kwargs)
                  self.firewall = DatabaseFirewall()

              def execute_secure_query(self, query: str):
                  """Execute a query through the security system"""
                  request = self.request
                  ip_address = request.META.get('REMOTE_ADDR', '0.0.0.0')

                  return self.firewall.execute_query(
                      app_id=self.security_app_id,
                      ip_address=ip_address,
                      operation=self.security_operation,
                      query=query
                  )


          # Example Django views
          """
          # views.py example

          from django.http import JsonResponse
          from framework_adapters.django_adapter import protect_query

          @protect_query(app_id='webapp_frontend', operation='SELECT')
          def get_users(request):
              is_auth, results, reason = request.db_security.execute_query(
                  request,
                  app_id=request.security_app_id,
                  operation=request.security_operation,
                  query='SELECT * FROM users'
              )

              if is_auth:
                  return JsonResponse({'users': results})
              else:
                  return JsonResponse({'error': reason}, status=403)

          def get_security_logs(request):
              logs = request.db_security.get_logs()
              return JsonResponse({'logs': logs})
          """
          |--- FILE CONTENT END ---|

        fastapi_adapter.py
          |--- FILE CONTENT START ---|
          """
          FastAPI adapter for integrating database security system
          """

          from fastapi import Request, HTTPException, Depends
          from typing import Callable, Optional
          import sys
          import os

          sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

          from core.firewall import DatabaseFirewall


          class FastAPISecurityMiddleware:
              """
              FastAPI middleware for database security

              Usage:
                  from fastapi import FastAPI
                  from framework_adapters import FastAPISecurityMiddleware

                  app = FastAPI()
                  security = FastAPISecurityMiddleware()

                  @app.get("/api/users")
                  async def get_users(
                      auth=Depends(security.protect(app_id="my_app", operation="SELECT"))
                  ):
                      results = await security.execute("SELECT * FROM users")
                      return results
              """

              def __init__(self, firewall: Optional[DatabaseFirewall] = None):
                  self.firewall = firewall or DatabaseFirewall()

              def protect(self, app_id: str, operation: str):
                  """
                  Dependency for protecting routes
                  """
                  def dependency(request: Request):
                      request.state.security_app_id = app_id
                      request.state.security_operation = operation
                      request.state.security_ip = request.client.host
                      return self
                  return dependency

              def execute(self, request: Request, query: str):
                  """Execute a query through the security system"""
                  app_id = getattr(request.state, 'security_app_id', 'unknown')
                  operation = getattr(request.state, 'security_operation', 'SELECT')
                  ip_address = getattr(request.state, 'security_ip', request.client.host)

                  is_auth, results, reason = self.firewall.execute_query(
                      app_id=app_id,
                      ip_address=ip_address,
                      operation=operation,
                      query=query
                  )

                  if not is_auth:
                      raise HTTPException(status_code=403, detail=reason)

                  return results

              def get_logs(self):
                  """Get security logs"""
                  return self.firewall.get_logs()

              def create_routes(self, app):
                  """Create security monitoring routes"""
                  from fastapi.responses import JSONResponse

                  @app.get("/api/security/logs")
                  async def get_security_logs():
                      logs = self.get_logs()
                      return JSONResponse(content={'logs': logs})

                  @app.get("/api/security/stats")
                  async def get_security_stats():
                      logs = self.get_logs()
                      stats = {
                          'total_queries': len(logs),
                          'blocked_queries': sum(1 for log in logs if log['action'] == 'REDIRECTED_TO_HONEYPOT'),
                          'unique_ips': len(set(log['ip_address'] for log in logs))
                      }
                      return JSONResponse(content=stats)

                  @app.post("/api/security/query")
                  async def execute_protected_query(request: Request):
                      data = await request.json()

                      if 'query' not in data:
                          raise HTTPException(status_code=400, detail="Missing query parameter")

                      ip_address = request.client.host
                      is_auth, results, reason = self.firewall.execute_query(
                          app_id=data.get('app_id', 'unknown'),
                          ip_address=ip_address,
                          operation=data.get('operation', 'SELECT'),
                          query=data['query']
                      )

                      return {
                          'authorized': is_auth,
                          'results': results,
                          'reason': reason
                      }


          # Example FastAPI app integration
          def create_protected_app():
              """Example of creating a FastAPI app with security protection"""
              from fastapi import FastAPI, Depends

              app = FastAPI(title="Protected Database API")
              security = FastAPISecurityMiddleware()

              security.create_routes(app)

              @app.get("/api/users")
              async def get_users(
                  request: Request,
                  auth=Depends(security.protect(app_id="webapp_frontend", operation="SELECT"))
              ):
                  results = await security.execute(request, "SELECT * FROM users")
                  return {'users': results}

              return app


          if __name__ == "__main__":
              import uvicorn
              app = create_protected_app()
              uvicorn.run(app, host="0.0.0.0", port=8000)
          |--- FILE CONTENT END ---|

        flask_adapter.py
          |--- FILE CONTENT START ---|
          """
          Flask adapter for integrating database security system
          """

          from flask import request, g, jsonify
          from functools import wraps
          from typing import Callable, Optional
          import sys
          import os

          # Add parent directory to path for imports
          sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

          from core.firewall import DatabaseFirewall


          class FlaskSecurityAdapter:
              """
              Flask adapter for database security system

              Usage:
                  from flask import Flask
                  from framework_adapters import FlaskSecurityAdapter

                  app = Flask(__name__)
                  security = FlaskSecurityAdapter(app)

                  @app.route('/api/users')
                  @security.protect(app_id='my_app', operation='SELECT')
                  def get_users():
                      # Your query here
                      pass
              """

              def __init__(self, app=None, firewall: Optional[DatabaseFirewall] = None):
                  """
                  Initialize Flask security adapter

                  Args:
                      app: Flask application instance (optional)
                      firewall: Custom DatabaseFirewall instance (optional)
                  """
                  self.firewall = firewall or DatabaseFirewall()

                  if app:
                      self.init_app(app)

              def init_app(self, app):
                  """
                  Initialize the adapter with a Flask application

                  Args:
                      app: Flask application instance
                  """
                  self.app = app

                  # Register before_request handler
                  @app.before_request
                  def before_request():
                      g.db_security = self

              def protect(self, app_id: str, operation: str):
                  """
                  Decorator to protect database queries

                  Args:
                      app_id: Application identifier
                      operation: SQL operation (SELECT, INSERT, UPDATE, DELETE)

                  Usage:
                      @security.protect(app_id='my_app', operation='SELECT')
                      def my_route():
                          query = "SELECT * FROM users"
                          return security.execute(query)
                  """
                  def decorator(f: Callable):
                      @wraps(f)
                      def wrapper(*args, **kwargs):
                          # Store context for use in execute method
                          g.security_app_id = app_id
                          g.security_operation = operation
                          g.security_ip = request.remote_addr

                          return f(*args, **kwargs)
                      return wrapper
                  return decorator

              def execute(self, query: str, simulate_time=None):
                  """
                  Execute a query through the security system

                  Args:
                      query: SQL query to execute
                      simulate_time: Optional datetime for testing

                  Returns:
                      Tuple of (is_authorized, results, reason)
                  """
                  app_id = g.get('security_app_id', 'unknown')
                  operation = g.get('security_operation', 'SELECT')
                  ip_address = g.get('security_ip', request.remote_addr)

                  return self.firewall.execute_query(
                      app_id=app_id,
                      ip_address=ip_address,
                      operation=operation,
                      query=query,
                      simulate_time=simulate_time
                  )

              def check_and_execute(self, app_id: str, operation: str, query: str):
                  """
                  Convenience method to check and execute a query in one call

                  Args:
                      app_id: Application identifier
                      operation: SQL operation
                      query: SQL query

                  Returns:
                      Flask Response object
                  """
                  ip_address = request.remote_addr

                  is_auth, results, reason = self.firewall.execute_query(
                      app_id=app_id,
                      ip_address=ip_address,
                      operation=operation,
                      query=query
                  )

                  return jsonify({
                      'authorized': is_auth,
                      'results': results,
                      'reason': reason
                  }), 200 if is_auth else 403

              def get_logs(self, limit: Optional[int] = None):
                  """Get security logs"""
                  return self.firewall.get_logs()

              def create_routes(self, app, prefix='/api/security'):
                  """
                  Create security monitoring routes

                  Args:
                      app: Flask application
                      prefix: URL prefix for routes
                  """
                  @app.route(f'{prefix}/logs', methods=['GET'])
                  def get_security_logs():
                      logs = self.get_logs()
                      return jsonify({'logs': logs}), 200

                  @app.route(f'{prefix}/stats', methods=['GET'])
                  def get_security_stats():
                      logs = self.get_logs()
                      stats = {
                          'total_queries': len(logs),
                          'blocked_queries': sum(1 for log in logs if log['action'] == 'REDIRECTED_TO_HONEYPOT'),
                          'unique_ips': len(set(log['ip_address'] for log in logs))
                      }
                      return jsonify(stats), 200

                  @app.route(f'{prefix}/query', methods=['POST'])
                  def execute_protected_query():
                      data = request.get_json()

                      if not data or 'query' not in data:
                          return jsonify({'error': 'Missing query parameter'}), 400

                      return self.check_and_execute(
                          app_id=data.get('app_id', 'unknown'),
                          operation=data.get('operation', 'SELECT'),
                          query=data['query']
                      )


          # Example Flask app integration
          def create_protected_app():
              """Example of creating a Flask app with security protection"""
              from flask import Flask

              app = Flask(__name__)
              security = FlaskSecurityAdapter(app)

              # Create security routes
              security.create_routes(app)

              @app.route('/api/users', methods=['GET'])
              @security.protect(app_id='webapp_frontend', operation='SELECT')
              def get_users():
                  is_auth, results, reason = security.execute("SELECT * FROM users")

                  if is_auth:
                      return jsonify({'users': results}), 200
                  else:
                      return jsonify({'error': reason, 'fake_data': results}), 403

              return app


          if __name__ == '__main__':
              app = create_protected_app()
              app.run(debug=True, port=5000)
          |--- FILE CONTENT END ---|

        __init__.py
          |--- FILE CONTENT START ---|
          """
          Framework adapters for integrating the security system with various web frameworks
          """

          from .flask_adapter import FlaskSecurityAdapter
          from .django_adapter import DjangoSecurityMiddleware
          from .fastapi_adapter import FastAPISecurityMiddleware

          __all__ = [
              'FlaskSecurityAdapter',
              'DjangoSecurityMiddleware',
              'FastAPISecurityMiddleware',
          ]
          |--- FILE CONTENT END ---|

    [gui]/
        dashboard.py
          |--- FILE CONTENT START ---|
          from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout,
                                       QLabel, QFrame, QGridLayout)
          from PyQt6.QtCore import Qt, QTimer
          from PyQt6.QtGui import QFont


          class Dashboard(QWidget):
              def __init__(self, firewall):
                  super().__init__()
                  self.firewall = firewall
                  self.init_ui()

                  # Setup auto-refresh timer
                  self.timer = QTimer()
                  self.timer.timeout.connect(self.refresh_stats)
                  self.timer.start(2000)  # Refresh every 2 seconds

              def init_ui(self):
                  layout = QVBoxLayout()

                  # Title
                  title = QLabel("Security Dashboard")
                  title_font = QFont()
                  title_font.setPointSize(16)
                  title_font.setBold(True)
                  title.setFont(title_font)
                  layout.addWidget(title)

                  # Statistics Grid
                  stats_layout = QGridLayout()

                  # Stat cards
                  self.total_queries_card = self.create_stat_card("Total Queries", "0")
                  self.blocked_queries_card = self.create_stat_card("Blocked Queries", "0")
                  self.honeypot_hits_card = self.create_stat_card("Honeypot Hits", "0")
                  self.unique_ips_card = self.create_stat_card("Unique IPs", "0")

                  stats_layout.addWidget(self.total_queries_card, 0, 0)
                  stats_layout.addWidget(self.blocked_queries_card, 0, 1)
                  stats_layout.addWidget(self.honeypot_hits_card, 1, 0)
                  stats_layout.addWidget(self.unique_ips_card, 1, 1)

                  layout.addLayout(stats_layout)

                  # Recent Activity Section
                  activity_label = QLabel("Recent Activity")
                  activity_font = QFont()
                  activity_font.setPointSize(12)
                  activity_font.setBold(True)
                  activity_label.setFont(activity_font)
                  layout.addWidget(activity_label)

                  self.activity_list = QLabel("No recent activity")
                  self.activity_list.setWordWrap(True)
                  self.activity_list.setStyleSheet("padding: 10px; background-color: #f5f5f5; border-radius: 5px;")
                  layout.addWidget(self.activity_list)

                  layout.addStretch()
                  self.setLayout(layout)

              def create_stat_card(self, title: str, value: str) -> QFrame:
                  """Create a statistics card widget"""
                  card = QFrame()
                  card.setFrameStyle(QFrame.Shape.Box)
                  card.setStyleSheet("""
                      QFrame {
                          background-color: white;
                          border: 2px solid #e0e0e0;
                          border-radius: 10px;
                          padding: 20px;
                      }
                  """)

                  card_layout = QVBoxLayout()

                  title_label = QLabel(title)
                  title_label.setStyleSheet("color: #666; font-size: 12px;")

                  value_label = QLabel(value)
                  value_label.setStyleSheet("color: #333; font-size: 24px; font-weight: bold;")
                  value_label.setObjectName("value_label")

                  card_layout.addWidget(title_label)
                  card_layout.addWidget(value_label)
                  card.setLayout(card_layout)

                  return card

              def refresh_stats(self):
                  """Refresh dashboard statistics"""
                  logs = self.firewall.get_logs()

                  # Update statistics
                  total_queries = len(logs)
                  blocked_queries = sum(1 for log in logs if log['action'] == 'REDIRECTED_TO_HONEYPOT')

                  # Get unique IPs
                  unique_ips = len(set(log['ip_address'] for log in logs))

                  # Update cards
                  self.update_card_value(self.total_queries_card, str(total_queries))
                  self.update_card_value(self.blocked_queries_card, str(blocked_queries))
                  self.update_card_value(self.honeypot_hits_card, str(blocked_queries))
                  self.update_card_value(self.unique_ips_card, str(unique_ips))

                  # Update recent activity
                  if logs:
                      recent_logs = logs[-5:]  # Last 5 logs
                      activity_text = ""
                      for log in reversed(recent_logs):
                          activity_text += f"‚Ä¢ {log['app_id']} from {log['ip_address']}: {log['reason']}\n"
                      self.activity_list.setText(activity_text)
                  else:
                      self.activity_list.setText("No recent activity")

              def update_card_value(self, card: QFrame, value: str):
                  """Update the value label in a stat card"""
                  value_label = card.findChild(QLabel, "value_label")
                  if value_label:
                      value_label.setText(value)
          |--- FILE CONTENT END ---|

        enhanced_main_window.py
          |--- FILE CONTENT START ---|
          from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                                       QTabWidget, QPushButton, QTextEdit, QLabel,
                                       QTableWidget, QTableWidgetItem, QLineEdit,
                                       QComboBox, QMessageBox, QDialog, QFormLayout,
                                       QDialogButtonBox, QGroupBox)
          from PyQt6.QtCore import Qt, QTimer
          from PyQt6.QtGui import QFont

          # Ensure the project 'src' directory is on sys.path when running this module directly
          import os, sys as _sys
          _CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
          _SRC_DIR = os.path.abspath(os.path.join(_CURRENT_DIR, '..'))
          if _SRC_DIR not in _sys.path:
              _sys.path.insert(0, _SRC_DIR)

          from core.firewall import DatabaseFirewall
          from database.adapters import SQLiteAdapter, PostgreSQLAdapter, MySQLAdapter, MongoDBAdapter
          from gui.dashboard import Dashboard
          from gui.log_viewer import LogViewer


          class DatabaseConfigDialog(QDialog):
              """Dialog for configuring database connections"""

              def __init__(self, parent=None):
                  super().__init__(parent)
                  self.setWindowTitle("Database Configuration")
                  self.setMinimumWidth(500)
                  self.init_ui()

              def init_ui(self):
                  layout = QVBoxLayout()

                  # Database type selection
                  type_layout = QHBoxLayout()
                  type_layout.addWidget(QLabel("Database Type:"))
                  self.db_type_combo = QComboBox()
                  self.db_type_combo.addItems(['SQLite', 'PostgreSQL', 'MySQL', 'MongoDB'])
                  self.db_type_combo.currentTextChanged.connect(self.on_db_type_changed)
                  type_layout.addWidget(self.db_type_combo)
                  layout.addLayout(type_layout)

                  # Connection parameters
                  self.form_layout = QFormLayout()

                  # SQLite fields
                  self.sqlite_group = QGroupBox("SQLite Configuration")
                  sqlite_layout = QFormLayout()
                  self.db_path_input = QLineEdit()
                  self.db_path_input.setPlaceholderText("/path/to/database.db")
                  sqlite_layout.addRow("Database Path:", self.db_path_input)
                  self.sqlite_group.setLayout(sqlite_layout)
                  layout.addWidget(self.sqlite_group)

                  # PostgreSQL/MySQL fields
                  self.sql_group = QGroupBox("SQL Database Configuration")
                  sql_layout = QFormLayout()
                  self.host_input = QLineEdit()
                  self.host_input.setPlaceholderText("localhost")
                  self.port_input = QLineEdit()
                  self.port_input.setPlaceholderText("5432 / 3306")
                  self.database_input = QLineEdit()
                  self.database_input.setPlaceholderText("database_name")
                  self.user_input = QLineEdit()
                  self.user_input.setPlaceholderText("username")
                  self.password_input = QLineEdit()
                  self.password_input.setEchoMode(QLineEdit.EchoMode.Password)
                  sql_layout.addRow("Host:", self.host_input)
                  sql_layout.addRow("Port:", self.port_input)
                  sql_layout.addRow("Database:", self.database_input)
                  sql_layout.addRow("User:", self.user_input)
                  sql_layout.addRow("Password:", self.password_input)
                  self.sql_group.setLayout(sql_layout)
                  self.sql_group.setVisible(False)
                  layout.addWidget(self.sql_group)

                  # Test connection button
                  test_btn = QPushButton("Test Connection")
                  test_btn.clicked.connect(self.test_connection)
                  layout.addWidget(test_btn)

                  # Dialog buttons
                  button_box = QDialogButtonBox(
                      QDialogButtonBox.StandardButton.Ok |
                      QDialogButtonBox.StandardButton.Cancel
                  )
                  button_box.accepted.connect(self.accept)
                  button_box.rejected.connect(self.reject)
                  layout.addWidget(button_box)

                  self.setLayout(layout)
                  self.on_db_type_changed('SQLite')

              def on_db_type_changed(self, db_type):
                  """Handle database type change"""
                  if db_type == 'SQLite':
                      self.sqlite_group.setVisible(True)
                      self.sql_group.setVisible(False)
                  else:
                      self.sqlite_group.setVisible(False)
                      self.sql_group.setVisible(True)

                      # Set default ports
                      if db_type == 'PostgreSQL':
                          self.port_input.setText('5432')
                      elif db_type == 'MySQL':
                          self.port_input.setText('3306')
                      elif db_type == 'MongoDB':
                          self.port_input.setText('27017')

              def test_connection(self):
                  """Test the database connection"""
                  try:
                      adapter = self.create_adapter()
                      success, message = adapter.test_connection()

                      if success:
                          QMessageBox.information(self, "Success", f"Connection successful!\n{message}")
                      else:
                          QMessageBox.warning(self, "Connection Failed", f"Could not connect:\n{message}")
                  except Exception as e:
                      QMessageBox.critical(self, "Error", f"Connection error:\n{str(e)}")

              def create_adapter(self):
                  """Create database adapter from current settings"""
                  db_type = self.db_type_combo.currentText()

                  if db_type == 'SQLite':
                      config = {'database': self.db_path_input.text() or ':memory:'}
                      return SQLiteAdapter(config)

                  elif db_type == 'PostgreSQL':
                      config = {
                          'host': self.host_input.text() or 'localhost',
                          'port': int(self.port_input.text() or 5432),
                          'database': self.database_input.text() or 'postgres',
                          'user': self.user_input.text() or 'postgres',
                          'password': self.password_input.text()
                      }
                      return PostgreSQLAdapter(config)

                  elif db_type == 'MySQL':
                      config = {
                          'host': self.host_input.text() or 'localhost',
                          'port': int(self.port_input.text() or 3306),
                          'database': self.database_input.text() or 'mysql',
                          'user': self.user_input.text() or 'root',
                          'password': self.password_input.text()
                      }
                      return MySQLAdapter(config)

                  elif db_type == 'MongoDB':
                      config = {
                          'host': self.host_input.text() or 'localhost',
                          'port': int(self.port_input.text() or 27017),
                          'database': self.database_input.text() or 'test',
                          'user': self.user_input.text(),
                          'password': self.password_input.text()
                      }
                      return MongoDBAdapter(config)

              def get_config(self):
                  """Get the current configuration"""
                  db_type = self.db_type_combo.currentText()

                  if db_type == 'SQLite':
                      return {
                          'type': 'sqlite',
                          'database': self.db_path_input.text()
                      }
                  else:
                      return {
                          'type': db_type.lower(),
                          'host': self.host_input.text(),
                          'port': self.port_input.text(),
                          'database': self.database_input.text(),
                          'user': self.user_input.text(),
                          'password': self.password_input.text()
                      }


          class EnhancedMainWindow(QMainWindow):
              """Enhanced main window with full database management"""

              def __init__(self):
                  super().__init__()
                  self.firewall = DatabaseFirewall()
                  self.db_adapter = None
                  self.init_ui()

              def init_ui(self):
                  self.setWindowTitle("Database Security System - Enterprise Edition")
                  self.setGeometry(100, 100, 1400, 900)

                  # Main widget and layout
                  central_widget = QWidget()
                  self.setCentralWidget(central_widget)
                  main_layout = QVBoxLayout(central_widget)

                  # Top toolbar
                  toolbar_layout = QHBoxLayout()

                  config_btn = QPushButton("‚öôÔ∏è Database Config")
                  config_btn.clicked.connect(self.show_db_config)
                  toolbar_layout.addWidget(config_btn)

                  connect_btn = QPushButton("üîå Connect")
                  connect_btn.clicked.connect(self.connect_database)
                  toolbar_layout.addWidget(connect_btn)

                  self.connection_status = QLabel("‚óè Disconnected")
                  self.connection_status.setStyleSheet("color: red; font-weight: bold;")
                  toolbar_layout.addWidget(self.connection_status)

                  toolbar_layout.addStretch()

                  export_btn = QPushButton("üìä Export Logs")
                  export_btn.clicked.connect(self.export_logs)
                  toolbar_layout.addWidget(export_btn)

                  main_layout.addLayout(toolbar_layout)

                  # Tab widget
                  self.tabs = QTabWidget()

                  # Dashboard tab
                  self.dashboard = Dashboard(self.firewall)
                  self.tabs.addTab(self.dashboard, "üìà Dashboard")

                  # Query Testing tab
                  query_widget = self.create_query_tab()
                  self.tabs.addTab(query_widget, "üîç Query Testing")

                  # Logs tab
                  self.log_viewer = LogViewer(self.firewall)
                  self.tabs.addTab(self.log_viewer, "üìã Security Logs")

                  # Query History Tab
                  query_history_widget = self.create_query_history_tab()
                  self.tabs.addTab(query_history_widget, "üìä Query Data")

                  # Configuration tab
                  config_widget = self.create_config_tab()
                  self.tabs.addTab(config_widget, "‚öôÔ∏è Configuration")

                  main_layout.addWidget(self.tabs)

                  # Status bar
                  self.statusBar().showMessage("Ready")

                  # Auto-refresh timer for query history
                  self.refresh_timer = QTimer()
                  self.refresh_timer.timeout.connect(self.refresh_query_history)
                  self.refresh_timer.start(2000)  # Refresh every 2 seconds

              def create_query_tab(self):
                  """Create query testing tab"""
                  widget = QWidget()
                  layout = QVBoxLayout(widget)

                  # Query input section
                  query_layout = QHBoxLayout()

                  self.app_input = QLineEdit()
                  self.app_input.setPlaceholderText("App ID")
                  query_layout.addWidget(QLabel("App:"))
                  query_layout.addWidget(self.app_input)

                  self.ip_input = QLineEdit()
                  self.ip_input.setPlaceholderText("IP Address")
                  query_layout.addWidget(QLabel("IP:"))
                  query_layout.addWidget(self.ip_input)

                  self.op_combo = QComboBox()
                  self.op_combo.addItems(['SELECT', 'INSERT', 'UPDATE', 'DELETE'])
                  query_layout.addWidget(QLabel("Op:"))
                  query_layout.addWidget(self.op_combo)

                  layout.addLayout(query_layout)

                  self.query_input = QTextEdit()
                  self.query_input.setPlaceholderText("Enter SQL query here...")
                  self.query_input.setMaximumHeight(100)
                  layout.addWidget(QLabel("Query:"))
                  layout.addWidget(self.query_input)

                  test_btn = QPushButton("üöÄ Execute Query")
                  test_btn.clicked.connect(self.test_query)
                  layout.addWidget(test_btn)

                  self.results_text = QTextEdit()
                  self.results_text.setReadOnly(True)
                  layout.addWidget(QLabel("Results:"))
                  layout.addWidget(self.results_text)

                  return widget

              def create_config_tab(self):
                  """Create configuration management tab"""
                  widget = QWidget()
                  layout = QVBoxLayout(widget)

                  layout.addWidget(QLabel("Security Configuration"))

                  info_text = QTextEdit()
                  info_text.setReadOnly(True)
                  info_text.setHtml("""
                  <h3>Configuration Files</h3>
                  <p><b>config/settings.py</b> - Application settings</p>
                  <p><b>config/database_config.py</b> - Access control rules</p>

                  <h3>Authorized Applications</h3>
                  <p>Configure applications in database_config.py with:</p>
                  <ul>
                      <li>Time windows for access</li>
                      <li>IP whitelists</li>
                      <li>Allowed operations</li>
                  </ul>

                  <h3>Supported Databases</h3>
                  <ul>
                      <li>‚úÖ SQLite</li>
                      <li>‚úÖ PostgreSQL</li>
                      <li>‚úÖ MySQL</li>
                      <li>‚úÖ MongoDB</li>
                  </ul>

                  <h3>Framework Support</h3>
                  <ul>
                      <li>‚úÖ Flask</li>
                      <li>‚úÖ FastAPI</li>
                      <li>‚úÖ Django</li>
                      <li>Coming: Express.js, Laravel adapters</li>
                  </ul>
                  """)
                  layout.addWidget(info_text)

                  return widget

              def show_db_config(self):
                  """Show database configuration dialog"""
                  dialog = DatabaseConfigDialog(self)
                  if dialog.exec():
                      config = dialog.get_config()
                      self.db_config = config
                      QMessageBox.information(self, "Success", "Database configuration saved!")

              def connect_database(self):
                  """Connect to configured database"""
                  if not hasattr(self, 'db_config'):
                      QMessageBox.warning(self, "No Configuration",
                                        "Please configure database connection first.")
                      return

                  try:
                      dialog = DatabaseConfigDialog(self)
                      self.db_adapter = dialog.create_adapter()

                      if self.db_adapter.connect():
                          self.connection_status.setText("‚óè Connected")
                          self.connection_status.setStyleSheet("color: green; font-weight: bold;")
                          self.statusBar().showMessage(f"Connected to {self.db_adapter.get_database_type()}")
                      else:
                          self.connection_status.setText("‚óè Failed")
                          self.connection_status.setStyleSheet("color: orange; font-weight: bold;")
                  except Exception as e:
                      QMessageBox.critical(self, "Connection Error", str(e))

              def test_query(self):
                  """Test a query"""
                  app_id = self.app_input.text() or 'test_app'
                  ip = self.ip_input.text() or '127.0.0.1'
                  query = self.query_input.toPlainText()
                  operation = self.op_combo.currentText()

                  if not query:
                      QMessageBox.warning(self, "No Query", "Please enter a query to test.")
                      return

                  is_auth, results, reason = self.firewall.execute_query(
                      app_id, ip, operation, query
                  )

                  status = "‚úÖ AUTHORIZED" if is_auth else "‚ùå BLOCKED"
                  result_text = f"""
          {status}

          Reason: {reason}
          App ID: {app_id}
          IP Address: {ip}
          Operation: {operation}

          Results ({len(results)} rows):
          {results}
                  """

                  self.results_text.setText(result_text)

                  # Refresh logs and dashboard
                  self.log_viewer.refresh_logs()
                  self.dashboard.refresh_stats()

              def create_query_history_tab(self):
                  """Create query history monitoring tab"""
                  widget = QWidget()
                  layout = QVBoxLayout(widget)

                  # Filter controls
                  filter_layout = QHBoxLayout()

                  filter_layout.addWidget(QLabel("Filter:"))
                  self.query_filter = QComboBox()
                  self.query_filter.addItems(['All Queries', 'Allowed Only', 'Blocked Only'])
                  self.query_filter.currentTextChanged.connect(self.refresh_query_history)
                  filter_layout.addWidget(self.query_filter)

                  filter_layout.addWidget(QLabel("Limit:"))
                  self.query_limit = QComboBox()
                  self.query_limit.addItems(['50', '100', '500', 'All'])
                  self.query_limit.currentTextChanged.connect(self.refresh_query_history)
                  filter_layout.addWidget(self.query_limit)

                  refresh_btn = QPushButton("üîÑ Refresh")
                  refresh_btn.clicked.connect(self.refresh_query_history)
                  filter_layout.addWidget(refresh_btn)

                  clear_btn = QPushButton("üóëÔ∏è Clear History")
                  clear_btn.clicked.connect(self.clear_query_history)
                  filter_layout.addWidget(clear_btn)

                  export_queries_btn = QPushButton("üíæ Export")
                  export_queries_btn.clicked.connect(self.export_query_history)
                  filter_layout.addWidget(export_queries_btn)

                  filter_layout.addStretch()
                  layout.addLayout(filter_layout)

                  # Statistics row
                  stats_layout = QHBoxLayout()
                  self.total_queries_label = QLabel("Total: 0")
                  self.allowed_queries_label = QLabel("Allowed: 0")
                  self.allowed_queries_label.setStyleSheet("color: green; font-weight: bold;")
                  self.blocked_queries_label = QLabel("Blocked: 0")
                  self.blocked_queries_label.setStyleSheet("color: red; font-weight: bold;")
                  self.block_rate_label = QLabel("Block Rate: 0%")

                  stats_layout.addWidget(self.total_queries_label)
                  stats_layout.addWidget(QLabel("|"))
                  stats_layout.addWidget(self.allowed_queries_label)
                  stats_layout.addWidget(QLabel("|"))
                  stats_layout.addWidget(self.blocked_queries_label)
                  stats_layout.addWidget(QLabel("|"))
                  stats_layout.addWidget(self.block_rate_label)
                  stats_layout.addStretch()
                  layout.addLayout(stats_layout)

                  # Query table
                  self.query_table = QTableWidget()
                  self.query_table.setColumnCount(8)
                  self.query_table.setHorizontalHeaderLabels([
                      'Timestamp', 'Status', 'App ID', 'IP Address',
                      'Operation', 'Query', 'Reason', 'Time (ms)'
                  ])
                  self.query_table.horizontalHeader().setStretchLastSection(False)
                  self.query_table.setColumnWidth(0, 150)
                  self.query_table.setColumnWidth(1, 80)
                  self.query_table.setColumnWidth(2, 120)
                  self.query_table.setColumnWidth(3, 120)
                  self.query_table.setColumnWidth(4, 80)
                  self.query_table.setColumnWidth(5, 400)
                  self.query_table.setColumnWidth(6, 200)
                  self.query_table.setColumnWidth(7, 80)
                  layout.addWidget(self.query_table)

                  return widget

              def refresh_query_history(self):
                  """Refresh the query history table"""
                  # Get filter settings
                  filter_text = self.query_filter.currentText()
                  limit_text = self.query_limit.currentText()

                  # Determine filter status
                  filter_status = None
                  if filter_text == 'Allowed Only':
                      filter_status = 'ALLOWED'
                  elif filter_text == 'Blocked Only':
                      filter_status = 'BLOCKED'

                  # Determine limit
                  limit = None if limit_text == 'All' else int(limit_text)

                  # Get query history
                  queries = self.firewall.logger.get_query_history(limit=limit, filter_status=filter_status)

                  # Update statistics
                  stats = self.firewall.logger.get_query_stats()
                  self.total_queries_label.setText(f"Total: {stats['total_queries']}")
                  self.allowed_queries_label.setText(f"Allowed: {stats['allowed']}")
                  self.blocked_queries_label.setText(f"Blocked: {stats['blocked']}")
                  self.block_rate_label.setText(f"Block Rate: {stats['block_rate']:.1f}%")

                  # Update table
                  self.query_table.setRowCount(len(queries))
                  for i, query in enumerate(reversed(queries)):  # Most recent first
                      # Timestamp
                      self.query_table.setItem(i, 0, QTableWidgetItem(query['timestamp']))

                      # Status with color
                      status_item = QTableWidgetItem(query['status'])
                      if query['status'] == 'ALLOWED':
                          status_item.setForeground(Qt.GlobalColor.green)
                      else:
                          status_item.setForeground(Qt.GlobalColor.red)
                      self.query_table.setItem(i, 1, status_item)

                      # Other fields
                      self.query_table.setItem(i, 2, QTableWidgetItem(query['app_id']))
                      self.query_table.setItem(i, 3, QTableWidgetItem(query['ip_address']))
                      self.query_table.setItem(i, 4, QTableWidgetItem(query['operation']))
                      self.query_table.setItem(i, 5, QTableWidgetItem(query['query'][:200]))  # Truncate long queries
                      self.query_table.setItem(i, 6, QTableWidgetItem(query['reason']))
                      self.query_table.setItem(i, 7, QTableWidgetItem(f"{query['execution_time_ms']:.2f}"))

              def clear_query_history(self):
                  """Clear all query history"""
                  reply = QMessageBox.question(self, 'Clear History',
                                               'Are you sure you want to clear all query history?',
                                               QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

                  if reply == QMessageBox.StandardButton.Yes:
                      self.firewall.logger.clear_query_history()
                      self.refresh_query_history()
                      QMessageBox.information(self, "Success", "Query history cleared")

              def export_query_history(self):
                  """Export query history to JSON"""
                  import json
                  from datetime import datetime

                  queries = self.firewall.logger.get_query_history()
                  filename = f"query_history_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

                  try:
                      with open(filename, 'w') as f:
                          json.dump(queries, f, indent=2)

                      QMessageBox.information(self, "Success",
                                            f"Query history exported to {filename}")
                  except Exception as e:
                      QMessageBox.critical(self, "Export Error", str(e))

              def export_logs(self):
                  """Export security logs"""
                  import json
                  from datetime import datetime

                  logs = self.firewall.get_logs()
                  filename = f"security_logs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

                  try:
                      with open(filename, 'w') as f:
                          json.dump(logs, f, indent=2)

                      QMessageBox.information(self, "Success",
                                            f"Logs exported to {filename}")
                  except Exception as e:
                      QMessageBox.critical(self, "Export Error", str(e))


          if __name__ == '__main__':
              import sys
              from PyQt6.QtWidgets import QApplication

              app = QApplication(sys.argv)
              window = EnhancedMainWindow()
              window.show()
              sys.exit(app.exec())
          |--- FILE CONTENT END ---|

        log_viewer.py
          |--- FILE CONTENT START ---|
          from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout,
                                       QTableWidget, QTableWidgetItem, QPushButton,
                                       QLabel, QLineEdit, QComboBox)
          from PyQt6.QtCore import Qt
          from PyQt6.QtGui import QColor


          class LogViewer(QWidget):
              def __init__(self, firewall):
                  super().__init__()
                  self.firewall = firewall
                  self.all_logs = []
                  self.init_ui()

              def init_ui(self):
                  layout = QVBoxLayout()

                  # Title
                  title = QLabel("Security Logs Viewer")
                  title.setStyleSheet("font-size: 16px; font-weight: bold;")
                  layout.addWidget(title)

                  # Filter controls
                  filter_layout = QHBoxLayout()

                  filter_layout.addWidget(QLabel("Filter by:"))

                  self.filter_combo = QComboBox()
                  self.filter_combo.addItems(['All', 'App ID', 'IP Address', 'Reason'])
                  self.filter_combo.currentTextChanged.connect(self.on_filter_changed)
                  filter_layout.addWidget(self.filter_combo)

                  self.filter_input = QLineEdit()
                  self.filter_input.setPlaceholderText("Enter filter value...")
                  self.filter_input.textChanged.connect(self.apply_filter)
                  filter_layout.addWidget(self.filter_input)

                  refresh_btn = QPushButton("Refresh")
                  refresh_btn.clicked.connect(self.refresh_logs)
                  filter_layout.addWidget(refresh_btn)

                  clear_btn = QPushButton("Clear Logs")
                  clear_btn.clicked.connect(self.clear_logs)
                  filter_layout.addWidget(clear_btn)

                  filter_layout.addStretch()
                  layout.addLayout(filter_layout)

                  # Logs table
                  self.logs_table = QTableWidget()
                  self.logs_table.setColumnCount(6)
                  self.logs_table.setHorizontalHeaderLabels([
                      'Timestamp', 'App ID', 'IP Address', 'Operation', 'Reason', 'Query'
                  ])
                  self.logs_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
                  self.logs_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
                  self.logs_table.setAlternatingRowColors(True)

                  # Set column widths
                  self.logs_table.setColumnWidth(0, 150)
                  self.logs_table.setColumnWidth(1, 120)
                  self.logs_table.setColumnWidth(2, 120)
                  self.logs_table.setColumnWidth(3, 80)
                  self.logs_table.setColumnWidth(4, 200)
                  self.logs_table.setColumnWidth(5, 300)

                  layout.addWidget(self.logs_table)

                  # Log count
                  self.log_count_label = QLabel("Total logs: 0")
                  layout.addWidget(self.log_count_label)

                  self.setLayout(layout)
                  self.refresh_logs()

              def refresh_logs(self):
                  """Refresh the logs table from the firewall"""
                  from datetime import datetime

                  self.all_logs = self.firewall.get_logs()
                  self.apply_filter()

              def apply_filter(self):
                  """Apply the current filter to the logs"""
                  filter_type = self.filter_combo.currentText()
                  filter_value = self.filter_input.text().lower()

                  # Filter logs
                  if filter_type == 'All' or not filter_value:
                      filtered_logs = self.all_logs
                  else:
                      filtered_logs = []
                      for log in self.all_logs:
                          if filter_type == 'App ID' and filter_value in log['app_id'].lower():
                              filtered_logs.append(log)
                          elif filter_type == 'IP Address' and filter_value in log['ip_address'].lower():
                              filtered_logs.append(log)
                          elif filter_type == 'Reason' and filter_value in log['reason'].lower():
                              filtered_logs.append(log)

                  # Update table
                  self.populate_table(filtered_logs)
                  self.log_count_label.setText(f"Total logs: {len(filtered_logs)} (Filtered from {len(self.all_logs)})")

              def populate_table(self, logs):
                  """Populate the table with logs"""
                  from datetime import datetime

                  self.logs_table.setRowCount(len(logs))

                  for i, log in enumerate(logs):
                      # Add timestamp (simulated as current time for display)
                      timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                      self.logs_table.setItem(i, 0, QTableWidgetItem(timestamp))

                      # Add log data
                      self.logs_table.setItem(i, 1, QTableWidgetItem(log['app_id']))
                      self.logs_table.setItem(i, 2, QTableWidgetItem(log['ip_address']))
                      self.logs_table.setItem(i, 3, QTableWidgetItem(log['operation']))
                      self.logs_table.setItem(i, 4, QTableWidgetItem(log['reason']))
                      self.logs_table.setItem(i, 5, QTableWidgetItem(log['query'][:100] + '...' if len(log['query']) > 100 else log['query']))

                      # Color code rows based on threat level
                      if 'SQL injection' in log['reason']:
                          color = QColor(255, 200, 200)  # Light red for injection attempts
                      elif 'not whitelisted' in log['reason']:
                          color = QColor(255, 230, 200)  # Light orange for unauthorized IPs
                      else:
                          color = QColor(255, 255, 200)  # Light yellow for other issues

                      for col in range(6):
                          item = self.logs_table.item(i, col)
                          if item:
                              item.setBackground(color)

              def on_filter_changed(self, value):
                  """Handle filter type change"""
                  if value == 'All':
                      self.filter_input.setEnabled(False)
                      self.filter_input.clear()
                  else:
                      self.filter_input.setEnabled(True)
                  self.apply_filter()

              def clear_logs(self):
                  """Clear all logs"""
                  self.firewall.logger.clear_logs()
                  self.refresh_logs()
          |--- FILE CONTENT END ---|

        main_window.py
          |--- FILE CONTENT START ---|
          from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout,
                                       QHBoxLayout, QPushButton, QTextEdit,
                                       QLabel, QTableWidget, QTableWidgetItem,
                                       QLineEdit, QComboBox)
          from PyQt6.QtCore import Qt
          from core.firewall import DatabaseFirewall

          class MainWindow(QMainWindow):
              def __init__(self):
                  super().__init__()
                  self.firewall = DatabaseFirewall()
                  self.init_ui()

              def init_ui(self):
                  self.setWindowTitle("Database Security System")
                  self.setGeometry(100, 100, 1200, 800)

                  central_widget = QWidget()
                  self.setCentralWidget(central_widget)
                  main_layout = QVBoxLayout(central_widget)

                  # Test query section
                  query_layout = QHBoxLayout()
                  self.app_input = QLineEdit()
                  self.app_input.setPlaceholderText("App ID")
                  self.ip_input = QLineEdit()
                  self.ip_input.setPlaceholderText("IP Address")
                  self.query_input = QLineEdit()
                  self.query_input.setPlaceholderText("SQL Query")
                  self.op_combo = QComboBox()
                  self.op_combo.addItems(['SELECT', 'INSERT', 'UPDATE', 'DELETE'])

                  test_btn = QPushButton("Test Query")
                  test_btn.clicked.connect(self.test_query)

                  query_layout.addWidget(QLabel("App:"))
                  query_layout.addWidget(self.app_input)
                  query_layout.addWidget(QLabel("IP:"))
                  query_layout.addWidget(self.ip_input)
                  query_layout.addWidget(QLabel("Op:"))
                  query_layout.addWidget(self.op_combo)
                  query_layout.addWidget(self.query_input)
                  query_layout.addWidget(test_btn)

                  # Results area
                  self.results_text = QTextEdit()
                  self.results_text.setReadOnly(True)

                  # Logs table
                  self.logs_table = QTableWidget()
                  self.logs_table.setColumnCount(5)
                  self.logs_table.setHorizontalHeaderLabels(
                      ['App ID', 'IP', 'Operation', 'Reason', 'Query']
                  )

                  refresh_btn = QPushButton("Refresh Logs")
                  refresh_btn.clicked.connect(self.refresh_logs)

                  main_layout.addLayout(query_layout)
                  main_layout.addWidget(QLabel("Results:"))
                  main_layout.addWidget(self.results_text)
                  main_layout.addWidget(refresh_btn)
                  main_layout.addWidget(self.logs_table)

              def test_query(self):
                  app_id = self.app_input.text()
                  ip = self.ip_input.text()
                  query = self.query_input.text()
                  operation = self.op_combo.currentText()

                  is_auth, results, reason = self.firewall.execute_query(
                      app_id, ip, operation, query
                  )

                  status = "‚úÖ AUTHORIZED" if is_auth else "‚ùå BLOCKED"
                  self.results_text.setText(
                      f"{status}\nReason: {reason}\nResults: {results}"
                  )
                  self.refresh_logs()

              def refresh_logs(self):
                  logs = self.firewall.get_logs()
                  self.logs_table.setRowCount(len(logs))

                  for i, log in enumerate(logs):
                      self.logs_table.setItem(i, 0, QTableWidgetItem(log['app_id']))
                      self.logs_table.setItem(i, 1, QTableWidgetItem(log['ip_address']))
                      self.logs_table.setItem(i, 2, QTableWidgetItem(log['operation']))
                      self.logs_table.setItem(i, 3, QTableWidgetItem(log['reason']))
                      self.logs_table.setItem(i, 4, QTableWidgetItem(log['query'][:50]))
          |--- FILE CONTENT END ---|

        __init__.py
          |--- FILE CONTENT START ---|

          |--- FILE CONTENT END ---|

    [security]/
        db_proxy.py
          |--- FILE CONTENT START ---|
          """
          src/security/db_proxy.py

          Transparent sqlite3 wrapper.

          Drop this import very early in startup (before any sqlite3.connect calls).
          It monkeypatches sqlite3.connect so returned connection objects provide wrapped
          cursors whose execute / executemany calls are scanned by injection_detector.score_sql_risk.

          Behavior:
          - If score >= BLOCK_ON_SCORE -> raises SecurityError (blocks query)
          - If LOG_ON_SCORE <= score < BLOCK_ON_SCORE -> logs warning and allows
          - Calls honeypot.alert_on_suspicious when suspicious blocking/logging occurs
          - Preserves original sqlite3 connection/cursor API via __getattr__
          """

          import sqlite3
          import functools
          import logging
          import threading
          import time
          from typing import Any, Iterable

          # Local imports (assumes these modules exist in your project)
          from database.injection_detector import score_sql_risk, detect_sql_injection
          from security.honeypot import alert_on_suspicious

          logger = logging.getLogger("db_proxy")
          logger.setLevel(logging.DEBUG)
          if not logger.handlers:
              ch = logging.StreamHandler()
              ch.setFormatter(logging.Formatter("%(asctime)s %(levelname)s db_proxy: %(message)s"))
              logger.addHandler(ch)

          # --- Configuration (tune these) ---
          BLOCK_ON_SCORE = 0.75   # block if >= this
          LOG_ON_SCORE = 0.35     # log warning if >= this
          CACHE_TTL_SECONDS = 30  # cache score decisions for identical query text
          CACHE_MAX = 2000
          # --- end config ---


          class SecurityError(RuntimeError):
              pass


          # Simple in-memory cache for query text -> (score, ts)
          _score_cache = {}
          _cache_lock = threading.Lock()


          def _cache_get(key: str):
              with _cache_lock:
                  entry = _score_cache.get(key)
                  if not entry:
                      return None
                  score, ts = entry
                  if time.time() - ts > CACHE_TTL_SECONDS:
                      del _score_cache[key]
                      return None
                  return score


          def _cache_set(key: str, score: float):
              with _cache_lock:
                  if len(_score_cache) > CACHE_MAX:
                      # simple eviction: pop a random key
                      _score_cache.pop(next(iter(_score_cache.keys())))
                  _score_cache[key] = (score, time.time())


          def install_sqlite_wrapper():
              """
              Monkeypatch sqlite3.connect to return WrappedConnection objects.
              Call before any sqlite3.connect is used by the app.
              """
              real_connect = sqlite3.connect

              @functools.wraps(real_connect)
              def wrapped_connect(*args, **kwargs):
                  conn = real_connect(*args, **kwargs)
                  return WrappedConnection(conn)

              sqlite3.connect = wrapped_connect
              logger.info("Installed sqlite3.connect wrapper.")


          class WrappedConnection:
              def __init__(self, real_conn):
                  self._conn = real_conn

              def cursor(self, *args, **kwargs):
                  real_cur = self._conn.cursor(*args, **kwargs)
                  return WrappedCursor(real_cur, self)

              def __getattr__(self, name):
                  # Delegate other attributes to the real connection
                  return getattr(self._conn, name)


          class WrappedCursor:
              def __init__(self, real_cursor, conn_wrapper: WrappedConnection):
                  self._cur = real_cursor
                  self._conn_wrapper = conn_wrapper

              # core interception point
              def execute(self, query: str, params: Any = None):
                  qtext = _normalize_query_text(query, params)
                  score = _evaluate_query(qtext, query, params)

                  if score >= BLOCK_ON_SCORE:
                      # Alert and block
                      try:
                          alert_on_suspicious(query=query, params=params, score=score)
                      except Exception:
                          logger.exception("honeypot alert failed")
                      logger.warning("Blocked SQL (score=%.3f): %s", score, _short(query))
                      raise SecurityError(f"Blocked suspicious SQL (score={score:.3f})")

                  if score >= LOG_ON_SCORE:
                      logger.warning("Suspicious SQL (score=%.3f): %s", score, _short(query))
                      try:
                          alert_on_suspicious(query=query, params=params, score=score, warn_only=True)
                      except Exception:
                          logger.exception("honeypot warn failed")

                  # Allow: delegate to real cursor
                  return self._cur.execute(query, params or ())

              def executemany(self, query: str, seq_of_params: Iterable):
                  qtext = _normalize_query_text(query, None)
                  # cheap check using the first param set (if any)
                  sample_params = None
                  try:
                      sample_params = (next(iter(seq_of_params)) if seq_of_params else None)
                  except Exception:
                      sample_params = None
                  score = _evaluate_query(qtext, query, sample_params)

                  if score >= BLOCK_ON_SCORE:
                      try:
                          alert_on_suspicious(query=query, params=sample_params, score=score)
                      except Exception:
                          logger.exception("honeypot alert failed")
                      logger.warning("Blocked executemany SQL (score=%.3f): %s", score, _short(query))
                      raise SecurityError(f"Blocked suspicious executemany SQL (score={score:.3f})")

                  if score >= LOG_ON_SCORE:
                      logger.warning("Suspicious executemany SQL (score=%.3f): %s", score, _short(query))
                      try:
                          alert_on_suspicious(query=query, params=sample_params, score=score, warn_only=True)
                      except Exception:
                          logger.exception("honeypot warn failed")

                  return self._cur.executemany(query, seq_of_params)

              def __getattr__(self, name):
                  return getattr(self._cur, name)


          # ---- helpers ----
          def _normalize_query_text(query: str, params: Any) -> str:
              # Return a canonical string for caching. Use query + param types/lengths.
              try:
                  q = str(query).strip()
                  if not q:
                      return ""
                  pinfo = ""
                  if params is None:
                      pinfo = "NOPARAMS"
                  else:
                      try:
                          # summarize params by type and length to avoid storing secrets
                          if isinstance(params, (list, tuple)):
                              pinfo = ",".join(f"{type(x).__name__}:{(len(str(x)) if x is not None else 0)}" for x in params)
                          else:
                              pinfo = f"{type(params).__name__}:{len(str(params))}"
                      except Exception:
                          pinfo = "PARAMS_UNKNOWN"
                  return q + "||" + pinfo
              except Exception:
                  return str(query)


          def _evaluate_query(cache_key: str, query: str, params: Any) -> float:
              # Try cache
              cached = _cache_get(cache_key)
              if cached is not None:
                  return cached

              # Compute score using injection_detector
              try:
                  score = score_sql_risk(query, params)
              except Exception:
                  # Fallback to binary detection
                  try:
                      score = 1.0 if detect_sql_injection(query, params) else 0.0
                  except Exception:
                      score = 1.0  # safest default: block if detector fails

              _cache_set(cache_key, score)
              return score


          def _short(x, n=200):
              try:
                  s = str(x)
                  return (s[:n] + "...") if len(s) > n else s
              except Exception:
                  return "<non-string>"
          |--- FILE CONTENT END ---|

        honeypot.py
          |--- FILE CONTENT START ---|
          """
          src/security/honeypot.py

          Lightweight honeypot / alerting module.

          Functions:
          - alert_on_suspicious(query, params, score, warn_only=False)

          This module intentionally keeps alerts simple (write to a log file and optionally
          simulate honeypot DB population). In a production system you'd wire this to:
          - persistent audit log, ELK/Graylog, Splunk, or alerting (PagerDuty/email/webhook)
          - a real honeypot DB instance with controlled fake data
          """

          import logging
          import os
          import json
          import datetime

          logger = logging.getLogger("honeypot")
          logger.setLevel(logging.DEBUG)
          if not logger.handlers:
              ch = logging.StreamHandler()
              ch.setFormatter(logging.Formatter("%(asctime)s %(levelname)s honeypot: %(message)s"))
              logger.addHandler(ch)

          # file to append alerts to (relative to project)
          _ALERT_FILE = os.environ.get("HONEYPOT_ALERT_FILE", "honeypot_alerts.log")


          def _append_alert(record: dict):
              try:
                  with open(_ALERT_FILE, "a", encoding="utf-8") as fh:
                      fh.write(json.dumps(record, default=str) + "\n")
              except Exception:
                  logger.exception("Failed to write honeypot alert file")


          def alert_on_suspicious(query: str, params: object = None, score: float = 1.0, warn_only: bool = False):
              """
              Called when db_proxy detects suspicious activity.
              - query: raw SQL text
              - params: parameters (may be None)
              - score: risk score 0..1
              - warn_only: if True, do not escalate beyond logging
              """
              rec = {
                  "timestamp": datetime.datetime.utcnow().isoformat() + "Z",
                  "score": float(score),
                  "query": str(query)[:2000],
                  "params_summary": _summarize_params(params),
                  "warn_only": bool(warn_only),
              }
              # write to file
              _append_alert(rec)
              # also log
              if warn_only:
                  logger.warning("Suspicious query logged (warn_only): score=%.3f query=%s", score, _short(query))
              else:
                  logger.error("Suspicious query ALERT: score=%.3f query=%s", score, _short(query))

              # TODO: trigger external alert (webhook/pagerduty) for high scores if desired


          def _short(x, n=160):
              try:
                  s = str(x)
                  return (s[:n] + "...") if len(s) > n else s
              except Exception:
                  return "<non-string>"


          def _summarize_params(params):
              try:
                  if params is None:
                      return None
                  if isinstance(params, (list, tuple)):
                      return [type(x).__name__ for x in params][:10]
                  return type(params).__name__
              except Exception:
                  return "params_unknown"
          |--- FILE CONTENT END ---|

        injection_detector.py
          |--- FILE CONTENT START ---|
          """
          src/database/injection_detector.py

          Simple, extensible SQL risk scoring and detection.

          Exports:
          - detect_sql_injection(query, params) -> bool
          - score_sql_risk(query, params) -> float  (0.0 .. 1.0)

          This is intentionally conservative and readable. Replace/extend the heuristics
          with an AST parser, ML model, or more advanced detection as needed.
          """

          import re
          import math
          from typing import Any

          # Heuristic regex patterns that indicate risky SQL (common injection tokens)
          _SUSPICIOUS_PATTERNS = [
              r"(--|\#)",                # SQL comment injection
              r";\s*",                   # query chaining
              r"(/\*|\*/)",              # block comments
              r"\bor\b\s+1\s*=\s*1",     # classic tautology
              r"\bunion\b\s+\bselect\b", # UNION-based injection
              r"\binformation_schema\b", # schema enumeration
              r"\bselect\b.+\bfrom\b.+\bwhere\b.+=[^=]", # suspicious equality in where
              r"\bdrop\b\s+\btable\b",
              r"\bdelete\b\s+\bfrom\b",
              r"\bupdate\b.+\bset\b.+\bwhere\b",  # updates with where can be dangerous without params
              r"\bexec\b\s+\bxp_",        # mssql exec xp_
          ]

          _COMPILED_PATTERNS = [re.compile(pat, re.IGNORECASE | re.DOTALL) for pat in _SUSPICIOUS_PATTERNS]

          # Weighting factors for scoring (tune as required)
          WEIGHTS = {
              "pattern_hit": 0.6,
              "unparameterized": 0.25,
              "length_anomaly": 0.1,
              "suspicious_tokens": 0.2,
          }

          # Suspicious tokens that increase score
          _SUSPICIOUS_TOKENS = [
              " or ",
              " and ",
              " union ",
              " information_schema",
              " load_file",
              " hex(",
              "0x",  # hex literals often used in payloads
          ]


          def detect_sql_injection(query: str, params: Any = None) -> bool:
              """
              Fast boolean detection: returns True if query looks like an injection payload.
              """
              if not query:
                  return False
              q = str(query).lower()
              # quick pattern tests
              for pat in _COMPILED_PATTERNS:
                  if pat.search(q):
                      return True
              # token checks
              for t in _SUSPICIOUS_TOKENS:
                  if t in q:
                      return True
              # if there are bare quotes concatenations with OR/AND patterns
              if ("'" in q and (" or " in q or " and " in q)) or ('"' in q and (" or " in q or " and " in q)):
                  return True

              # if params are None and query contains quotes or formatting markers -> suspicious
              if params is None and ("%" in q or ("'" in q and "=" in q)):
                  return True

              return False


          def _looks_unparameterized(query: str, params: Any = None) -> bool:
              """
              Heuristic: returns True when query looks like it contains inlined user data (not placeholders).
              Works for sqlite3-style queries where params are provided as tuple/list.
              """
              if not query:
                  return False
              q = str(query).lower()
              # placeholders: ? or :name or $1 or %s
              if "?" in q or ":" in q or "$" in q or "%s" in q:
                  # looks parameterized
                  return False
              # if query has single quotes and params is None -> likely inlined values
              if "'" in q or '"' in q:
                  return True
              return False


          def _length_anomaly_score(query: str) -> float:
              """
              Rudimentary length-based anomaly: if query text is unusually long compared to typical queries,
              increase score slightly.
              """
              if not query:
                  return 0.0
              L = len(query)
              if L < 200:
                  return 0.0
              # scale smoothly between 200..2000
              x = min(max((L - 200) / 1800.0, 0.0), 1.0)
              return x * 1.0 * WEIGHTS["length_anomaly"]


          def score_sql_risk(query: str, params: Any = None) -> float:
              """
              Return risk score in [0.0, 1.0].
              Combine pattern hits, parameterization heuristics, token checks, and length anomaly.
              """
              if not query:
                  return 0.0
              q = str(query).lower()

              score = 0.0
              # pattern hits
              for pat in _COMPILED_PATTERNS:
                  if pat.search(q):
                      score += WEIGHTS["pattern_hit"]
                      break

              # suspicious tokens
              token_hits = 0
              for t in _SUSPICIOUS_TOKENS:
                  if t in q:
                      token_hits += 1
              if token_hits:
                  # increase proportional to number of distinct suspicious tokens found
                  score += WEIGHTS["suspicious_tokens"] * min(token_hits, 3)

              # unparameterized queries
              if _looks_unparameterized(query, params):
                  score += WEIGHTS["unparameterized"]

              # length anomaly
              score += _length_anomaly_score(query)

              # clamp to [0,1]
              score = max(0.0, min(1.0, score))

              # small normalization: if score very low but contains 'drop' or 'delete' keyword, bump up
              if score < 0.25 and (" drop " in q or " delete " in q):
                  score = max(score, 0.5)

              return score
          |--- FILE CONTENT END ---|

        ip_tracker.py
          |--- FILE CONTENT START ---|
          from typing import Dict, List
          from datetime import datetime
          import ipaddress


          class IPTracker:
              def __init__(self):
                  self.tracked_ips = {}
                  self.blocked_ips = set()

              def track_ip(self, ip_address: str, app_id: str, operation: str):
                  """Track an IP address activity"""
                  if ip_address not in self.tracked_ips:
                      self.tracked_ips[ip_address] = {
                          'first_seen': datetime.now(),
                          'last_seen': datetime.now(),
                          'attempts': 0,
                          'operations': [],
                          'apps': set()
                      }

                  self.tracked_ips[ip_address]['last_seen'] = datetime.now()
                  self.tracked_ips[ip_address]['attempts'] += 1
                  self.tracked_ips[ip_address]['operations'].append({
                      'operation': operation,
                      'timestamp': datetime.now()
                  })
                  self.tracked_ips[ip_address]['apps'].add(app_id)

              def block_ip(self, ip_address: str):
                  """Add an IP address to the block list"""
                  self.blocked_ips.add(ip_address)

              def unblock_ip(self, ip_address: str):
                  """Remove an IP address from the block list"""
                  if ip_address in self.blocked_ips:
                      self.blocked_ips.remove(ip_address)

              def is_blocked(self, ip_address: str) -> bool:
                  """Check if an IP address is blocked"""
                  return ip_address in self.blocked_ips

              def get_ip_info(self, ip_address: str) -> Dict:
                  """Get information about a specific IP address"""
                  if ip_address not in self.tracked_ips:
                      return None

                  info = self.tracked_ips[ip_address].copy()
                  info['apps'] = list(info['apps'])
                  info['is_blocked'] = self.is_blocked(ip_address)
                  return info

              def get_all_tracked_ips(self) -> List[Dict]:
                  """Get information about all tracked IPs"""
                  result = []
                  for ip, info in self.tracked_ips.items():
                      ip_data = {
                          'ip_address': ip,
                          'first_seen': info['first_seen'],
                          'last_seen': info['last_seen'],
                          'attempts': info['attempts'],
                          'apps': list(info['apps']),
                          'is_blocked': self.is_blocked(ip)
                      }
                      result.append(ip_data)
                  return result

              def get_suspicious_ips(self, threshold: int = 5) -> List[str]:
                  """Get IPs with attempts exceeding threshold"""
                  suspicious = []
                  for ip, info in self.tracked_ips.items():
                      if info['attempts'] >= threshold:
                          suspicious.append(ip)
                  return suspicious

              def is_private_ip(self, ip_address: str) -> bool:
                  """Check if an IP address is private"""
                  try:
                      ip_obj = ipaddress.ip_address(ip_address)
                      return ip_obj.is_private
                  except:
                      return False

              def clear_tracking(self):
                  """Clear all tracking data"""
                  self.tracked_ips = {}
                  self.blocked_ips = set()
          |--- FILE CONTENT END ---|

        threat_analyzer.py
          |--- FILE CONTENT START ---|
          from typing import Dict, List
          from datetime import datetime, timedelta


          class ThreatAnalyzer:
              def __init__(self):
                  self.threat_history = []
                  self.ip_attempts = {}

              def analyze_threat_level(self, ip_address: str, reason: str) -> str:
                  """
                  Analyze threat level based on attack patterns and frequency
                  Returns: 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'
                  """
                  # Record the attempt
                  current_time = datetime.now()
                  if ip_address not in self.ip_attempts:
                      self.ip_attempts[ip_address] = []

                  self.ip_attempts[ip_address].append({
                      'timestamp': current_time,
                      'reason': reason
                  })

                  # Clean old attempts (older than 1 hour)
                  self._clean_old_attempts(ip_address)

                  # Calculate threat level
                  recent_attempts = len(self.ip_attempts[ip_address])

                  if recent_attempts >= 10:
                      return 'CRITICAL'
                  elif recent_attempts >= 5:
                      return 'HIGH'
                  elif recent_attempts >= 3:
                      return 'MEDIUM'
                  else:
                      return 'LOW'

              def _clean_old_attempts(self, ip_address: str):
                  """Remove attempts older than 1 hour"""
                  one_hour_ago = datetime.now() - timedelta(hours=1)
                  if ip_address in self.ip_attempts:
                      self.ip_attempts[ip_address] = [
                          attempt for attempt in self.ip_attempts[ip_address]
                          if attempt['timestamp'] > one_hour_ago
                      ]

              def get_threat_statistics(self) -> Dict:
                  """Get statistics about current threats"""
                  stats = {
                      'total_ips_tracked': len(self.ip_attempts),
                      'high_risk_ips': [],
                      'total_attempts': 0
                  }

                  for ip, attempts in self.ip_attempts.items():
                      attempt_count = len(attempts)
                      stats['total_attempts'] += attempt_count
                      if attempt_count >= 5:
                          stats['high_risk_ips'].append({
                              'ip': ip,
                              'attempts': attempt_count
                          })

                  return stats

              def is_blocked_ip(self, ip_address: str, threshold: int = 10) -> bool:
                  """Check if an IP should be blocked based on attempt threshold"""
                  if ip_address not in self.ip_attempts:
                      return False
                  return len(self.ip_attempts[ip_address]) >= threshold
          |--- FILE CONTENT END ---|

        __init__.py
          |--- FILE CONTENT START ---|

          |--- FILE CONTENT END --- are all thie files please fix it