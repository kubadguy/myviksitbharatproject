--- Scanning Project Root: src ---    [92mhelper.txt[0m      [93m|--- FILE CONTENT START ---|[0m      [91m[CONTENT SKIPPED: Error reading file: 'charmap' codec can't encode characters in position 93-95: character maps to <undefined>][0m
    [92mmain.py[0m      [93m|--- FILE CONTENT START ---|[0m      #!/usr/bin/env python
      """
      Database Security System - Main Entry Point
      """
      import sys
      import os
      
      # Add src to path for imports
      sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
      
      def run_gui(firewall=None):
          """Run the GUI application"""
          try:
              from PyQt6.QtWidgets import QApplication
              from gui.enhanced_main_window import EnhancedMainWindow
              
              app = QApplication(sys.argv)
              
              # Create firewall instance if not provided
              if firewall is None:
                  from core.firewall import DatabaseFirewall
                  firewall = DatabaseFirewall()
              
              # Create and show main window
              main_win = EnhancedMainWindow()
              main_win.firewall = firewall  # Set firewall as attribute
              main_win.show()
              
              sys.exit(app.exec())
          except ImportError as e:
              print(f"Error: {e}")
              print("PyQt6 is required for GUI mode.")
              print("Install it with: pip install PyQt6")
              sys.exit(1)
      
      def run_api():
          """Run the REST API server"""
          from api.rest_api import app
          print("Starting API server on http://0.0.0.0:5000")
          app.run(host='0.0.0.0', port=5000, debug=True)
      
      def run_demo():
          """Run demonstration scenarios"""
          from core.firewall import DatabaseFirewall
          from datetime import datetime, time
          
          print("=== Database Security System Demo ===\n")
          
          # Initialize firewall
          firewall = DatabaseFirewall()
          
          # Test 1: Authorized access
          print("Test 1: Authorized SELECT query")
          is_auth, results, reason = firewall.execute_query(
              app_id='demo_app',
              ip_address='127.0.0.1',
              operation='SELECT',
              query='SELECT * FROM users'
          )
          print(f"Authorized: {is_auth}")
          print(f"Reason: {reason}")
          print(f"Results: {results}\n")
          
          # Test 2: SQL Injection attempt
          print("Test 2: SQL Injection attempt")
          is_auth, results, reason = firewall.execute_query(
              app_id='demo_app',
              ip_address='192.168.1.50',
              operation='SELECT',
              query="SELECT * FROM users WHERE username='admin' OR '1'='1'"
          )
          print(f"Authorized: {is_auth}")
          print(f"Reason: {reason}")
          print(f"Results (honeypot): {results}\n")
          
          # Test 3: Unauthorized IP
          print("Test 3: Unauthorized IP address")
          is_auth, results, reason = firewall.execute_query(
              app_id='webapp_frontend',
              ip_address='10.0.0.100',
              operation='SELECT',
              query='SELECT * FROM users'
          )
          print(f"Authorized: {is_auth}")
          print(f"Reason: {reason}")
          print(f"Results (honeypot): {results}\n")
          
          # Test 4: View security logs
          print("Security Logs:")
          logs = firewall.get_logs()
          for log in logs:
              print(f"  - {log['timestamp']}: {log['app_id']} from {log['ip_address']}")
              print(f"    Reason: {log['reason']}\n")
      
      def main():
          """Main entry point"""
          if len(sys.argv) < 2:
              print("Usage: python main.py [gui|api|demo]")
              print("  gui  - Launch GUI application")
              print("  api  - Start REST API server")
              print("  demo - Run demonstration")
              sys.exit(1)
          
          mode = sys.argv[1].lower()
          
          if mode == 'gui':
              from core.firewall import DatabaseFirewall
              firewall_instance = DatabaseFirewall()
              run_gui(firewall_instance)
          elif mode == 'api':
              run_api()
          elif mode == 'demo':
              run_demo()
          else:
              print(f"Unknown mode: {mode}")
              print("Use: gui, api, or demo")
              sys.exit(1)
      
      if __name__ == '__main__':
          main()      [93m|--- FILE CONTENT END ---|[0m
    [92m__init__.py[0m      [93m|--- FILE CONTENT START ---|[0m      [93m|--- FILE CONTENT END ---|[0m
    [92m__main__.py[0m      [93m|--- FILE CONTENT START ---|[0m      from main import main
      
      if __name__ == '__main__':
          main()      [93m|--- FILE CONTENT END ---|[0m
    [94m[alerts]/[0m        [92malert_manager.py[0m          [93m|--- FILE CONTENT START ---|[0m          [91m[CONTENT SKIPPED: Error reading file: 'charmap' codec can't encode character '\U0001f6a8' in position 413: character maps to <undefined>][0m
        [92memail_notifier.py[0m          [93m|--- FILE CONTENT START ---|[0m          [91m[CONTENT SKIPPED: Error reading file: 'charmap' codec can't encode character '\U0001f6a8' in position 1366: character maps to <undefined>][0m
        [92msms_notifier.py[0m          [93m|--- FILE CONTENT START ---|[0m          [91m[CONTENT SKIPPED: Error reading file: 'charmap' codec can't encode character '\U0001f6a8' in position 1038: character maps to <undefined>][0m
        [92m__init__.py[0m          [93m|--- FILE CONTENT START ---|[0m          [93m|--- FILE CONTENT END ---|[0m
    [94m[api]/[0m        [92mmiddleware.py[0m          [93m|--- FILE CONTENT START ---|[0m          from flask import request, jsonify
          from functools import wraps
          import time
          from typing import Callable
          
          
          class SecurityMiddleware:
              def __init__(self):
                  self.rate_limits = {}
                  self.blocked_ips = set()
          
              def rate_limit(self, max_requests: int = 100, window_seconds: int = 60):
                  """
                  Rate limiting decorator
                  """
                  def decorator(f: Callable):
                      @wraps(f)
                      def wrapper(*args, **kwargs):
                          ip = request.remote_addr
                          current_time = time.time()
          
                          # Initialize tracking for this IP
                          if ip not in self.rate_limits:
                              self.rate_limits[ip] = []
          
                          # Clean old requests outside the window
                          self.rate_limits[ip] = [
                              req_time for req_time in self.rate_limits[ip]
                              if current_time - req_time < window_seconds
                          ]
          
                          # Check rate limit
                          if len(self.rate_limits[ip]) >= max_requests:
                              return jsonify({
                                  'error': 'Rate limit exceeded',
                                  'message': f'Maximum {max_requests} requests per {window_seconds} seconds'
                              }), 429
          
                          # Record this request
                          self.rate_limits[ip].append(current_time)
          
                          return f(*args, **kwargs)
                      return wrapper
                  return decorator
          
              def require_api_key(self, f: Callable):
                  """
                  API key authentication decorator
                  """
                  @wraps(f)
                  def wrapper(*args, **kwargs):
                      api_key = request.headers.get('X-API-Key')
                      
                      if not api_key:
                          return jsonify({
                              'error': 'Authentication required',
                              'message': 'API key is missing'
                          }), 401
          
                      # In production, validate against a database or configuration
                      # For now, we'll accept any non-empty key
                      if not self._validate_api_key(api_key):
                          return jsonify({
                              'error': 'Authentication failed',
                              'message': 'Invalid API key'
                          }), 403
          
                      return f(*args, **kwargs)
                  return wrapper
          
              def _validate_api_key(self, api_key: str) -> bool:
                  """
                  Validate API key (placeholder implementation)
                  In production, check against database or configuration
                  """
                  # Placeholder: accept any non-empty key for demo
                  return len(api_key) > 0
          
              def ip_whitelist(self, allowed_ips: list):
                  """
                  IP whitelist decorator
                  """
                  def decorator(f: Callable):
                      @wraps(f)
                      def wrapper(*args, **kwargs):
                          ip = request.remote_addr
                          
                          if ip not in allowed_ips:
                              return jsonify({
                                  'error': 'Access denied',
                                  'message': 'Your IP is not whitelisted'
                              }), 403
          
                          return f(*args, **kwargs)
                      return wrapper
                  return decorator
          
              def block_ip(self, ip: str):
                  """Add an IP to the blocked list"""
                  self.blocked_ips.add(ip)
          
              def unblock_ip(self, ip: str):
                  """Remove an IP from the blocked list"""
                  if ip in self.blocked_ips:
                      self.blocked_ips.remove(ip)
          
              def check_blocked_ip(self, f: Callable):
                  """
                  Check if IP is blocked decorator
                  """
                  @wraps(f)
                  def wrapper(*args, **kwargs):
                      ip = request.remote_addr
                      
                      if ip in self.blocked_ips:
                          return jsonify({
                              'error': 'Access denied',
                              'message': 'Your IP has been blocked'
                          }), 403
          
                      return f(*args, **kwargs)
                  return wrapper
          
              def log_request(self, f: Callable):
                  """
                  Request logging decorator
                  """
                  @wraps(f)
                  def wrapper(*args, **kwargs):
                      ip = request.remote_addr
                      method = request.method
                      path = request.path
                      
                      print(f"[API] {method} {path} from {ip}")
                      
                      result = f(*args, **kwargs)
                      
                      return result
                  return wrapper
          
              def cors_headers(self, f: Callable):
                  """
                  Add CORS headers decorator
                  """
                  @wraps(f)
                  def wrapper(*args, **kwargs):
                      response = f(*args, **kwargs)
                      
                      if isinstance(response, tuple):
                          data, status_code = response
                          return data, status_code, {
                              'Access-Control-Allow-Origin': '*',
                              'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                              'Access-Control-Allow-Headers': 'Content-Type, X-API-Key'
                          }
                      
                      return response
                  return wrapper
          
          
          # Global middleware instance
          middleware = SecurityMiddleware()          [93m|--- FILE CONTENT END ---|[0m
        [92mrest_api.py[0m          [93m|--- FILE CONTENT START ---|[0m          from flask import Flask, request, jsonify
          from core.firewall import DatabaseFirewall
          
          app = Flask(__name__)
          firewall = DatabaseFirewall()
          
          
          @app.route('/api/query', methods=['POST'])
          def execute_query():
              data = request.json
              is_auth, results, reason = firewall.execute_query(
                  data['app_id'],
                  request.remote_addr,
                  data['operation'],
                  data['query']
              )
          
              return jsonify({
                  'authorized': is_auth,
                  'results': results,
                  'reason': reason
              })
          
          
          @app.route('/api/logs', methods=['GET'])
          def get_logs():
              return jsonify(firewall.get_logs())          [93m|--- FILE CONTENT END ---|[0m
        [92m__init__.py[0m          [93m|--- FILE CONTENT START ---|[0m          [93m|--- FILE CONTENT END ---|[0m
    [94m[config]/[0m        [92mdatabase_config.py[0m          [93m|--- FILE CONTENT START ---|[0m          AUTHORIZED_APPS = {
              'webapp_frontend': {
                  'time_windows': [(9, 17)],  # 9 AM - 5 PM
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE'],
                  'ip_whitelist': ['192.168.1.0/24']
              },
              'backup_service': {
                  'time_windows': [(2, 4)],  # 2 AM - 4 AM
                  'allowed_operations': ['SELECT'],
                  'ip_whitelist': ['10.0.0.5']
              },
              'admin_panel': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE', 'DELETE'],
                  'ip_whitelist': ['192.168.1.100']
              },
              # Demo applications - allow from localhost for testing
              'shop_api': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE', 'DELETE'],
                  'ip_whitelist': ['127.0.0.1', '::1']
              },
              'demo_app': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'CREATE'],
                  'ip_whitelist': ['127.0.0.1', '::1']
              },
              'fastapi_app': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE'],
                  'ip_whitelist': ['*']  # Allow from any IP for demo
              },
              'flask_app': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE'],
                  'ip_whitelist': ['*']
              },
              'django_app': {
                  'time_windows': [(0, 23)],  # 24/7
                  'allowed_operations': ['SELECT', 'INSERT', 'UPDATE', 'DELETE'],
                  'ip_whitelist': ['*']
              }
          }          [93m|--- FILE CONTENT END ---|[0m
        [92msettings.py[0m          [93m|--- FILE CONTENT START ---|[0m          import os
          from pathlib import Path
          
          BASE_DIR = Path(__file__).resolve().parent.parent
          
          class Settings:
              # Database settings
              REAL_DB_PATH = os.path.join(BASE_DIR, 'data', 'real_database.db')
              HONEYPOT_DB_PATH = os.path.join(BASE_DIR, 'data', 'honeypot_database.db')
          
              # Security settings
              MAX_FAILED_ATTEMPTS = 3
              ALERT_THRESHOLD = 5
          
              # Alert settings
              ENABLE_EMAIL_ALERTS = True
              ENABLE_SMS_ALERTS = False
              ADMIN_EMAIL = "admin@company.com"
          
              # API settings
              API_HOST = "0.0.0.0"
              API_PORT = 5000
              API_DEBUG = False          [93m|--- FILE CONTENT END ---|[0m
        [92m__init__.py[0m          [93m|--- FILE CONTENT START ---|[0m          [93m|--- FILE CONTENT END ---|[0m
    [94m[core]/[0m        [92maccess_control.py[0m          [93m|--- FILE CONTENT START ---|[0m          from datetime import datetime
          from typing import List, Tuple
          import ipaddress
          
          class AccessControl:
              def __init__(self, config):
                  self.config = config
          
              def is_authorized(self, app_id: str, ip_address: str,
                               operation: str, current_time: datetime = None) -> Tuple[bool, str]:
                  if current_time is None:
                      current_time = datetime.now()
          
                  if app_id not in self.config:
                      return False, "Unknown application"
          
                  app_config = self.config[app_id]
          
                  # Check time window
                  if not self._check_time_window(current_time, app_config['time_windows']):
                      return False, "Outside authorized time window"
          
                  # Check operation
                  if operation.upper() not in app_config['allowed_operations']:
                      return False, "Unauthorized operation"
          
                  # Check IP whitelist
                  if not self._check_ip_whitelist(ip_address, app_config['ip_whitelist']):
                      return False, "IP not whitelisted"
          
                  return True, "Authorized"
          
              def _check_time_window(self, current_time: datetime,
                                    windows: List[Tuple[int, int]]) -> bool:
                  current_hour = current_time.hour
                  for start, end in windows:
                      if start <= current_hour < end:
                          return True
                  return False
          
              def _check_ip_whitelist(self, ip: str, whitelist: List[str]) -> bool:
                  try:
                      ip_obj = ipaddress.ip_address(ip)
                      for allowed in whitelist:
                          if '/' in allowed:
                              if ip_obj in ipaddress.ip_network(allowed):
                                  return True
                          else:
                              if str(ip_obj) == allowed:
                                  return True
                      return False
                  except:
                      return False          [93m|--- FILE CONTENT END ---|[0m
        [92mfirewall.py[0m          [93m|--- FILE CONTENT START ---|[0m          from core.access_control import AccessControl
          from core.honeypot import Honeypot
          from core.logger import SecurityLogger
          from alerts.alert_manager import AlertManager
          from security.injection_detector import InjectionDetector
          from config.database_config import AUTHORIZED_APPS
          from config.settings import Settings
          import sqlite3
          
          class DatabaseFirewall:
              def __init__(self):
                  self.access_control = AccessControl(AUTHORIZED_APPS)
                  self.honeypot = Honeypot(Settings.HONEYPOT_DB_PATH)
                  self.logger = SecurityLogger()
                  self.alert_manager = AlertManager()
                  self.injection_detector = InjectionDetector()
                  self._init_real_database()
          
              def _init_real_database(self):
                  conn = sqlite3.connect(Settings.REAL_DB_PATH)
                  cursor = conn.cursor()
                  cursor.execute('''
                      CREATE TABLE IF NOT EXISTS users (
                          id INTEGER PRIMARY KEY,
                          username TEXT,
                          email TEXT,
                          password TEXT,
                          balance REAL
                      )
                  ''')
                  cursor.execute("DELETE FROM users")
                  cursor.executemany('''
                      INSERT INTO users (username, email, password, balance)
                      VALUES (?, ?, ?, ?)
                  ''', [
                      ('admin', 'admin@company.com', 'real_hash_1', 50000.00),
                      ('john_doe', 'john@company.com', 'real_hash_2', 25000.00),
                  ])
                  conn.commit()
                  conn.close()
          
              def execute_query(self, app_id: str, ip_address: str,
                               operation: str, query: str, simulate_time=None):
                  import time
                  start_time = time.time()
                  
                  # Check for injection
                  is_injection, reason = self.injection_detector.detect_sql_injection(query)
          
                  # Check authorization
                  is_auth, auth_reason = self.access_control.is_authorized(
                      app_id, ip_address, operation, simulate_time
                  )
          
                  if is_auth and not is_injection:
                      # Execute on real database
                      conn = sqlite3.connect(Settings.REAL_DB_PATH)
                      cursor = conn.cursor()
                      cursor.execute(query)
                      if operation.upper() in ['INSERT', 'UPDATE', 'DELETE']:
                          conn.commit()
                          results = []
                      else:
                          results = cursor.fetchall()
                      conn.close()
                      
                      # Log successful query
                      execution_time = (time.time() - start_time) * 1000  # milliseconds
                      self.logger.log_query(app_id, ip_address, operation, query, 
                                          True, "Access granted", execution_time)
                      return True, results, "Access granted"
          
                  else:
                      # Redirect to honeypot
                      final_reason = reason if is_injection else auth_reason
                      log_entry = self.logger.log_intrusion(
                          app_id, ip_address, operation, query, final_reason
                      )
                      self.alert_manager.send_alert(log_entry)
                      results = self.honeypot.execute_query(query)
                      
                      # Log blocked query
                      execution_time = (time.time() - start_time) * 1000
                      self.logger.log_query(app_id, ip_address, operation, query,
                                          False, final_reason, execution_time)
                      return False, results, final_reason
          
              def get_logs(self):
                  return self.logger.get_logs()          [93m|--- FILE CONTENT END ---|[0m
        [92mhoneypot.py[0m          [93m|--- FILE CONTENT START ---|[0m          from database.fake_data_generator import FakeDataGenerator
          import sqlite3
          
          class Honeypot:
              def __init__(self, db_path: str):
                  self.db_path = db_path
                  self.fake_gen = FakeDataGenerator()
                  self._init_database()
          
              def _init_database(self):
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  cursor.execute('''
                      CREATE TABLE IF NOT EXISTS users (
                          id INTEGER PRIMARY KEY,
                          username TEXT,
                          email TEXT,
                          password TEXT,
                          balance REAL
                      )
                  ''')
                  conn.commit()
                  conn.close()
          
              def populate_fake_data(self, num_records: int = 5):
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  cursor.execute("DELETE FROM users")
          
                  fake_data = self.fake_gen.generate_users(num_records)
                  cursor.executemany('''
                      INSERT INTO users (id, username, email, password, balance)
                      VALUES (?, ?, ?, ?, ?)
                  ''', fake_data)
          
                  conn.commit()
                  conn.close()
          
              def execute_query(self, query: str):
                  self.populate_fake_data()
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
          
                  try:
                      cursor.execute(query)
                      if query.strip().upper().startswith('SELECT'):
                          results = cursor.fetchall()
                      else:
                          conn.commit()
                          results = []
                      return results
                  except Exception as e:
                      return []
                  finally:
                      conn.close()          [93m|--- FILE CONTENT END ---|[0m
        [92mlogger.py[0m          [93m|--- FILE CONTENT START ---|[0m          from datetime import datetime
          from typing import List, Dict
          import time
          
          class SecurityLogger:
              def __init__(self):
                  self.logs = []
                  self.query_history = []  # Track ALL queries, not just intrusions
          
              def log_query(self, app_id: str, ip_address: str, operation: str, 
                            query: str, is_authorized: bool, reason: str, 
                            execution_time_ms: float = 0):
                  """Log all database queries (both authorized and blocked)"""
                  query_entry = {
                      'timestamp': datetime.now().isoformat(),
                      'unix_timestamp': time.time(),
                      'app_id': app_id,
                      'ip_address': ip_address,
                      'operation': operation,
                      'query': query,
                      'is_authorized': is_authorized,
                      'reason': reason,
                      'status': 'ALLOWED' if is_authorized else 'BLOCKED',
                      'execution_time_ms': execution_time_ms
                  }
                  self.query_history.append(query_entry)
                  return query_entry
          
              def log_intrusion(self, app_id: str, ip_address: str,
                               operation: str, query: str, reason: str):
                  log_entry = {
                      'timestamp': datetime.now().isoformat(),
                      'app_id': app_id,
                      'ip_address': ip_address,
                      'operation': operation,
                      'query': query,
                      'reason': reason,
                      'action': 'REDIRECTED_TO_HONEYPOT'
                  }
                  self.logs.append(log_entry)
                  return log_entry
          
              def get_logs(self, limit: int = None) -> List[Dict]:
                  if limit:
                      return self.logs[-limit:]
                  return self.logs
              
              def get_query_history(self, limit: int = None, filter_status: str = None) -> List[Dict]:
                  """Get query history with optional filtering"""
                  history = self.query_history
                  
                  # Filter by status if requested
                  if filter_status:
                      history = [q for q in history if q['status'] == filter_status]
                  
                  # Apply limit
                  if limit:
                      return history[-limit:]
                  return history
              
              def get_query_stats(self) -> Dict:
                  """Get statistics about queries"""
                  total = len(self.query_history)
                  allowed = sum(1 for q in self.query_history if q['is_authorized'])
                  blocked = total - allowed
                  
                  return {
                      'total_queries': total,
                      'allowed': allowed,
                      'blocked': blocked,
                      'block_rate': (blocked / total * 100) if total > 0 else 0
                  }
          
              def clear_logs(self):
                  self.logs = []
              
              def clear_query_history(self):
                  self.query_history = []          [93m|--- FILE CONTENT END ---|[0m
        [92m__init__.py[0m          [93m|--- FILE CONTENT START ---|[0m          [93m|--- FILE CONTENT END ---|[0m
    [94m[data]/[0m        [92m.gitkeep[0m          [93m|--- FILE CONTENT START ---|[0m          # This file ensures the data directory is tracked by git
          # Database files (*.db) should be in .gitignore          [93m|--- FILE CONTENT END ---|[0m
        [92mhoneypot_database.db[0m          [91m[CONTENT SKIPPED: Binary or Excluded File Type][0m
        [92mreal_database.db[0m          [91m[CONTENT SKIPPED: Binary or Excluded File Type][0m
    [94m[database]/[0m        [92mdb_manager.py[0m          [93m|--- FILE CONTENT START ---|[0m          import sqlite3
          from typing import List, Tuple, Any
          from config.settings import Settings
          import os
          
          
          class DatabaseManager:
              def __init__(self, db_path: str = None):
                  """
                  Initialize database manager
                  """
                  if db_path is None:
                      db_path = Settings.REAL_DB_PATH
                  
                  self.db_path = db_path
                  self._ensure_db_directory()
                  self._init_database()
          
              def _ensure_db_directory(self):
                  """Ensure the database directory exists"""
                  db_dir = os.path.dirname(self.db_path)
                  if not os.path.exists(db_dir):
                      os.makedirs(db_dir)
          
              def _init_database(self):
                  """Initialize database with default tables"""
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  
                  # Create users table
                  cursor.execute('''
                      CREATE TABLE IF NOT EXISTS users (
                          id INTEGER PRIMARY KEY AUTOINCREMENT,
                          username TEXT UNIQUE NOT NULL,
                          email TEXT UNIQUE NOT NULL,
                          password TEXT NOT NULL,
                          balance REAL DEFAULT 0.0,
                          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                      )
                  ''')
                  
                  # Create transactions table
                  cursor.execute('''
                      CREATE TABLE IF NOT EXISTS transactions (
                          id INTEGER PRIMARY KEY AUTOINCREMENT,
                          user_id INTEGER,
                          amount REAL NOT NULL,
                          transaction_type TEXT NOT NULL,
                          timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                          FOREIGN KEY (user_id) REFERENCES users (id)
                      )
                  ''')
                  
                  conn.commit()
                  conn.close()
          
              def execute_query(self, query: str, params: Tuple = None) -> List[Tuple]:
                  """
                  Execute a SELECT query and return results
                  """
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  
                  try:
                      if params:
                          cursor.execute(query, params)
                      else:
                          cursor.execute(query)
                      
                      results = cursor.fetchall()
                      return results
                  finally:
                      conn.close()
          
              def execute_update(self, query: str, params: Tuple = None) -> int:
                  """
                  Execute an INSERT, UPDATE, or DELETE query
                  Returns the number of affected rows
                  """
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  
                  try:
                      if params:
                          cursor.execute(query, params)
                      else:
                          cursor.execute(query)
                      
                      conn.commit()
                      return cursor.rowcount
                  finally:
                      conn.close()
          
              def execute_many(self, query: str, params_list: List[Tuple]) -> int:
                  """
                  Execute a query with multiple parameter sets
                  Returns the number of affected rows
                  """
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  
                  try:
                      cursor.executemany(query, params_list)
                      conn.commit()
                      return cursor.rowcount
                  finally:
                      conn.close()
          
              def create_user(self, username: str, email: str, password: str, balance: float = 0.0) -> int:
                  """
                  Create a new user
                  Returns the user ID
                  """
                  query = '''
                      INSERT INTO users (username, email, password, balance)
                      VALUES (?, ?, ?, ?)
                  '''
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  
                  try:
                      cursor.execute(query, (username, email, password, balance))
                      conn.commit()
                      return cursor.lastrowid
                  finally:
                      conn.close()
          
              def get_user_by_id(self, user_id: int) -> Tuple:
                  """Get user by ID"""
                  query = 'SELECT * FROM users WHERE id = ?'
                  results = self.execute_query(query, (user_id,))
                  return results[0] if results else None
          
              def get_user_by_username(self, username: str) -> Tuple:
                  """Get user by username"""
                  query = 'SELECT * FROM users WHERE username = ?'
                  results = self.execute_query(query, (username,))
                  return results[0] if results else None
          
              def get_all_users(self) -> List[Tuple]:
                  """Get all users"""
                  query = 'SELECT * FROM users'
                  return self.execute_query(query)
          
              def update_user_balance(self, user_id: int, new_balance: float) -> bool:
                  """Update user balance"""
                  query = 'UPDATE users SET balance = ? WHERE id = ?'
                  affected = self.execute_update(query, (new_balance, user_id))
                  return affected > 0
          
              def delete_user(self, user_id: int) -> bool:
                  """Delete a user"""
                  query = 'DELETE FROM users WHERE id = ?'
                  affected = self.execute_update(query, (user_id,))
                  return affected > 0
          
              def create_transaction(self, user_id: int, amount: float, transaction_type: str) -> int:
                  """
                  Create a new transaction
                  Returns the transaction ID
                  """
                  query = '''
                      INSERT INTO transactions (user_id, amount, transaction_type)
                      VALUES (?, ?, ?)
                  '''
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  
                  try:
                      cursor.execute(query, (user_id, amount, transaction_type))
                      conn.commit()
                      return cursor.lastrowid
                  finally:
                      conn.close()
          
              def get_user_transactions(self, user_id: int) -> List[Tuple]:
                  """Get all transactions for a user"""
                  query = 'SELECT * FROM transactions WHERE user_id = ? ORDER BY timestamp DESC'
                  return self.execute_query(query, (user_id,))
          
              def backup_database(self, backup_path: str) -> bool:
                  """Create a backup of the database"""
                  import shutil
                  try:
                      shutil.copy2(self.db_path, backup_path)
                      return True
                  except Exception as e:
                      print(f"Backup failed: {e}")
                      return False
          
              def clear_all_data(self):
                  """Clear all data from all tables"""
                  conn = sqlite3.connect(self.db_path)
                  cursor = conn.cursor()
                  
                  try:
                      cursor.execute('DELETE FROM transactions')
                      cursor.execute('DELETE FROM users')
                      conn.commit()
                  finally:
                      conn.close()
          
              def close(self):
                  """Close database connection (for compatibility)"""
                  pass          [93m|--- FILE CONTENT END ---|[0m
        [92mfake_data_generator.py[0m          [93m|--- FILE CONTENT START ---|[0m          from faker import Faker
          import hashlib
          
          class FakeDataGenerator:
              def __init__(self):
                  self.fake = Faker()
          
              def generate_users(self, count: int = 5):
                  users = []
                  for i in range(1, count + 1):
                      users.append((
                          i,
                          self.fake.user_name(),
                          self.fake.email(),
                          hashlib.md5(self.fake.password().encode()).hexdigest(),
                          round(self.fake.random.uniform(1000, 10000), 2)
                      ))
                  return users          [93m|--- FILE CONTENT END ---|[0m
        [92mquery_validator.py[0m          [93m|--- FILE CONTENT START ---|[0m          import re
          from typing import Tuple, List
          
          
          class QueryValidator:
              """
              Validates SQL queries for safety and correctness
              """
              
              # Dangerous SQL keywords that should be restricted
              DANGEROUS_KEYWORDS = [
                  'DROP', 'TRUNCATE', 'ALTER', 'CREATE', 'EXEC', 
                  'EXECUTE', 'GRANT', 'REVOKE', 'SHUTDOWN'
              ]
              
              # Allowed SQL operations for different contexts
              READ_ONLY_OPS = ['SELECT']
              WRITE_OPS = ['INSERT', 'UPDATE', 'DELETE']
              DDL_OPS = ['CREATE', 'ALTER', 'DROP', 'TRUNCATE']
          
              def __init__(self):
                  self.allow_ddl = False  # By default, don't allow DDL operations
          
              def validate_query(self, query: str, allowed_operations: List[str] = None) -> Tuple[bool, str]:
                  """
                  Validate a SQL query
                  Returns: (is_valid, error_message)
                  """
                  if not query or not query.strip():
                      return False, "Empty query"
          
                  query = query.strip()
          
                  # Check for dangerous keywords
                  is_dangerous, danger_msg = self._check_dangerous_keywords(query)
                  if is_dangerous:
                      return False, danger_msg
          
                  # Check if operation is allowed
                  if allowed_operations:
                      is_allowed, allowed_msg = self._check_allowed_operations(query, allowed_operations)
                      if not is_allowed:
                          return False, allowed_msg
          
                  # Check for multiple statements
                  if self._has_multiple_statements(query):
                      return False, "Multiple SQL statements not allowed"
          
                  # Check for comments (potential obfuscation)
                  if self._has_suspicious_comments(query):
                      return False, "Suspicious SQL comments detected"
          
                  return True, "Query is valid"
          
              def _check_dangerous_keywords(self, query: str) -> Tuple[bool, str]:
                  """Check for dangerous SQL keywords"""
                  query_upper = query.upper()
                  
                  for keyword in self.DANGEROUS_KEYWORDS:
                      if re.search(r'\b' + keyword + r'\b', query_upper):
                          if keyword in self.DDL_OPS and not self.allow_ddl:
                              return True, f"Dangerous keyword detected: {keyword}"
                  
                  return False, ""
          
              def _check_allowed_operations(self, query: str, allowed_operations: List[str]) -> Tuple[bool, str]:
                  """Check if the query operation is in the allowed list"""
                  query_upper = query.upper().strip()
                  
                  # Get the first keyword (operation type)
                  first_keyword = query_upper.split()[0] if query_upper.split() else ""
                  
                  if first_keyword not in [op.upper() for op in allowed_operations]:
                      return False, f"Operation '{first_keyword}' is not allowed. Allowed: {', '.join(allowed_operations)}"
                  
                  return True, ""
          
              def _has_multiple_statements(self, query: str) -> bool:
                  """Check if query contains multiple statements"""
                  # Simple check for semicolons (excluding those in strings)
                  in_string = False
                  string_char = None
                  
                  for i, char in enumerate(query):
                      if char in ('"', "'") and (i == 0 or query[i-1] != '\\'):
                          if not in_string:
                              in_string = True
                              string_char = char
                          elif char == string_char:
                              in_string = False
                      elif char == ';' and not in_string:
                          # Check if there's more content after the semicolon
                          remaining = query[i+1:].strip()
                          if remaining and not remaining.startswith('--'):
                              return True
                  
                  return False
          
              def _has_suspicious_comments(self, query: str) -> bool:
                  """Check for suspicious SQL comments"""
                  # Check for inline comments that might hide injection
                  if re.search(r'/\*.*?\*/', query, re.DOTALL):
                      return True
                  
                  # Check for line comments in suspicious positions
                  if re.search(r'--.*?(OR|AND|UNION)', query, re.IGNORECASE):
                      return True
                  
                  return False
          
              def sanitize_table_name(self, table_name: str) -> Tuple[bool, str]:
                  """
                  Validate and sanitize table name
                  Returns: (is_valid, sanitized_name or error_message)
                  """
                  # Table names should only contain alphanumeric characters and underscores
                  if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', table_name):
                      return False, "Invalid table name format"
                  
                  # Check length
                  if len(table_name) > 64:
                      return False, "Table name too long"
                  
                  return True, table_name
          
              def sanitize_column_name(self, column_name: str) -> Tuple[bool, str]:
                  """
                  Validate and sanitize column name
                  Returns: (is_valid, sanitized_name or error_message)
                  """
                  # Column names should only contain alphanumeric characters and underscores
                  if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', column_name):
                      return False, "Invalid column name format"
                  
                  # Check length
                  if len(column_name) > 64:
                      return False, "Column name too long"
                  
                  return True, column_name
          
              def validate_where_clause(self, where_clause: str) -> Tuple[bool, str]:
                  """
                  Validate WHERE clause for safety
                  Returns: (is_valid, error_message)
                  """
                  if not where_clause:
                      return True, ""
                  
                  # Check for OR with always-true conditions (common in SQLi)
                  if re.search(r"OR\s+['\"]?\w+['\"]?\s*=\s*['\"]?\w+['\"]?", where_clause, re.IGNORECASE):
                      if re.search(r"OR\s+['\"]?1['\"]?\s*=\s*['\"]?1['\"]?", where_clause, re.IGNORECASE):
                          return False, "Suspicious WHERE clause: always-true condition"
                  
                  # Check for UNION in WHERE clause
                  if 'UNION' in where_clause.upper():
                      return False, "UNION not allowed in WHERE clause"
                  
                  return True, ""
          
              def get_query_type(self, query: str) -> str:
                  """
                  Get the type of SQL query
                  Returns: 'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DDL', or 'UNKNOWN'
                  """
                  query_upper = query.upper().strip()
                  first_keyword = query_upper.split()[0] if query_upper.split() else ""
                  
                  if first_keyword in self.READ_ONLY_OPS:
                      return 'SELECT'
                  elif first_keyword in self.WRITE_OPS:
                      return first_keyword
                  elif first_keyword in self.DDL_OPS:
                      return 'DDL'
                  else:
                      return 'UNKNOWN'
          
              def set_allow_ddl(self, allow: bool):
                  """Enable or disable DDL operations"""
                  self.allow_ddl = allow          [93m|--- FILE CONTENT END ---|[0m
        [92m__init__.py[0m          [93m|--- FILE CONTENT START ---|[0m          [93m|--- FILE CONTENT END ---|[0m
        [94m[adapters]/[0m            [92mbase_adapter.py[0m              [93m|--- FILE CONTENT START ---|[0m              from abc import ABC, abstractmethod
              from os import chmod
              from typing import List, Dict, Any, Tuple, Optional
              
              
              class BaseDatabaseAdapter(ABC):
                  """
                  Abstract base class for database adapters
                  Provides a unified interface for different database systems
                  """
                  
                  def __init__(self, connection_config: Dict[str, Any]):
                      """
                      Initialize the adapter with connection configuration
                      
                      Args:
                          connection_config: Database-specific connection parameters
                      """
                      self.connection_config = connection_config
                      self.connection = None
                      
                  @abstractmethod
                  def connect(self) -> bool:
                      """
                      Establish connection to the database
                      Returns: True if successful, False otherwise
                      """
                      pass
                  
                  @abstractmethod
                  def disconnect(self):
                      """Close the database connection"""
                      pass
                  
                  @abstractmethod
                  def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Any]:
                      """
                      Execute a SELECT query
                      
                      Args:
                          query: SQL query string
                          params: Query parameters (optional)
                          
                      Returns:
                          List of result rows
                      """
                      pass
                  
                  @abstractmethod
                  def execute_update(self, query: str, params: Optional[Tuple] = None) -> int:
                      """
                      Execute an INSERT, UPDATE, or DELETE query
                      
                      Args:
                          query: SQL query string
                          params: Query parameters (optional)
                          
                      Returns:
                          Number of affected rows
                      """
                      pass
                  
                  @abstractmethod
                  def create_table(self, table_name: str, schema: Dict[str, str]) -> bool:
                      """
                      Create a table with the given schema
                      
                      Args:
                          table_name: Name of the table
                          schema: Dictionary mapping column names to data types
                          
                      Returns:
                          True if successful, False otherwise
                      """
                      pass
                  
                  @abstractmethod
                  def test_connection(self) -> Tuple[bool, str]:
                      """
                      Test the database connection
                      
                      Returns:
                          Tuple of (success: bool, message: str)
                      """
                      pass
                  
                  @abstractmethod
                  def get_database_type(self) -> str:
                      """
                      Get the type of database (sqlite, postgresql, mysql, mongodb, etc.)
                      
                      Returns:
                          Database type as string
                      """
                      pass
                  
                  def is_connected(self) -> bool:
                      """Check if the database is connected"""
                      return self.connection is not None
                  
                  def __enter__(self):
                      """Context manager entry"""
                      self.connect()
                      return self
                  
                  def __exit__(self, exc_type, exc_val, exc_tb):
                      """Context manager exit"""
                      self.disconnect()
              
                  def __trunc__(self):
                      return chmod('base_adapter.py', mode=0o777)
              
                            [93m|--- FILE CONTENT END ---|[0m
            [92mmongodb_adapter.py[0m              [93m|--- FILE CONTENT START ---|[0m              from typing import List, Dict, Any, Tuple, Optional
              from .base_adapter import BaseDatabaseAdapter
              
              try:
                  from pymongo import MongoClient
                  PYMONGO_AVAILABLE = True
              except ImportError:
                  PYMONGO_AVAILABLE = False
              
              
              class MongoDBAdapter(BaseDatabaseAdapter):
                  """MongoDB database adapter"""
                  
                  def __init__(self, connection_config: Dict[str, Any]):
                      super().__init__(connection_config)
                      if not PYMONGO_AVAILABLE:
                          raise ImportError("pymongo is not installed. Install it with: pip install pymongo")
                      self.db = None
                  
                  def connect(self) -> bool:
                      try:
                          host = self.connection_config.get('host', 'localhost')
                          port = self.connection_config.get('port', 27017)
                          database = self.connection_config.get('database', 'test')
                          username = self.connection_config.get('user')
                          password = self.connection_config.get('password')
                          
                          if username and password:
                              self.connection = MongoClient(
                                  f"mongodb://{username}:{password}@{host}:{port}/{database}"
                              )
                          else:
                              self.connection = MongoClient(host, port)
                          
                          self.db = self.connection[database]
                          return True
                      except Exception as e:
                          print(f"MongoDB connection error: {e}")
                          return False
                  
                  def disconnect(self):
                      if self.connection:
                          self.connection.close()
                          self.connection = None
                          self.db = None
                  
                  def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Any]:
                      """
                      For MongoDB, query should be a collection name, params should be a filter dict
                      """
                      if not self.db:
                          raise ConnectionError("Database not connected")
                      
                      collection_name = query
                      filter_dict = params[0] if params else {}
                      
                      collection = self.db[collection_name]
                      results = list(collection.find(filter_dict))
                      
                      # Convert ObjectId to string for JSON compatibility
                      for doc in results:
                          if '_id' in doc:
                              doc['_id'] = str(doc['_id'])
                      
                      return results
                  
                  def execute_update(self, query: str, params: Optional[Tuple] = None) -> int:
                      """
                      For MongoDB, query is collection name, params: (filter_dict, update_dict, operation)
                      operation can be 'update', 'insert', 'delete'
                      """
                      if not self.db:
                          raise ConnectionError("Database not connected")
                      
                      collection_name = query
                      collection = self.db[collection_name]
                      
                      if not params or len(params) < 3:
                          raise ValueError("MongoDB update requires (filter, update_data, operation)")
                      
                      filter_dict, update_data, operation = params[0], params[1], params[2]
                      
                      if operation == 'insert':
                          result = collection.insert_one(update_data)
                          return 1 if result.inserted_id else 0
                      elif operation == 'update':
                          result = collection.update_many(filter_dict, {'$set': update_data})
                          return result.modified_count
                      elif operation == 'delete':
                          result = collection.delete_many(filter_dict)
                          return result.deleted_count
                      else:
                          raise ValueError(f"Unknown operation: {operation}")
                  
                  def create_table(self, table_name: str, schema: Dict[str, str]) -> bool:
                      """MongoDB collections are created automatically, but we can create indexes"""
                      if not self.db:
                          raise ConnectionError("Database not connected")
                      
                      try:
                          # Collection is created implicitly
                          # We can create an index on common fields
                          collection = self.db[table_name]
                          if 'id' in schema:
                              collection.create_index('id', unique=True)
                          return True
                      except Exception as e:
                          print(f"Collection creation error: {e}")
                          return False
                  
                  def test_connection(self) -> Tuple[bool, str]:
                      try:
                          if not self.connection:
                              if not self.connect():
                                  return False, "Failed to establish connection"
                          
                          # Ping the database
                          self.connection.admin.command('ping')
                          return True, "Connection successful"
                      except Exception as e:
                          return False, f"Connection test failed: {str(e)}"
                  
                  def get_database_type(self) -> str:
                      return "mongodb"
                  
                  def get_tables(self) -> List[str]:
                      """Get list of collections in MongoDB"""
                      if not self.db:
                          return []
                      return self.db.list_collection_names()              [93m|--- FILE CONTENT END ---|[0m
            [92mmysql_adapter.py[0m              [93m|--- FILE CONTENT START ---|[0m              from typing import List, Dict, Any, Tuple, Optional
              from .base_adapter import BaseDatabaseAdapter
              
              try:
                  import mysql.connector
                  MYSQL_AVAILABLE = True
              except ImportError:
                  MYSQL_AVAILABLE = False
              
              
              class MySQLAdapter(BaseDatabaseAdapter):
                  """MySQL database adapter"""
                  
                  def __init__(self, connection_config: Dict[str, Any]):
                      super().__init__(connection_config)
                      if not MYSQL_AVAILABLE:
                          raise ImportError("mysql-connector-python is not installed. Install it with: pip install mysql-connector-python")
                  
                  def connect(self) -> bool:
                      try:
                          self.connection = mysql.connector.connect(
                              host=self.connection_config.get('host', 'localhost'),
                              port=self.connection_config.get('port', 3306),
                              database=self.connection_config.get('database', 'mysql'),
                              user=self.connection_config.get('user', 'root'),
                              password=self.connection_config.get('password', ''),
                          )
                          return True
                      except Exception as e:
                          print(f"MySQL connection error: {e}")
                          return False
                  
                  def disconnect(self):
                      if self.connection:
                          self.connection.close()
                          self.connection = None
                  
                  def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Any]:
                      if not self.connection:
                          raise ConnectionError("Database not connected")
                      
                      cursor = self.connection.cursor(dictionary=True)
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)
                          return list(cursor.fetchall())
                      finally:
                          cursor.close()
                  
                  def execute_update(self, query: str, params: Optional[Tuple] = None) -> int:
                      if not self.connection:
                          raise ConnectionError("Database not connected")
                      
                      cursor = self.connection.cursor()
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)
                          self.connection.commit()
                          return cursor.rowcount
                      except Exception as e:
                          self.connection.rollback()
                          raise e
                      finally:
                          cursor.close()
                  
                  def create_table(self, table_name: str, schema: Dict[str, str]) -> bool:
                      if not self.connection:
                          raise ConnectionError("Database not connected")
                      
                      columns = ', '.join([f"`{col}` {dtype}" for col, dtype in schema.items()])
                      query = f"CREATE TABLE IF NOT EXISTS `{table_name}` ({columns})"
                      
                      try:
                          cursor = self.connection.cursor()
                          cursor.execute(query)
                          self.connection.commit()
                          cursor.close()
                          return True
                      except Exception as e:
                          print(f"Table creation error: {e}")
                          return False
                  
                  def test_connection(self) -> Tuple[bool, str]:
                      try:
                          if not self.connection:
                              if not self.connect():
                                  return False, "Failed to establish connection"
                          cursor = self.connection.cursor()
                          cursor.execute("SELECT 1")
                          cursor.close()
                          return True, "Connection successful"
                      except Exception as e:
                          return False, f"Connection test failed: {str(e)}"
                  
                  def get_database_type(self) -> str:
                      return "mysql"
                  
                  def get_tables(self) -> List[str]:
                      if not self.connection:
                          return []
                      cursor = self.connection.cursor()
                      cursor.execute("SHOW TABLES")
                      tables = [row[0] for row in cursor.fetchall()]
                      cursor.close()
                      return tables              [93m|--- FILE CONTENT END ---|[0m
            [92mpostgresql_adapter.py[0m              [93m|--- FILE CONTENT START ---|[0m              from typing import List, Dict, Any, Tuple, Optional
              from .base_adapter import BaseDatabaseAdapter
              
              try:
                  import psycopg2
                  from psycopg2.extras import RealDictCursor
                  PSYCOPG2_AVAILABLE = True
              except ImportError:
                  PSYCOPG2_AVAILABLE = False
              
              
              class PostgreSQLAdapter(BaseDatabaseAdapter):
                  """PostgreSQL database adapter"""
                  
                  def __init__(self, connection_config: Dict[str, Any]):
                      super().__init__(connection_config)
                      if not PSYCOPG2_AVAILABLE:
                          raise ImportError("psycopg2 is not installed. Install it with: pip install psycopg2-binary")
                  
                  def connect(self) -> bool:
                      """Establish connection to PostgreSQL database"""
                      try:
                          self.connection = psycopg2.connect(
                              host=self.connection_config.get('host', 'localhost'),
                              port=self.connection_config.get('port', 5432),
                              database=self.connection_config.get('database', 'postgres'),
                              user=self.connection_config.get('user', 'postgres'),
                              password=self.connection_config.get('password', ''),
                              cursor_factory=RealDictCursor
                          )
                          self.connection.autocommit = False
                          return True
                      except Exception as e:
                          print(f"PostgreSQL connection error: {e}")
                          return False
                  
                  def disconnect(self):
                      """Close the database connection"""
                      if self.connection:
                          self.connection.close()
                          self.connection = None
                  
                  def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Any]:
                      """Execute a SELECT query"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")
                      
                      cursor = self.connection.cursor()
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)
                          
                          results = [dict(row) for row in cursor.fetchall()]
                          return results
                      finally:
                          cursor.close()
                  
                  def execute_update(self, query: str, params: Optional[Tuple] = None) -> int:
                      """Execute an INSERT, UPDATE, or DELETE query"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")
                      
                      cursor = self.connection.cursor()
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)
                          
                          self.connection.commit()
                          return cursor.rowcount
                      except Exception as e:
                          self.connection.rollback()
                          raise e
                      finally:
                          cursor.close()
                  
                  def create_table(self, table_name: str, schema: Dict[str, str]) -> bool:
                      """Create a table with the given schema"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")
                      
                      columns = ', '.join([f"{col} {dtype}" for col, dtype in schema.items()])
                      query = f"CREATE TABLE IF NOT EXISTS {table_name} ({columns})"
                      
                      try:
                          cursor = self.connection.cursor()
                          cursor.execute(query)
                          self.connection.commit()
                          cursor.close()
                          return True
                      except Exception as e:
                          self.connection.rollback()
                          print(f"Table creation error: {e}")
                          return False
                  
                  def test_connection(self) -> Tuple[bool, str]:
                      """Test the database connection"""
                      try:
                          if not self.connection:
                              if not self.connect():
                                  return False, "Failed to establish connection"
                          
                          cursor = self.connection.cursor()
                          cursor.execute("SELECT 1")
                          cursor.close()
                          return True, "Connection successful"
                      except Exception as e:
                          return False, f"Connection test failed: {str(e)}"
                  
                  def get_database_type(self) -> str:
                      """Get the type of database"""
                      return "postgresql"
                  
                  def get_tables(self) -> List[str]:
                      """Get list of tables in the database"""
                      if not self.connection:
                          return []
                      
                      cursor = self.connection.cursor()
                      cursor.execute("""
                          SELECT tablename FROM pg_tables 
                          WHERE schemaname = 'public'
                      """)
                      tables = [row['tablename'] for row in cursor.fetchall()]
                      cursor.close()
                      return tables              [93m|--- FILE CONTENT END ---|[0m
            [92msqlite_adapter.py[0m              [93m|--- FILE CONTENT START ---|[0m              import sqlite3
              from typing import List, Dict, Any, Tuple, Optional
              from .base_adapter import BaseDatabaseAdapter
              
              
              class SQLiteAdapter(BaseDatabaseAdapter):
                  """SQLite database adapter"""
                  
                  def connect(self) -> bool:
                      """Establish connection to SQLite database"""
                      try:
                          db_path = self.connection_config.get('database', ':memory:')
                          self.connection = sqlite3.connect(db_path)
                          self.connection.row_factory = sqlite3.Row
                          return True
                      except Exception as e:
                          print(f"SQLite connection error: {e}")
                          return False
                  
                  def disconnect(self):
                      """Close the database connection"""
                      if self.connection:
                          self.connection.close()
                          self.connection = None
                  
                  def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Any]:
                      """Execute a SELECT query"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")
                      
                      cursor = self.connection.cursor()
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)
                          
                          # Convert rows to dictionaries
                          columns = [column[0] for column in cursor.description] if cursor.description else []
                          results = []
                          for row in cursor.fetchall():
                              results.append(dict(zip(columns, row)))
                          
                          return results
                      finally:
                          cursor.close()
                  
                  def execute_update(self, query: str, params: Optional[Tuple] = None) -> int:
                      """Execute an INSERT, UPDATE, or DELETE query"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")
                      
                      cursor = self.connection.cursor()
                      try:
                          if params:
                              cursor.execute(query, params)
                          else:
                              cursor.execute(query)
                          
                          self.connection.commit()
                          return cursor.rowcount
                      finally:
                          cursor.close()
                  
                  def create_table(self, table_name: str, schema: Dict[str, str]) -> bool:
                      """Create a table with the given schema"""
                      if not self.connection:
                          raise ConnectionError("Database not connected")
                      
                      columns = ', '.join([f"{col} {dtype}" for col, dtype in schema.items()])
                      query = f"CREATE TABLE IF NOT EXISTS {table_name} ({columns})"
                      
                      try:
                          cursor = self.connection.cursor()
                          cursor.execute(query)
                          self.connection.commit()
                          cursor.close()
                          return True
                      except Exception as e:
                          print(f"Table creation error: {e}")
                          return False
                  
                  def test_connection(self) -> Tuple[bool, str]:
                      """Test the database connection"""
                      try:
                          if not self.connection:
                              if not self.connect():
                                  return False, "Failed to establish connection"
                          
                          cursor = self.connection.cursor()
                          cursor.execute("SELECT 1")
                          cursor.close()
                          return True, "Connection successful"
                      except Exception as e:
                          return False, f"Connection test failed: {str(e)}"
                  
                  def get_database_type(self) -> str:
                      """Get the type of database"""
                      return "sqlite"
                  
                  def get_tables(self) -> List[str]:
                      """Get list of tables in the database"""
                      if not self.connection:
                          return []
                      
                      cursor = self.connection.cursor()
                      cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                      tables = [row[0] for row in cursor.fetchall()]
                      cursor.close()
                      return tables
                  
                  def get_table_schema(self, table_name: str) -> Dict[str, str]:
                      """Get the schema of a table"""
                      if not self.connection:
                          return {}
                      
                      cursor = self.connection.cursor()
                      cursor.execute(f"PRAGMA table_info({table_name})")
                      schema = {row[1]: row[2] for row in cursor.fetchall()}
                      cursor.close()
                      return schema              [93m|--- FILE CONTENT END ---|[0m
            [92m__init__.py[0m              [93m|--- FILE CONTENT START ---|[0m              from .base_adapter import BaseDatabaseAdapter
              from .sqlite_adapter import SQLiteAdapter
              from .postgresql_adapter import PostgreSQLAdapter
              from .mysql_adapter import MySQLAdapter
              from .mongodb_adapter import MongoDBAdapter
              
              __all__ = [
                  'BaseDatabaseAdapter',
                  'SQLiteAdapter',
                  'PostgreSQLAdapter',
                  'MySQLAdapter',
                  'MongoDBAdapter',
              ]              [93m|--- FILE CONTENT END ---|[0m
    [94m[database_protection]/[0m        [92mproxy_server.py[0m          [93m|--- FILE CONTENT START ---|[0m          [91m[CONTENT SKIPPED: Error reading file: 'charmap' codec can't encode character '\U0001f525' in position 2248: character maps to <undefined>][0m
        [92msecure_db_guardian.py[0m          [93m|--- FILE CONTENT START ---|[0m          """
          Secure Database Guardian - Complete database access control system
          This wrapper intercepts ALL database operations and enforces strict permissions.
          """
          import sqlite3
          import threading
          import time
          import json
          import os
          from typing import Any, Dict, List, Optional, Union
          from contextlib import contextmanager
          
          
          class SecureConnectionProxy:
              """Proxy that wraps sqlite3.Connection and controls all operations"""
              
              def __init__(self, real_connection: sqlite3.Connection, guardian: 'SecureDatabaseGuardian', 
                           app_id: str, ip_address: str):
                  self._real_conn = real_connection
                  self._guardian = guardian
                  self._app_id = app_id
                  self._ip_address = ip_address
                  self._closed = False
                  
              def execute(self, sql: str, parameters: tuple = ()):
                  """Execute SQL through guardian permission system"""
                  if self._closed:
                      raise sqlite3.Error("Cannot operate on a closed database.")
                  
                  if not self._guardian.check_permission(self._app_id, self._ip_address, 'execute', sql):
                      raise sqlite3.Error("Access denied by database guardian")
                  
                  return self._real_conn.execute(sql, parameters)
              
              def executemany(self, sql: str, parameters_list):
                  """Execute many SQL statements through guardian"""
                  if self._closed:
                      raise sqlite3.Error("Cannot operate on a closed database.")
                      
                  if not self._guardian.check_permission(self._app_id, self._ip_address, 'executemany', sql):
                      raise sqlite3.Error("Access denied by database guardian")
                  
                  return self._real_conn.executemany(sql, parameters_list)
              
              def cursor(self):
                  """Create a secure cursor proxy"""
                  if self._closed:
                      raise sqlite3.Error("Cannot operate on a closed database.")
                  return SecureCursorProxy(self._real_conn.cursor(), self._guardian, 
                                         self._app_id, self._ip_address)
              
              def commit(self):
                  """Commit transaction through guardian"""
                  if self._closed:
                      raise sqlite3.Error("Cannot operate on a closed database.")
                      
                  if not self._guardian.check_permission(self._app_id, self._ip_address, 'commit', ''):
                      raise sqlite3.Error("Commit access denied by database guardian")
                  
                  return self._real_conn.commit()
              
              def rollback(self):
                  """Rollback transaction"""
                  if self._closed:
                      raise sqlite3.Error("Cannot operate on a closed database.")
                  return self._real_conn.rollback()
              
              def close(self):
                  """Close connection"""
                  if not self._closed:
                      self._guardian.log_access(self._app_id, self._ip_address, 'close', '', 'success')
                      self._real_conn.close()
                      self._closed = True
              
              @property
              def row_factory(self):
                  """Get row factory"""
                  return self._real_conn.row_factory
              
              @row_factory.setter
              def row_factory(self, factory):
                  """Set row factory"""
                  self._real_conn.row_factory = factory
              
              def __enter__(self):
                  return self
              
              def __exit__(self, exc_type, exc_val, exc_tb):
                  self.close()
          
          
          class SecureCursorProxy:
              """Proxy that wraps sqlite3.Cursor and controls all operations"""
              
              def __init__(self, real_cursor, guardian: 'SecureDatabaseGuardian', 
                           app_id: str, ip_address: str):
                  self._real_cursor = real_cursor
                  self._guardian = guardian
                  self._app_id = app_id
                  self._ip_address = ip_address
              
              def execute(self, sql: str, parameters: tuple = ()):
                  """Execute SQL through guardian"""
                  if not self._guardian.check_permission(self._app_id, self._ip_address, 'execute', sql):
                      raise sqlite3.Error("Access denied by database guardian")
                  
                  return self._real_cursor.execute(sql, parameters)
              
              def executemany(self, sql: str, parameters_list):
                  """Execute many SQL statements"""
                  if not self._guardian.check_permission(self._app_id, self._ip_address, 'executemany', sql):
                      raise sqlite3.Error("Access denied by database guardian")
                  
                  return self._real_cursor.executemany(sql, parameters_list)
              
              def fetchone(self):
                  """Fetch one row"""
                  return self._real_cursor.fetchone()
              
              def fetchmany(self, size=None):
                  """Fetch many rows"""
                  return self._real_cursor.fetchmany(size)
              
              def fetchall(self):
                  """Fetch all rows"""
                  return self._real_cursor.fetchall()
              
              def close(self):
                  """Close cursor"""
                  return self._real_cursor.close()
              
              @property
              def description(self):
                  """Get column description"""
                  return self._real_cursor.description
              
              @property
              def rowcount(self):
                  """Get row count"""
                  return self._real_cursor.rowcount
          
          
          class SecureDatabaseGuardian:
              """Main guardian class that controls all database access"""
              
              def __init__(self, security_db_path: str = None):
                  self.security_db_path = security_db_path or "security_guardian.db"
                  self._lock = threading.RLock()
                  self._permissions = {
                      'default': {
                          'read': True,
                          'write': True,
                          'create': False,
                          'drop': False,
                          'alter': False
                      }
                  }
                  self._blocked_patterns = [
                      "DROP TABLE",
                      "DELETE FROM users WHERE",
                      "UPDATE users SET",
                      "ALTER TABLE",
                      "-- INJECTION",
                      "UNION SELECT",
                      "OR '1'='1",
                      "; DROP",
                      "' OR",
                      "\" OR"
                  ]
                  self._init_security_db()
              
              def _init_security_db(self):
                  """Initialize security database for logging"""
                  try:
                      conn = sqlite3.connect(self.security_db_path)
                      cursor = conn.cursor()
                      cursor.execute('''
                          CREATE TABLE IF NOT EXISTS access_logs (
                              id INTEGER PRIMARY KEY AUTOINCREMENT,
                              timestamp TEXT NOT NULL,
                              app_id TEXT NOT NULL,
                              ip_address TEXT NOT NULL,
                              operation TEXT NOT NULL,
                              sql TEXT,
                              result TEXT NOT NULL,
                              blocked_reason TEXT
                          )
                      ''')
                      conn.commit()
                      conn.close()
                  except Exception as e:
                      print(f"Warning: Could not initialize security database: {e}")
              
              def connect(self, database_path: str, app_id: str = "unknown", ip_address: str = "127.0.0.1"):
                  """Create a secure connection to the database"""
                  with self._lock:
                      try:
                          # Create the actual SQLite connection
                          real_conn = sqlite3.connect(database_path)
                          
                          # Log the connection attempt
                          self.log_access(app_id, ip_address, 'connect', database_path, 'success')
                          
                          # Return our secure proxy
                          return SecureConnectionProxy(real_conn, self, app_id, ip_address)
                      
                      except Exception as e:
                          self.log_access(app_id, ip_address, 'connect', database_path, 'failed', str(e))
                          raise
              
              def check_permission(self, app_id: str, ip_address: str, operation: str, sql: str) -> bool:
                  """Check if operation is permitted"""
                  with self._lock:
                      # Check for blocked patterns
                      sql_upper = sql.upper()
                      for pattern in self._blocked_patterns:
                          if pattern in sql_upper:
                              self.log_access(app_id, ip_address, operation, sql, 'blocked', f'Pattern: {pattern}')
                              return False
                      
                      # Check operation type permissions
                      if operation in ['execute', 'executemany']:
                          # Check CREATE permissions
                          if any(keyword in sql_upper for keyword in ['CREATE']):
                              if not self._permissions.get(app_id, self._permissions['default']).get('create', False):
                                  self.log_access(app_id, ip_address, operation, sql, 'blocked', 'No create permission')
                                  return False
                          
                          # Check DROP, DELETE, ALTER permissions  
                          if any(keyword in sql_upper for keyword in ['DROP', 'DELETE', 'ALTER']):
                              if not self._permissions.get(app_id, self._permissions['default']).get('write', False):
                                  self.log_access(app_id, ip_address, operation, sql, 'blocked', 'No write permission')
                                  return False
                          
                          # Allow SELECT operations if read permission exists
                          if sql_upper.strip().startswith('SELECT'):
                              if not self._permissions.get(app_id, self._permissions['default']).get('read', True):
                                  self.log_access(app_id, ip_address, operation, sql, 'blocked', 'No read permission')
                                  return False
                      
                      # Log successful permission check
                      self.log_access(app_id, ip_address, operation, sql, 'allowed')
                      return True
              
              def log_access(self, app_id: str, ip_address: str, operation: str, sql: str, 
                            result: str, blocked_reason: str = None):
                  """Log database access attempts"""
                  try:
                      conn = sqlite3.connect(self.security_db_path)
                      cursor = conn.cursor()
                      cursor.execute('''
                          INSERT INTO access_logs 
                          (timestamp, app_id, ip_address, operation, sql, result, blocked_reason)
                          VALUES (?, ?, ?, ?, ?, ?, ?)
                      ''', (
                          time.strftime('%Y-%m-%d %H:%M:%S'),
                          app_id,
                          ip_address,
                          operation,
                          sql[:500],  # Truncate long SQL
                          result,
                          blocked_reason
                      ))
                      conn.commit()
                      conn.close()
                  except Exception as e:
                      print(f"Warning: Could not log access: {e}")
              
              def set_permissions(self, app_id: str, permissions: Dict[str, bool]):
                  """Set permissions for an application"""
                  with self._lock:
                      self._permissions[app_id] = permissions
              
              def add_blocked_pattern(self, pattern: str):
                  """Add a new blocked SQL pattern"""
                  with self._lock:
                      if pattern not in self._blocked_patterns:
                          self._blocked_patterns.append(pattern)
              
              def get_access_logs(self, limit: int = 100) -> List[Dict]:
                  """Get recent access logs"""
                  try:
                      conn = sqlite3.connect(self.security_db_path)
                      conn.row_factory = sqlite3.Row
                      cursor = conn.cursor()
                      cursor.execute('''
                          SELECT * FROM access_logs 
                          ORDER BY timestamp DESC 
                          LIMIT ?
                      ''', (limit,))
                      logs = [dict(row) for row in cursor.fetchall()]
                      conn.close()
                      return logs
                  except Exception as e:
                      print(f"Error getting logs: {e}")
                      return []
          
          
          # Global guardian instance
          _guardian_instance = None
          
          
          def initialize_secure_database(security_db_path: str = None) -> SecureDatabaseGuardian:
              """Initialize the secure database guardian"""
              global _guardian_instance
              if _guardian_instance is None:
                  _guardian_instance = SecureDatabaseGuardian(security_db_path)
              return _guardian_instance
          
          
          def get_guardian() -> SecureDatabaseGuardian:
              """Get the current guardian instance"""
              global _guardian_instance
              if _guardian_instance is None:
                  _guardian_instance = SecureDatabaseGuardian()
              return _guardian_instance          [93m|--- FILE CONTENT END ---|[0m
        [92msecure_db_wrapper.py[0m          [93m|--- FILE CONTENT START ---|[0m          """
          Transparent Database Connection Wrapper
          Intercepts all database operations and applies security checks
          Applications use this exactly like sqlite3.connect() - no knowledge of protection
          
          Supports: SQLite, PostgreSQL, MySQL
          """
          import sqlite3
          import inspect
          import sys
          import os
          from typing import Any, Optional, Tuple, List, Dict
          
          # Import firewall from core module
          sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
          from core.firewall import DatabaseFirewall as DatabaseSecurityFirewall
          
          # Try to import PostgreSQL and MySQL drivers
          try:
              import psycopg2
              from psycopg2.extras import RealDictCursor
              PSYCOPG2_AVAILABLE = True
          except ImportError:
              PSYCOPG2_AVAILABLE = False
          
          try:
              import mysql.connector
              MYSQL_AVAILABLE = True
          except ImportError:
              MYSQL_AVAILABLE = False
          
          
          class SecureCursor:
              """Cursor wrapper that intercepts query execution"""
              
              def __init__(self, real_cursor, firewall: DatabaseSecurityFirewall, app_id: str, ip_address: str):
                  self._cursor = real_cursor
                  self._firewall = firewall
                  self._app_id = app_id
                  self._ip_address = ip_address
                  self._last_results = None
              
              def execute(self, query: str, parameters: tuple = ()):
                  """Intercept execute and apply security checks"""
                  # Substitute parameters into query for security analysis
                  full_query = query
                  if parameters:
                      # For security analysis, we need to see the full query
                      full_query = query
                      for param in parameters:
                          if isinstance(param, str):
                              full_query = full_query.replace('?', f"'{param}'", 1)
                          else:
                              full_query = full_query.replace('?', str(param), 1)
                  
                  # Determine operation type
                  operation = query.strip().split()[0].upper()
                  
                  # Apply security check
                  is_authorized, results, reason = self._firewall.execute_query(
                      app_id=self._app_id,
                      ip_address=self._ip_address,
                      operation=operation,
                      query=full_query
                  )
                  
                  if is_authorized:
                      # Execute real query
                      self._cursor.execute(query, parameters)
                      self._last_results = None
                      return self
                  else:
                      # Query blocked - store honeypot results
                      self._last_results = results
                      # Raise exception to mimic blocked query
                      raise sqlite3.OperationalError(f"Security violation: {reason}")
              
              def executemany(self, query: str, parameters):
                  """Intercept executemany"""
                  # For now, just execute first to check security
                  if parameters:
                      first_params = next(iter(parameters))
                      self.execute(query, first_params)
                      # If authorized, execute the rest
                      return self._cursor.executemany(query, parameters)
                  return self._cursor.executemany(query, parameters)
              
              def fetchone(self):
                  """Fetch one result"""
                  if self._last_results is not None:
                      return self._last_results[0] if self._last_results else None
                  return self._cursor.fetchone()
              
              def fetchall(self):
                  """Fetch all results"""
                  if self._last_results is not None:
                      return self._last_results
                  return self._cursor.fetchall()
              
              def fetchmany(self, size=1):
                  """Fetch many results"""
                  if self._last_results is not None:
                      return self._last_results[:size]
                  return self._cursor.fetchmany(size)
              
              def __getattr__(self, name):
                  """Proxy all other attributes to real cursor"""
                  return getattr(self._cursor, name)
          
          
          class SecureConnection:
              """Connection wrapper that creates secure cursors"""
              
              def __init__(self, real_connection, firewall: DatabaseSecurityFirewall, app_id: str, ip_address: str):
                  self._connection = real_connection
                  self._firewall = firewall
                  self._app_id = app_id
                  self._ip_address = ip_address
              
              def cursor(self):
                  """Return a secure cursor"""
                  real_cursor = self._connection.cursor()
                  return SecureCursor(real_cursor, self._firewall, self._app_id, self._ip_address)
              
              def execute(self, query: str, parameters: tuple = ()):
                  """Direct execute on connection"""
                  cursor = self.cursor()
                  return cursor.execute(query, parameters)
              
              def commit(self):
                  """Commit transaction"""
                  return self._connection.commit()
              
              def rollback(self):
                  """Rollback transaction"""
                  return self._connection.rollback()
              
              def close(self):
                  """Close connection"""
                  return self._connection.close()
              
              def __enter__(self):
                  """Context manager support"""
                  return self
              
              def __exit__(self, exc_type, exc_val, exc_tb):
                  """Context manager cleanup"""
                  self.close()
              
              def __getattr__(self, name):
                  """Proxy all other attributes to real connection"""
                  return getattr(self._connection, name)
          
          
          class SecureDatabaseWrapper:
              """
              Transparent database wrapper that intercepts all database operations
              
              Usage from application (FastAPI, Django, etc.):
                  # SQLite
                  conn = secure_db.connect('db.sqlite3', app_id='my_app')
                  
                  # PostgreSQL
                  conn = secure_db.connect_postgresql(host='localhost', database='mydb', 
                                                     user='user', password='pass', app_id='my_app')
                  
                  # MySQL
                  conn = secure_db.connect_mysql(host='localhost', database='mydb',
                                                 user='user', password='pass', app_id='my_app')
                  
              The application doesn't need to know about security - it's transparent!
              """
              
              def __init__(self, firewall: DatabaseSecurityFirewall):
                  self.firewall = firewall
              
              def connect(self, database: str, app_id: str, ip_address: str = "127.0.0.1", **kwargs) -> SecureConnection:
                  """
                  Connect to SQLite database with transparent security
                  
                  Args:
                      database: Database path
                      app_id: Application identifier (must be registered in dashboard)
                      ip_address: IP address of the connection
                      **kwargs: Additional sqlite3.connect arguments
                  
                  Returns:
                      SecureConnection that looks and acts like sqlite3.Connection
                  """
                  # Create real connection
                  real_connection = sqlite3.connect(database, **kwargs)
                  
                  # Wrap it with security
                  return SecureConnection(real_connection, self.firewall, app_id, ip_address)
              
              def connect_postgresql(self, host: str, database: str, user: str, password: str,
                                    app_id: str, ip_address: str = "127.0.0.1", 
                                    port: int = 5432, **kwargs) -> SecureConnection:
                  """
                  Connect to PostgreSQL database with transparent security
                  
                  Args:
                      host: Database host
                      database: Database name
                      user: Username
                      password: Password
                      app_id: Application identifier
                      ip_address: IP address of the connection
                      port: Database port (default 5432)
                      **kwargs: Additional psycopg2.connect arguments
                  
                  Returns:
                      SecureConnection that intercepts all queries
                  """
                  if not PSYCOPG2_AVAILABLE:
                      raise ImportError("psycopg2 not available. Install with: pip install psycopg2-binary")
                  
                  real_connection = psycopg2.connect(
                      host=host,
                      port=port,
                      database=database,
                      user=user,
                      password=password,
                      **kwargs
                  )
                  
                  return SecureConnection(real_connection, self.firewall, app_id, ip_address)
              
              def connect_mysql(self, host: str, database: str, user: str, password: str,
                               app_id: str, ip_address: str = "127.0.0.1",
                               port: int = 3306, **kwargs) -> SecureConnection:
                  """
                  Connect to MySQL database with transparent security
                  
                  Args:
                      host: Database host
                      database: Database name
                      user: Username
                      password: Password
                      app_id: Application identifier
                      ip_address: IP address of the connection
                      port: Database port (default 3306)
                      **kwargs: Additional mysql.connector.connect arguments
                  
                  Returns:
                      SecureConnection that intercepts all queries
                  """
                  if not MYSQL_AVAILABLE:
                      raise ImportError("mysql-connector-python not available. Install with: pip install mysql-connector-python")
                  
                  real_connection = mysql.connector.connect(
                      host=host,
                      port=port,
                      database=database,
                      user=user,
                      password=password,
                      **kwargs
                  )
                  
                  return SecureConnection(real_connection, self.firewall, app_id, ip_address)
          
          
          # Global instance for easy import
          _global_firewall = None
          
          def initialize_secure_database(db_path: str = "security.db"):
              """Initialize the global secure database wrapper"""
              global _global_firewall
              _global_firewall = DatabaseSecurityFirewall()
              return SecureDatabaseWrapper(_global_firewall)
          
          def get_secure_wrapper() -> SecureDatabaseWrapper:
              """Get the global secure database wrapper"""
              if _global_firewall is None:
                  raise RuntimeError("Secure database not initialized. Call initialize_secure_database() first")
              return SecureDatabaseWrapper(_global_firewall)          [93m|--- FILE CONTENT END ---|[0m
    [94m[framework_adapters]/[0m        [92mdjango_adapter.py[0m          [93m|--- FILE CONTENT START ---|[0m          """
          Django adapter for integrating database security system
          
          Installation:
              Add to settings.py:
              
              MIDDLEWARE = [
                  ...
                  'framework_adapters.django_adapter.DjangoSecurityMiddleware',
              ]
              
              DB_SECURITY_CONFIG = {
                  'enabled': True,
                  'app_id': 'django_app',
              }
          """
          
          import sys
          import os
          from typing import Callable
          
          sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
          
          from core.firewall import DatabaseFirewall
          
          
          class DjangoSecurityMiddleware:
              """
              Django middleware for database security
              """
              
              def __init__(self, get_response: Callable):
                  self.get_response = get_response
                  self.firewall = DatabaseFirewall()
              
              def __call__(self, request):
                  # Add firewall to request
                  request.db_security = self
                  
                  # Store request info for query execution
                  request.security_ip = self.get_client_ip(request)
                  
                  response = self.get_response(request)
                  return response
              
              def get_client_ip(self, request):
                  """Get client IP address from request"""
                  x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
                  if x_forwarded_for:
                      ip = x_forwarded_for.split(',')[0]
                  else:
                      ip = request.META.get('REMOTE_ADDR')
                  return ip
              
              def execute_query(self, request, app_id: str, operation: str, query: str):
                  """
                  Execute a query through the security system
                  
                  Usage in views:
                      def my_view(request):
                          is_auth, results, reason = request.db_security.execute_query(
                              request,
                              app_id='my_app',
                              operation='SELECT',
                              query='SELECT * FROM users'
                          )
                  """
                  ip_address = self.get_client_ip(request)
                  
                  return self.firewall.execute_query(
                      app_id=app_id,
                      ip_address=ip_address,
                      operation=operation,
                      query=query
                  )
              
              def get_logs(self):
                  """Get security logs"""
                  return self.firewall.get_logs()
          
          
          # Django view decorators
          def protect_query(app_id: str, operation: str):
              """
              Decorator for Django views to protect database queries
              
              Usage:
                  from framework_adapters.django_adapter import protect_query
                  
                  @protect_query(app_id='my_app', operation='SELECT')
                  def my_view(request):
                      # Access protected query execution via request
                      pass
              """
              def decorator(view_func: Callable):
                  def wrapper(request, *args, **kwargs):
                      request.security_app_id = app_id
                      request.security_operation = operation
                      return view_func(request, *args, **kwargs)
                  return wrapper
              return decorator
          
          
          # Django REST Framework integration
          class DRFSecurityMixin:
              """
              Mixin for Django REST Framework ViewSets
              
              Usage:
                  from rest_framework import viewsets
                  from framework_adapters.django_adapter import DRFSecurityMixin
                  
                  class UserViewSet(DRFSecurityMixin, viewsets.ModelViewSet):
                      security_app_id = 'api'
                      security_operation = 'SELECT'
                      
                      def list(self, request):
                          is_auth, results, reason = self.execute_secure_query(
                              'SELECT * FROM users'
                          )
                          return Response({'users': results})
              """
              
              security_app_id = 'unknown'
              security_operation = 'SELECT'
              
              def __init__(self, *args, **kwargs):
                  super().__init__(*args, **kwargs)
                  self.firewall = DatabaseFirewall()
              
              def execute_secure_query(self, query: str):
                  """Execute a query through the security system"""
                  request = self.request
                  ip_address = request.META.get('REMOTE_ADDR', '0.0.0.0')
                  
                  return self.firewall.execute_query(
                      app_id=self.security_app_id,
                      ip_address=ip_address,
                      operation=self.security_operation,
                      query=query
                  )
          
          
          # Example Django views
          """
          # views.py example
          
          from django.http import JsonResponse
          from framework_adapters.django_adapter import protect_query
          
          @protect_query(app_id='webapp_frontend', operation='SELECT')
          def get_users(request):
              is_auth, results, reason = request.db_security.execute_query(
                  request,
                  app_id=request.security_app_id,
                  operation=request.security_operation,
                  query='SELECT * FROM users'
              )
              
              if is_auth:
                  return JsonResponse({'users': results})
              else:
                  return JsonResponse({'error': reason}, status=403)
          
          def get_security_logs(request):
              logs = request.db_security.get_logs()
              return JsonResponse({'logs': logs})
          """          [93m|--- FILE CONTENT END ---|[0m
        [92mfastapi_adapter.py[0m          [93m|--- FILE CONTENT START ---|[0m          """
          FastAPI adapter for integrating database security system
          """
          
          from fastapi import Request, HTTPException, Depends
          from typing import Callable, Optional
          import sys
          import os
          
          sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
          
          from core.firewall import DatabaseFirewall
          
          
          class FastAPISecurityMiddleware:
              """
              FastAPI middleware for database security
              
              Usage:
                  from fastapi import FastAPI
                  from framework_adapters import FastAPISecurityMiddleware
                  
                  app = FastAPI()
                  security = FastAPISecurityMiddleware()
                  
                  @app.get("/api/users")
                  async def get_users(
                      auth=Depends(security.protect(app_id="my_app", operation="SELECT"))
                  ):
                      results = await security.execute("SELECT * FROM users")
                      return results
              """
              
              def __init__(self, firewall: Optional[DatabaseFirewall] = None):
                  self.firewall = firewall or DatabaseFirewall()
              
              def protect(self, app_id: str, operation: str):
                  """
                  Dependency for protecting routes
                  """
                  def dependency(request: Request):
                      request.state.security_app_id = app_id
                      request.state.security_operation = operation
                      request.state.security_ip = request.client.host
                      return self
                  return dependency
              
              def execute(self, request: Request, query: str):
                  """Execute a query through the security system"""
                  app_id = getattr(request.state, 'security_app_id', 'unknown')
                  operation = getattr(request.state, 'security_operation', 'SELECT')
                  ip_address = getattr(request.state, 'security_ip', request.client.host)
                  
                  is_auth, results, reason = self.firewall.execute_query(
                      app_id=app_id,
                      ip_address=ip_address,
                      operation=operation,
                      query=query
                  )
                  
                  if not is_auth:
                      raise HTTPException(status_code=403, detail=reason)
                  
                  return results
              
              def get_logs(self):
                  """Get security logs"""
                  return self.firewall.get_logs()
              
              def create_routes(self, app):
                  """Create security monitoring routes"""
                  from fastapi.responses import JSONResponse
                  
                  @app.get("/api/security/logs")
                  async def get_security_logs():
                      logs = self.get_logs()
                      return JSONResponse(content={'logs': logs})
                  
                  @app.get("/api/security/stats")
                  async def get_security_stats():
                      logs = self.get_logs()
                      stats = {
                          'total_queries': len(logs),
                          'blocked_queries': sum(1 for log in logs if log['action'] == 'REDIRECTED_TO_HONEYPOT'),
                          'unique_ips': len(set(log['ip_address'] for log in logs))
                      }
                      return JSONResponse(content=stats)
                  
                  @app.post("/api/security/query")
                  async def execute_protected_query(request: Request):
                      data = await request.json()
                      
                      if 'query' not in data:
                          raise HTTPException(status_code=400, detail="Missing query parameter")
                      
                      ip_address = request.client.host
                      is_auth, results, reason = self.firewall.execute_query(
                          app_id=data.get('app_id', 'unknown'),
                          ip_address=ip_address,
                          operation=data.get('operation', 'SELECT'),
                          query=data['query']
                      )
                      
                      return {
                          'authorized': is_auth,
                          'results': results,
                          'reason': reason
                      }
          
          
          # Example FastAPI app integration
          def create_protected_app():
              """Example of creating a FastAPI app with security protection"""
              from fastapi import FastAPI, Depends
              
              app = FastAPI(title="Protected Database API")
              security = FastAPISecurityMiddleware()
              
              security.create_routes(app)
              
              @app.get("/api/users")
              async def get_users(
                  request: Request,
                  auth=Depends(security.protect(app_id="webapp_frontend", operation="SELECT"))
              ):
                  results = await security.execute(request, "SELECT * FROM users")
                  return {'users': results}
              
              return app
          
          
          if __name__ == "__main__":
              import uvicorn
              app = create_protected_app()
              uvicorn.run(app, host="0.0.0.0", port=8000)          [93m|--- FILE CONTENT END ---|[0m
        [92mflask_adapter.py[0m          [93m|--- FILE CONTENT START ---|[0m          """
          Flask adapter for integrating database security system
          """
          
          from flask import request, g, jsonify
          from functools import wraps
          from typing import Callable, Optional
          import sys
          import os
          
          # Add parent directory to path for imports
          sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
          
          from core.firewall import DatabaseFirewall
          
          
          class FlaskSecurityAdapter:
              """
              Flask adapter for database security system
              
              Usage:
                  from flask import Flask
                  from framework_adapters import FlaskSecurityAdapter
                  
                  app = Flask(__name__)
                  security = FlaskSecurityAdapter(app)
                  
                  @app.route('/api/users')
                  @security.protect(app_id='my_app', operation='SELECT')
                  def get_users():
                      # Your query here
                      pass
              """
              
              def __init__(self, app=None, firewall: Optional[DatabaseFirewall] = None):
                  """
                  Initialize Flask security adapter
                  
                  Args:
                      app: Flask application instance (optional)
                      firewall: Custom DatabaseFirewall instance (optional)
                  """
                  self.firewall = firewall or DatabaseFirewall()
                  
                  if app:
                      self.init_app(app)
              
              def init_app(self, app):
                  """
                  Initialize the adapter with a Flask application
                  
                  Args:
                      app: Flask application instance
                  """
                  self.app = app
                  
                  # Register before_request handler
                  @app.before_request
                  def before_request():
                      g.db_security = self
              
              def protect(self, app_id: str, operation: str):
                  """
                  Decorator to protect database queries
                  
                  Args:
                      app_id: Application identifier
                      operation: SQL operation (SELECT, INSERT, UPDATE, DELETE)
                  
                  Usage:
                      @security.protect(app_id='my_app', operation='SELECT')
                      def my_route():
                          query = "SELECT * FROM users"
                          return security.execute(query)
                  """
                  def decorator(f: Callable):
                      @wraps(f)
                      def wrapper(*args, **kwargs):
                          # Store context for use in execute method
                          g.security_app_id = app_id
                          g.security_operation = operation
                          g.security_ip = request.remote_addr
                          
                          return f(*args, **kwargs)
                      return wrapper
                  return decorator
              
              def execute(self, query: str, simulate_time=None):
                  """
                  Execute a query through the security system
                  
                  Args:
                      query: SQL query to execute
                      simulate_time: Optional datetime for testing
                  
                  Returns:
                      Tuple of (is_authorized, results, reason)
                  """
                  app_id = g.get('security_app_id', 'unknown')
                  operation = g.get('security_operation', 'SELECT')
                  ip_address = g.get('security_ip', request.remote_addr)
                  
                  return self.firewall.execute_query(
                      app_id=app_id,
                      ip_address=ip_address,
                      operation=operation,
                      query=query,
                      simulate_time=simulate_time
                  )
              
              def check_and_execute(self, app_id: str, operation: str, query: str):
                  """
                  Convenience method to check and execute a query in one call
                  
                  Args:
                      app_id: Application identifier
                      operation: SQL operation
                      query: SQL query
                  
                  Returns:
                      Flask Response object
                  """
                  ip_address = request.remote_addr
                  
                  is_auth, results, reason = self.firewall.execute_query(
                      app_id=app_id,
                      ip_address=ip_address,
                      operation=operation,
                      query=query
                  )
                  
                  return jsonify({
                      'authorized': is_auth,
                      'results': results,
                      'reason': reason
                  }), 200 if is_auth else 403
              
              def get_logs(self, limit: Optional[int] = None):
                  """Get security logs"""
                  return self.firewall.get_logs()
              
              def create_routes(self, app, prefix='/api/security'):
                  """
                  Create security monitoring routes
                  
                  Args:
                      app: Flask application
                      prefix: URL prefix for routes
                  """
                  @app.route(f'{prefix}/logs', methods=['GET'])
                  def get_security_logs():
                      logs = self.get_logs()
                      return jsonify({'logs': logs}), 200
                  
                  @app.route(f'{prefix}/stats', methods=['GET'])
                  def get_security_stats():
                      logs = self.get_logs()
                      stats = {
                          'total_queries': len(logs),
                          'blocked_queries': sum(1 for log in logs if log['action'] == 'REDIRECTED_TO_HONEYPOT'),
                          'unique_ips': len(set(log['ip_address'] for log in logs))
                      }
                      return jsonify(stats), 200
                  
                  @app.route(f'{prefix}/query', methods=['POST'])
                  def execute_protected_query():
                      data = request.get_json()
                      
                      if not data or 'query' not in data:
                          return jsonify({'error': 'Missing query parameter'}), 400
                      
                      return self.check_and_execute(
                          app_id=data.get('app_id', 'unknown'),
                          operation=data.get('operation', 'SELECT'),
                          query=data['query']
                      )
          
          
          # Example Flask app integration
          def create_protected_app():
              """Example of creating a Flask app with security protection"""
              from flask import Flask
              
              app = Flask(__name__)
              security = FlaskSecurityAdapter(app)
              
              # Create security routes
              security.create_routes(app)
              
              @app.route('/api/users', methods=['GET'])
              @security.protect(app_id='webapp_frontend', operation='SELECT')
              def get_users():
                  is_auth, results, reason = security.execute("SELECT * FROM users")
                  
                  if is_auth:
                      return jsonify({'users': results}), 200
                  else:
                      return jsonify({'error': reason, 'fake_data': results}), 403
              
              return app
          
          
          if __name__ == '__main__':
              app = create_protected_app()
              app.run(debug=True, port=5000)          [93m|--- FILE CONTENT END ---|[0m
        [92m__init__.py[0m          [93m|--- FILE CONTENT START ---|[0m          """
          Framework adapters for integrating the security system with various web frameworks
          """
          
          from .flask_adapter import FlaskSecurityAdapter
          from .django_adapter import DjangoSecurityMiddleware
          from .fastapi_adapter import FastAPISecurityMiddleware
          
          __all__ = [
              'FlaskSecurityAdapter',
              'DjangoSecurityMiddleware',
              'FastAPISecurityMiddleware',
          ]          [93m|--- FILE CONTENT END ---|[0m
    [94m[gui]/[0m        [92mdashboard.py[0m          [93m|--- FILE CONTENT START ---|[0m          from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, 
                                       QLabel, QFrame, QGridLayout)
          from PyQt6.QtCore import Qt, QTimer
          from PyQt6.QtGui import QFont
          
          
          class Dashboard(QWidget):
              def __init__(self, firewall):
                  super().__init__()
                  self.firewall = firewall
                  self.init_ui()
                  
                  # Setup auto-refresh timer
                  self.timer = QTimer()
                  self.timer.timeout.connect(self.refresh_stats)
                  self.timer.start(2000)  # Refresh every 2 seconds
          
              def init_ui(self):
                  layout = QVBoxLayout()
                  
                  # Title
                  title = QLabel("Security Dashboard")
                  title_font = QFont()
                  title_font.setPointSize(16)
                  title_font.setBold(True)
                  title.setFont(title_font)
                  layout.addWidget(title)
          
                  # Statistics Grid
                  stats_layout = QGridLayout()
                  
                  # Stat cards
                  self.total_queries_card = self.create_stat_card("Total Queries", "0")
                  self.blocked_queries_card = self.create_stat_card("Blocked Queries", "0")
                  self.honeypot_hits_card = self.create_stat_card("Honeypot Hits", "0")
                  self.unique_ips_card = self.create_stat_card("Unique IPs", "0")
          
                  stats_layout.addWidget(self.total_queries_card, 0, 0)
                  stats_layout.addWidget(self.blocked_queries_card, 0, 1)
                  stats_layout.addWidget(self.honeypot_hits_card, 1, 0)
                  stats_layout.addWidget(self.unique_ips_card, 1, 1)
          
                  layout.addLayout(stats_layout)
          
                  # Recent Activity Section
                  activity_label = QLabel("Recent Activity")
                  activity_font = QFont()
                  activity_font.setPointSize(12)
                  activity_font.setBold(True)
                  activity_label.setFont(activity_font)
                  layout.addWidget(activity_label)
          
                  self.activity_list = QLabel("No recent activity")
                  self.activity_list.setWordWrap(True)
                  self.activity_list.setStyleSheet("padding: 10px; background-color: #f5f5f5; border-radius: 5px;")
                  layout.addWidget(self.activity_list)
          
                  layout.addStretch()
                  self.setLayout(layout)
          
              def create_stat_card(self, title: str, value: str) -> QFrame:
                  """Create a statistics card widget"""
                  card = QFrame()
                  card.setFrameStyle(QFrame.Shape.Box)
                  card.setStyleSheet("""
                      QFrame {
                          background-color: white;
                          border: 2px solid #e0e0e0;
                          border-radius: 10px;
                          padding: 20px;
                      }
                  """)
          
                  card_layout = QVBoxLayout()
          
                  title_label = QLabel(title)
                  title_label.setStyleSheet("color: #666; font-size: 12px;")
                  
                  value_label = QLabel(value)
                  value_label.setStyleSheet("color: #333; font-size: 24px; font-weight: bold;")
                  value_label.setObjectName("value_label")
          
                  card_layout.addWidget(title_label)
                  card_layout.addWidget(value_label)
                  card.setLayout(card_layout)
          
                  return card
          
              def refresh_stats(self):
                  """Refresh dashboard statistics"""
                  logs = self.firewall.get_logs()
                  
                  # Update statistics
                  total_queries = len(logs)
                  blocked_queries = sum(1 for log in logs if log['action'] == 'REDIRECTED_TO_HONEYPOT')
                  
                  # Get unique IPs
                  unique_ips = len(set(log['ip_address'] for log in logs))
          
                  # Update cards
                  self.update_card_value(self.total_queries_card, str(total_queries))
                  self.update_card_value(self.blocked_queries_card, str(blocked_queries))
                  self.update_card_value(self.honeypot_hits_card, str(blocked_queries))
                  self.update_card_value(self.unique_ips_card, str(unique_ips))
          
                  # Update recent activity
                  if logs:
                      recent_logs = logs[-5:]  # Last 5 logs
                      activity_text = ""
                      for log in reversed(recent_logs):
                          activity_text += f" {log['app_id']} from {log['ip_address']}: {log['reason']}\n"
                      self.activity_list.setText(activity_text)
                  else:
                      self.activity_list.setText("No recent activity")
          
              def update_card_value(self, card: QFrame, value: str):
                  """Update the value label in a stat card"""
                  value_label = card.findChild(QLabel, "value_label")
                  if value_label:
                      value_label.setText(value)          [93m|--- FILE CONTENT END ---|[0m
        [92mdatabase_connection_tab.py[0m          [93m|--- FILE CONTENT START ---|[0m          """
          Database Connection Manager for GUI
          Allows users to connect to and manage different databases
          """
          from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QGroupBox,
                                        QLabel, QLineEdit, QPushButton, QComboBox,
                                        QTableWidget, QTableWidgetItem, QMessageBox,
                                        QFileDialog, QSpinBox, QTextEdit, QTabWidget)
          from PyQt6.QtCore import Qt, pyqtSignal
          from PyQt6.QtGui import QColor
          import sys
          import os
          
          # Add parent directory to path
          sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
          
          from database.adapters import (SQLiteAdapter, PostgreSQLAdapter, 
                                          MySQLAdapter, MongoDBAdapter)
          
          
          class DatabaseConnectionTab(QWidget):
              """Widget for managing database connections"""
              
              connection_changed = pyqtSignal(object)  # Signal when connection changes
              
              def __init__(self, firewall=None):
                  super().__init__()
                  self.firewall = firewall
                  self.current_adapter = None
                  self.connections = {}  # Store multiple connections
                  self.init_ui()
              
              def init_ui(self):
                  """Initialize the user interface"""
                  layout = QVBoxLayout()
                  
                  # Title
                  title = QLabel("Database Connection Manager")
                  title.setStyleSheet("font-size: 16px; font-weight: bold; padding: 10px;")
                  layout.addWidget(title)
                  
                  # Create tabs for different sections
                  tabs = QTabWidget()
                  
                  # Connection tab
                  connection_tab = self.create_connection_tab()
                  tabs.addTab(connection_tab, "Connect to Database")
                  
                  # Active connections tab
                  active_tab = self.create_active_connections_tab()
                  tabs.addTab(active_tab, "Active Connections")
                  
                  # Query executor tab
                  query_tab = self.create_query_tab()
                  tabs.addTab(query_tab, "Execute Queries")
                  
                  layout.addWidget(tabs)
                  
                  self.setLayout(layout)
              
              def create_connection_tab(self):
                  """Create the database connection configuration tab"""
                  widget = QWidget()
                  layout = QVBoxLayout()
                  
                  # Database type selection
                  type_group = QGroupBox("Database Type")
                  type_layout = QHBoxLayout()
                  
                  type_layout.addWidget(QLabel("Select Type:"))
                  self.db_type_combo = QComboBox()
                  self.db_type_combo.addItems(['SQLite', 'PostgreSQL', 'MySQL', 'MongoDB'])
                  self.db_type_combo.currentTextChanged.connect(self.on_db_type_changed)
                  type_layout.addWidget(self.db_type_combo)
                  type_layout.addStretch()
                  
                  type_group.setLayout(type_layout)
                  layout.addWidget(type_group)
                  
                  # Connection parameters (will change based on DB type)
                  self.params_group = QGroupBox("Connection Parameters")
                  self.params_layout = QVBoxLayout()
                  self.params_group.setLayout(self.params_layout)
                  layout.addWidget(self.params_group)
                  
                  # Initialize with SQLite parameters
                  self.on_db_type_changed('SQLite')
                  
                  # Connection name and app ID
                  config_group = QGroupBox("Security Configuration")
                  config_layout = QVBoxLayout()
                  
                  # Connection name
                  name_layout = QHBoxLayout()
                  name_layout.addWidget(QLabel("Connection Name:"))
                  self.conn_name_input = QLineEdit()
                  self.conn_name_input.setPlaceholderText("e.g., Production DB")
                  name_layout.addWidget(self.conn_name_input)
                  config_layout.addLayout(name_layout)
                  
                  # App ID
                  app_layout = QHBoxLayout()
                  app_layout.addWidget(QLabel("Application ID:"))
                  self.app_id_input = QLineEdit()
                  self.app_id_input.setPlaceholderText("e.g., webapp_frontend")
                  app_layout.addWidget(self.app_id_input)
                  config_layout.addLayout(app_layout)
                  
                  config_group.setLayout(config_layout)
                  layout.addWidget(config_group)
                  
                  # Action buttons
                  button_layout = QHBoxLayout()
                  
                  test_btn = QPushButton("Test Connection")
                  test_btn.clicked.connect(self.test_connection)
                  button_layout.addWidget(test_btn)
                  
                  connect_btn = QPushButton("Connect")
                  connect_btn.setStyleSheet("background-color: #28a745;")
                  connect_btn.clicked.connect(self.connect_database)
                  button_layout.addWidget(connect_btn)
                  
                  button_layout.addStretch()
                  layout.addLayout(button_layout)
                  
                  # Status area
                  self.status_text = QTextEdit()
                  self.status_text.setReadOnly(True)
                  self.status_text.setMaximumHeight(100)
                  self.status_text.setPlaceholderText("Connection status will appear here...")
                  layout.addWidget(QLabel("Status:"))
                  layout.addWidget(self.status_text)
                  
                  layout.addStretch()
                  widget.setLayout(layout)
                  return widget
              
              def on_db_type_changed(self, db_type):
                  """Handle database type change"""
                  # Clear existing parameters
                  while self.params_layout.count():
                      child = self.params_layout.takeAt(0)
                      if child.widget():
                          child.widget().deleteLater()
                  
                  # Store input widgets
                  self.param_inputs = {}
                  
                  if db_type == 'SQLite':
                      self.create_sqlite_params()
                  elif db_type == 'PostgreSQL':
                      self.create_postgresql_params()
                  elif db_type == 'MySQL':
                      self.create_mysql_params()
                  elif db_type == 'MongoDB':
                      self.create_mongodb_params()
              
              def create_sqlite_params(self):
                  """Create SQLite connection parameters"""
                  # Database file path
                  file_layout = QHBoxLayout()
                  file_layout.addWidget(QLabel("Database File:"))
                  self.param_inputs['database'] = QLineEdit()
                  self.param_inputs['database'].setPlaceholderText("Path to .db file")
                  file_layout.addWidget(self.param_inputs['database'])
                  
                  browse_btn = QPushButton("Browse...")
                  browse_btn.clicked.connect(self.browse_sqlite_file)
                  file_layout.addWidget(browse_btn)
                  
                  self.params_layout.addLayout(file_layout)
              
              def create_postgresql_params(self):
                  """Create PostgreSQL connection parameters"""
                  params = [
                      ('host', 'Host:', 'localhost'),
                      ('port', 'Port:', '5432'),
                      ('database', 'Database:', 'postgres'),
                      ('user', 'Username:', 'postgres'),
                      ('password', 'Password:', '')
                  ]
                  
                  for key, label, placeholder in params:
                      layout = QHBoxLayout()
                      layout.addWidget(QLabel(label))
                      self.param_inputs[key] = QLineEdit()
                      self.param_inputs[key].setPlaceholderText(placeholder)
                      
                      if key == 'password':
                          self.param_inputs[key].setEchoMode(QLineEdit.EchoMode.Password)
                      
                      layout.addWidget(self.param_inputs[key])
                      self.params_layout.addLayout(layout)
              
              def create_mysql_params(self):
                  """Create MySQL connection parameters"""
                  params = [
                      ('host', 'Host:', 'localhost'),
                      ('port', 'Port:', '3306'),
                      ('database', 'Database:', 'mysql'),
                      ('user', 'Username:', 'root'),
                      ('password', 'Password:', '')
                  ]
                  
                  for key, label, placeholder in params:
                      layout = QHBoxLayout()
                      layout.addWidget(QLabel(label))
                      self.param_inputs[key] = QLineEdit()
                      self.param_inputs[key].setPlaceholderText(placeholder)
                      
                      if key == 'password':
                          self.param_inputs[key].setEchoMode(QLineEdit.EchoMode.Password)
                      
                      layout.addWidget(self.param_inputs[key])
                      self.params_layout.addLayout(layout)
              
              def create_mongodb_params(self):
                  """Create MongoDB connection parameters"""
                  params = [
                      ('host', 'Host:', 'localhost'),
                      ('port', 'Port:', '27017'),
                      ('database', 'Database:', 'test'),
                      ('user', 'Username (optional):', ''),
                      ('password', 'Password (optional):', '')
                  ]
                  
                  for key, label, placeholder in params:
                      layout = QHBoxLayout()
                      layout.addWidget(QLabel(label))
                      self.param_inputs[key] = QLineEdit()
                      self.param_inputs[key].setPlaceholderText(placeholder)
                      
                      if key == 'password':
                          self.param_inputs[key].setEchoMode(QLineEdit.EchoMode.Password)
                      
                      layout.addWidget(self.param_inputs[key])
                      self.params_layout.addLayout(layout)
              
              def browse_sqlite_file(self):
                  """Browse for SQLite database file"""
                  file_path, _ = QFileDialog.getOpenFileName(
                      self,
                      "Select SQLite Database",
                      "",
                      "SQLite Database (*.db *.sqlite *.sqlite3);;All Files (*)"
                  )
                  
                  if file_path:
                      self.param_inputs['database'].setText(file_path)
              
              def get_connection_config(self):
                  """Get connection configuration from inputs"""
                  config = {}
                  for key, widget in self.param_inputs.items():
                      value = widget.text()
                      
                      # Convert port to int if applicable
                      if key == 'port' and value:
                          try:
                              config[key] = int(value)
                          except ValueError:
                              config[key] = value
                      else:
                          config[key] = value
                  
                  return config
              
              def test_connection(self):
                  """Test database connection"""
                  db_type = self.db_type_combo.currentText()
                  config = self.get_connection_config()
                  
                  self.status_text.append(f"\n[INFO] Testing {db_type} connection...")
                  
                  try:
                      adapter = self.create_adapter(db_type, config)
                      
                      if adapter.connect():
                          success, message = adapter.test_connection()
                          
                          if success:
                              self.status_text.append(f"[SUCCESS] {message}")
                              QMessageBox.information(self, "Success", f"Connection successful!\n{message}")
                          else:
                              self.status_text.append(f"[ERROR] {message}")
                              QMessageBox.warning(self, "Connection Failed", message)
                          
                          adapter.disconnect()
                      else:
                          self.status_text.append("[ERROR] Failed to establish connection")
                          QMessageBox.warning(self, "Connection Failed", "Could not connect to database")
                  
                  except Exception as e:
                      error_msg = f"Connection error: {str(e)}"
                      self.status_text.append(f"[ERROR] {error_msg}")
                      QMessageBox.critical(self, "Error", error_msg)
              
              def connect_database(self):
                  """Connect to database and store connection"""
                  db_type = self.db_type_combo.currentText()
                  config = self.get_connection_config()
                  conn_name = self.conn_name_input.text() or f"{db_type} Connection"
                  app_id = self.app_id_input.text() or "unknown_app"
                  
                  self.status_text.append(f"\n[INFO] Connecting to {db_type}...")
                  
                  try:
                      adapter = self.create_adapter(db_type, config)
                      
                      if adapter.connect():
                          # Store connection
                          self.connections[conn_name] = {
                              'adapter': adapter,
                              'db_type': db_type,
                              'app_id': app_id,
                              'config': config
                          }
                          
                          self.current_adapter = adapter
                          
                          self.status_text.append(f"[SUCCESS] Connected to {conn_name}")
                          QMessageBox.information(
                              self,
                              "Success",
                              f"Successfully connected to {conn_name}\nApp ID: {app_id}"
                          )
                          
                          # Update active connections display
                          self.update_active_connections()
                          
                          # Emit signal
                          self.connection_changed.emit(adapter)
                      else:
                          self.status_text.append("[ERROR] Failed to connect")
                          QMessageBox.warning(self, "Connection Failed", "Could not connect to database")
                  
                  except Exception as e:
                      error_msg = f"Connection error: {str(e)}"
                      self.status_text.append(f"[ERROR] {error_msg}")
                      QMessageBox.critical(self, "Error", error_msg)
              
              def create_adapter(self, db_type, config):
                  """Create appropriate database adapter"""
                  if db_type == 'SQLite':
                      return SQLiteAdapter(config)
                  elif db_type == 'PostgreSQL':
                      return PostgreSQLAdapter(config)
                  elif db_type == 'MySQL':
                      return MySQLAdapter(config)
                  elif db_type == 'MongoDB':
                      return MongoDBAdapter(config)
                  else:
                      raise ValueError(f"Unsupported database type: {db_type}")
              
              def create_active_connections_tab(self):
                  """Create tab showing active connections"""
                  widget = QWidget()
                  layout = QVBoxLayout()
                  
                  layout.addWidget(QLabel("Active Database Connections:"))
                  
                  # Connections table
                  self.connections_table = QTableWidget()
                  self.connections_table.setColumnCount(4)
                  self.connections_table.setHorizontalHeaderLabels([
                      'Connection Name', 'Database Type', 'App ID', 'Status'
                  ])
                  self.connections_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
                  self.connections_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
                  
                  layout.addWidget(self.connections_table)
                  
                  # Action buttons
                  button_layout = QHBoxLayout()
                  
                  refresh_btn = QPushButton("Refresh")
                  refresh_btn.clicked.connect(self.update_active_connections)
                  button_layout.addWidget(refresh_btn)
                  
                  disconnect_btn = QPushButton("Disconnect Selected")
                  disconnect_btn.setStyleSheet("background-color: #dc3545;")
                  disconnect_btn.clicked.connect(self.disconnect_selected)
                  button_layout.addWidget(disconnect_btn)
                  
                  button_layout.addStretch()
                  layout.addLayout(button_layout)
                  
                  widget.setLayout(layout)
                  return widget
              
              def update_active_connections(self):
                  """Update the active connections display"""
                  self.connections_table.setRowCount(len(self.connections))
                  
                  for i, (name, conn_info) in enumerate(self.connections.items()):
                      self.connections_table.setItem(i, 0, QTableWidgetItem(name))
                      self.connections_table.setItem(i, 1, QTableWidgetItem(conn_info['db_type']))
                      self.connections_table.setItem(i, 2, QTableWidgetItem(conn_info['app_id']))
                      
                      # Check connection status
                      adapter = conn_info['adapter']
                      status = "Connected" if adapter.is_connected() else "Disconnected"
                      status_item = QTableWidgetItem(status)
                      
                      if status == "Connected":
                          status_item.setBackground(QColor(200, 255, 200))
                      else:
                          status_item.setBackground(QColor(255, 200, 200))
                      
                      self.connections_table.setItem(i, 3, status_item)
              
              def disconnect_selected(self):
                  """Disconnect selected connection"""
                  current_row = self.connections_table.currentRow()
                  
                  if current_row < 0:
                      QMessageBox.warning(self, "No Selection", "Please select a connection to disconnect")
                      return
                  
                  conn_name = self.connections_table.item(current_row, 0).text()
                  
                  reply = QMessageBox.question(
                      self,
                      "Disconnect",
                      f"Disconnect from '{conn_name}'?",
                      QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                  )
                  
                  if reply == QMessageBox.StandardButton.Yes:
                      if conn_name in self.connections:
                          self.connections[conn_name]['adapter'].disconnect()
                          del self.connections[conn_name]
                          
                          self.update_active_connections()
                          QMessageBox.information(self, "Success", f"Disconnected from {conn_name}")
              
              def create_query_tab(self):
                  """Create query execution tab"""
                  widget = QWidget()
                  layout = QVBoxLayout()
                  
                  # Query input
                  layout.addWidget(QLabel("Enter SQL Query:"))
                  
                  self.query_input = QTextEdit()
                  self.query_input.setPlaceholderText("SELECT * FROM users;")
                  self.query_input.setMaximumHeight(150)
                  layout.addWidget(self.query_input)
                  
                  # Execute button
                  exec_btn = QPushButton("Execute Query (Protected)")
                  exec_btn.setStyleSheet("background-color: #28a745; font-weight: bold;")
                  exec_btn.clicked.connect(self.execute_query)
                  layout.addWidget(exec_btn)
                  
                  # Results
                  layout.addWidget(QLabel("Query Results:"))
                  
                  self.results_table = QTableWidget()
                  layout.addWidget(self.results_table)
                  
                  widget.setLayout(layout)
                  return widget
              
              def execute_query(self):
                  """Execute query through the firewall"""
                  query = self.query_input.toPlainText().strip()
                  
                  if not query:
                      QMessageBox.warning(self, "Empty Query", "Please enter a query to execute")
                      return
                  
                  if not self.current_adapter:
                      QMessageBox.warning(self, "No Connection", "Please connect to a database first")
                      return
                  
                  # Get app_id from current connection
                  app_id = "unknown_app"
                  for conn_name, conn_info in self.connections.items():
                      if conn_info['adapter'] == self.current_adapter:
                          app_id = conn_info['app_id']
                          break
                  
                  try:
                      # Execute through firewall if available
                      if self.firewall:
                          operation = query.split()[0].upper()
                          is_auth, results, reason = self.firewall.execute_query(
                              app_id=app_id,
                              ip_address='127.0.0.1',
                              operation=operation,
                              query=query
                          )
                          
                          if is_auth:
                              self.display_results(results, f"Query executed successfully")
                          else:
                              self.display_results(results, f"BLOCKED: {reason}\n(Showing honeypot data)")
                      else:
                          # Execute directly if no firewall
                          results = self.current_adapter.execute_query(query)
                          self.display_results(results, "Query executed (no firewall protection)")
                  
                  except Exception as e:
                      QMessageBox.critical(self, "Query Error", f"Error executing query:\n{str(e)}")
              
              def display_results(self, results, message):
                  """Display query results in table"""
                  if not results:
                      QMessageBox.information(self, "Query Results", f"{message}\nNo results returned")
                      self.results_table.setRowCount(0)
                      self.results_table.setColumnCount(0)
                      return
                  
                  # Convert results to list of dicts if needed
                  if isinstance(results[0], dict):
                      # Results are already dicts (from adapters)
                      columns = list(results[0].keys())
                      rows = results
                  else:
                      # Results are tuples (from SQLite)
                      columns = [f"Column {i+1}" for i in range(len(results[0]))]
                      rows = [dict(zip(columns, row)) for row in results]
                  
                  # Setup table
                  self.results_table.setRowCount(len(rows))
                  self.results_table.setColumnCount(len(columns))
                  self.results_table.setHorizontalHeaderLabels(columns)
                  
                  # Populate table
                  for i, row in enumerate(rows):
                      for j, col in enumerate(columns):
                          value = str(row.get(col, ''))
                          self.results_table.setItem(i, j, QTableWidgetItem(value))
                  
                  self.results_table.resizeColumnsToContents()
                  
                  QMessageBox.information(self, "Success", f"{message}\nRows returned: {len(results)}")          [93m|--- FILE CONTENT END ---|[0m
        [92menhanced_main_window.py[0m          [93m|--- FILE CONTENT START ---|[0m          """
          Enhanced Main Window for Database Security System GUI
          """
          from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                                        QTabWidget, QPushButton, QLabel, QStatusBar,
                                        QToolBar, QMessageBox, QFileDialog)
          from PyQt6.QtCore import Qt, QTimer
          from PyQt6.QtGui import QAction, QFont, QIcon
          import json
          from datetime import datetime
          
          # Import other GUI components
          from gui.dashboard import Dashboard
          from gui.log_viewer import LogViewer
          from gui.database_connection_tab import DatabaseConnectionTab
          
          
          class EnhancedMainWindow(QMainWindow):
              """Enhanced main window with modern UI"""
              
              def __init__(self):
                  super().__init__()
                  self.firewall = None  # Will be set by main.py
                  self.init_ui()
                  
                  # Setup auto-refresh timer
                  self.refresh_timer = QTimer()
                  self.refresh_timer.timeout.connect(self.refresh_data)
                  self.refresh_timer.start(3000)  # Refresh every 3 seconds
              
              def init_ui(self):
                  """Initialize the user interface"""
                  self.setWindowTitle("Database Security System - Enhanced Dashboard")
                  self.setMinimumSize(1200, 800)
                  
                  # Create central widget and layout
                  central_widget = QWidget()
                  self.setCentralWidget(central_widget)
                  main_layout = QVBoxLayout(central_widget)
                  
                  # Create toolbar
                  self.create_toolbar()
                  
                  # Create header
                  header = self.create_header()
                  main_layout.addWidget(header)
                  
                  # Create tab widget
                  self.tabs = QTabWidget()
                  self.tabs.setStyleSheet("""
                      QTabWidget::pane {
                          border: 1px solid #cccccc;
                          background: white;
                      }
                      QTabBar::tab {
                          background: #f0f0f0;
                          padding: 10px 20px;
                          margin-right: 2px;
                      }
                      QTabBar::tab:selected {
                          background: white;
                          border-bottom: 3px solid #007bff;
                      }
                  """)
                  
                  # Wait for firewall to be set before creating tabs
                  # We'll create them in refresh_data
                  main_layout.addWidget(self.tabs)
                  
                  # Create status bar
                  self.create_status_bar()
                  
                  # Apply stylesheet
                  self.apply_stylesheet()
              
              def create_toolbar(self):
                  """Create toolbar with actions"""
                  toolbar = QToolBar()
                  toolbar.setMovable(False)
                  self.addToolBar(toolbar)
                  
                  # Refresh action
                  refresh_action = QAction("Refresh", self)
                  refresh_action.triggered.connect(self.refresh_data)
                  toolbar.addAction(refresh_action)
                  
                  toolbar.addSeparator()
                  
                  # Clear logs action
                  clear_action = QAction("Clear Logs", self)
                  clear_action.triggered.connect(self.clear_logs)
                  toolbar.addAction(clear_action)
                  
                  toolbar.addSeparator()
                  
                  # Export action
                  export_action = QAction("Export Data", self)
                  export_action.triggered.connect(self.export_data)
                  toolbar.addAction(export_action)
                  
                  toolbar.addSeparator()
                  
                  # About action
                  about_action = QAction("About", self)
                  about_action.triggered.connect(self.show_about)
                  toolbar.addAction(about_action)
              
              def create_header(self):
                  """Create header section"""
                  header = QWidget()
                  header.setStyleSheet("background-color: #2c3e50; padding: 20px;")
                  layout = QVBoxLayout(header)
                  
                  title = QLabel("Database Security System")
                  title.setStyleSheet("color: white; font-size: 24px; font-weight: bold;")
                  layout.addWidget(title)
                  
                  subtitle = QLabel("Real-time Database Access Monitoring & Protection")
                  subtitle.setStyleSheet("color: #ecf0f1; font-size: 14px;")
                  layout.addWidget(subtitle)
                  
                  return header
              
              def create_status_bar(self):
                  """Create status bar"""
                  self.status_bar = QStatusBar()
                  self.setStatusBar(self.status_bar)
                  
                  self.status_label = QLabel("Ready")
                  self.status_bar.addWidget(self.status_label)
                  
                  # Connection status
                  self.connection_status = QLabel("Firewall Active")
                  self.connection_status.setStyleSheet("color: green; font-weight: bold;")
                  self.status_bar.addPermanentWidget(self.connection_status)
              
              def apply_stylesheet(self):
                  """Apply modern stylesheet"""
                  self.setStyleSheet("""
                      QMainWindow {
                          background-color: #f5f5f5;
                      }
                      QPushButton {
                          background-color: #007bff;
                          color: white;
                          border: none;
                          padding: 8px 16px;
                          border-radius: 4px;
                          font-weight: bold;
                      }
                      QPushButton:hover {
                          background-color: #0056b3;
                      }
                      QPushButton:pressed {
                          background-color: #004085;
                      }
                      QLabel {
                          color: #333333;
                      }
                      QToolBar {
                          background-color: #ffffff;
                          border-bottom: 1px solid #cccccc;
                          spacing: 10px;
                          padding: 5px;
                      }
                  """)
              
              def refresh_data(self):
                  """Refresh all data displays"""
                  if self.firewall is None:
                      # Firewall not set yet, try to import it
                      try:
                          from core.firewall import DatabaseFirewall
                          self.firewall = DatabaseFirewall()
                          self.initialize_tabs()
                      except Exception as e:
                          self.status_label.setText(f"Error: {str(e)}")
                          return
                  
                  # Update status
                  try:
                      logs = self.firewall.get_logs()
                      self.status_label.setText(f"Total Events: {len(logs)} | Active")
                  except Exception as e:
                      self.status_label.setText(f"Error: {str(e)}")
              
              def initialize_tabs(self):
                  """Initialize tabs once firewall is available"""
                  if self.tabs.count() == 0 and self.firewall is not None:
                      # Database Connection tab (NEW!)
                      self.db_connection_tab = DatabaseConnectionTab(self.firewall)
                      self.tabs.addTab(self.db_connection_tab, "Database Connections")
                      
                      # Dashboard tab
                      self.dashboard = Dashboard(self.firewall)
                      self.tabs.addTab(self.dashboard, "Dashboard")
                      
                      # Logs tab
                      self.log_viewer = LogViewer(self.firewall)
                      self.tabs.addTab(self.log_viewer, "Security Logs")
              
              def clear_logs(self):
                  """Clear all security logs"""
                  reply = QMessageBox.question(
                      self,
                      "Clear Logs",
                      "Are you sure you want to clear all security logs?",
                      QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                  )
                  
                  if reply == QMessageBox.StandardButton.Yes:
                      if self.firewall:
                          self.firewall.logger.clear_logs()
                          self.refresh_data()
                          QMessageBox.information(self, "Success", "Logs cleared successfully")
              
              def export_data(self):
                  """Export security logs to file"""
                  if not self.firewall:
                      QMessageBox.warning(self, "No Data", "No firewall data available to export")
                      return
                  
                  file_path, _ = QFileDialog.getSaveFileName(
                      self,
                      "Export Security Logs",
                      f"security_logs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                      "JSON Files (*.json);;CSV Files (*.csv);;All Files (*)"
                  )
                  
                  if file_path:
                      try:
                          logs = self.firewall.get_logs()
                          
                          if file_path.endswith('.json'):
                              with open(file_path, 'w') as f:
                                  json.dump(logs, f, indent=2)
                          elif file_path.endswith('.csv'):
                              import csv
                              if logs:
                                  with open(file_path, 'w', newline='') as f:
                                      writer = csv.DictWriter(f, fieldnames=logs[0].keys())
                                      writer.writeheader()
                                      writer.writerows(logs)
                          
                          QMessageBox.information(self, "Success", f"Logs exported to:\n{file_path}")
                      except Exception as e:
                          QMessageBox.critical(self, "Export Failed", f"Error exporting logs:\n{str(e)}")
              
              def show_about(self):
                  """Show about dialog"""
                  about_text = """
                  <h2>Database Security System</h2>
                  <p><b>Version 1.0</b></p>
                  <p>A comprehensive database security solution with:</p>
                  <ul>
                      <li>Real-time SQL injection detection</li>
                      <li>Access control and authorization</li>
                      <li>Honeypot database for attackers</li>
                      <li>Detailed security logging</li>
                      <li>Multi-database support (SQLite, PostgreSQL, MySQL, MongoDB)</li>
                      <li>Application-level access control</li>
                  </ul>
                  <p><b>Built with Python and PyQt6</b></p>
                  <p>&copy; 2025 Database Security System</p>
                  """
                  
                  QMessageBox.about(self, "About Database Security System", about_text)
              
              def closeEvent(self, event):
                  """Handle window close event"""
                  reply = QMessageBox.question(
                      self,
                      "Exit",
                      "Are you sure you want to exit?\n\nAll active database connections will be closed.",
                      QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                  )
                  
                  if reply == QMessageBox.StandardButton.Yes:
                      # Close all database connections
                      if hasattr(self, 'db_connection_tab'):
                          for conn_info in self.db_connection_tab.connections.values():
                              try:
                                  conn_info['adapter'].disconnect()
                              except:
                                  pass
                      event.accept()
                  else:
                      event.ignore()          [93m|--- FILE CONTENT END ---|[0m
        [92mlog_viewer.py[0m          [93m|--- FILE CONTENT START ---|[0m          from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout,
                                       QTableWidget, QTableWidgetItem, QPushButton,
                                       QLabel, QLineEdit, QComboBox)
          from PyQt6.QtCore import Qt
          from PyQt6.QtGui import QColor
          
          
          class LogViewer(QWidget):
              def __init__(self, firewall):
                  super().__init__()
                  self.firewall = firewall
                  self.all_logs = []
                  self.init_ui()
          
              def init_ui(self):
                  layout = QVBoxLayout()
          
                  # Title
                  title = QLabel("Security Logs Viewer")
                  title.setStyleSheet("font-size: 16px; font-weight: bold;")
                  layout.addWidget(title)
          
                  # Filter controls
                  filter_layout = QHBoxLayout()
                  
                  filter_layout.addWidget(QLabel("Filter by:"))
                  
                  self.filter_combo = QComboBox()
                  self.filter_combo.addItems(['All', 'App ID', 'IP Address', 'Reason'])
                  self.filter_combo.currentTextChanged.connect(self.on_filter_changed)
                  filter_layout.addWidget(self.filter_combo)
                  
                  self.filter_input = QLineEdit()
                  self.filter_input.setPlaceholderText("Enter filter value...")
                  self.filter_input.textChanged.connect(self.apply_filter)
                  filter_layout.addWidget(self.filter_input)
                  
                  refresh_btn = QPushButton("Refresh")
                  refresh_btn.clicked.connect(self.refresh_logs)
                  filter_layout.addWidget(refresh_btn)
                  
                  clear_btn = QPushButton("Clear Logs")
                  clear_btn.clicked.connect(self.clear_logs)
                  filter_layout.addWidget(clear_btn)
                  
                  filter_layout.addStretch()
                  layout.addLayout(filter_layout)
          
                  # Logs table
                  self.logs_table = QTableWidget()
                  self.logs_table.setColumnCount(6)
                  self.logs_table.setHorizontalHeaderLabels([
                      'Timestamp', 'App ID', 'IP Address', 'Operation', 'Reason', 'Query'
                  ])
                  self.logs_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
                  self.logs_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
                  self.logs_table.setAlternatingRowColors(True)
                  
                  # Set column widths
                  self.logs_table.setColumnWidth(0, 150)
                  self.logs_table.setColumnWidth(1, 120)
                  self.logs_table.setColumnWidth(2, 120)
                  self.logs_table.setColumnWidth(3, 80)
                  self.logs_table.setColumnWidth(4, 200)
                  self.logs_table.setColumnWidth(5, 300)
                  
                  layout.addWidget(self.logs_table)
          
                  # Log count
                  self.log_count_label = QLabel("Total logs: 0")
                  layout.addWidget(self.log_count_label)
          
                  self.setLayout(layout)
                  self.refresh_logs()
          
              def refresh_logs(self):
                  """Refresh the logs table from the firewall"""
                  from datetime import datetime
                  
                  self.all_logs = self.firewall.get_logs()
                  self.apply_filter()
          
              def apply_filter(self):
                  """Apply the current filter to the logs"""
                  filter_type = self.filter_combo.currentText()
                  filter_value = self.filter_input.text().lower()
          
                  # Filter logs
                  if filter_type == 'All' or not filter_value:
                      filtered_logs = self.all_logs
                  else:
                      filtered_logs = []
                      for log in self.all_logs:
                          if filter_type == 'App ID' and filter_value in log['app_id'].lower():
                              filtered_logs.append(log)
                          elif filter_type == 'IP Address' and filter_value in log['ip_address'].lower():
                              filtered_logs.append(log)
                          elif filter_type == 'Reason' and filter_value in log['reason'].lower():
                              filtered_logs.append(log)
          
                  # Update table
                  self.populate_table(filtered_logs)
                  self.log_count_label.setText(f"Total logs: {len(filtered_logs)} (Filtered from {len(self.all_logs)})")
          
              def populate_table(self, logs):
                  """Populate the table with logs"""
                  from datetime import datetime
                  
                  self.logs_table.setRowCount(len(logs))
          
                  for i, log in enumerate(logs):
                      # Add timestamp (simulated as current time for display)
                      timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                      self.logs_table.setItem(i, 0, QTableWidgetItem(timestamp))
                      
                      # Add log data
                      self.logs_table.setItem(i, 1, QTableWidgetItem(log['app_id']))
                      self.logs_table.setItem(i, 2, QTableWidgetItem(log['ip_address']))
                      self.logs_table.setItem(i, 3, QTableWidgetItem(log['operation']))
                      self.logs_table.setItem(i, 4, QTableWidgetItem(log['reason']))
                      self.logs_table.setItem(i, 5, QTableWidgetItem(log['query'][:100] + '...' if len(log['query']) > 100 else log['query']))
          
                      # Color code rows based on threat level
                      if 'SQL injection' in log['reason']:
                          color = QColor(255, 200, 200)  # Light red for injection attempts
                      elif 'not whitelisted' in log['reason']:
                          color = QColor(255, 230, 200)  # Light orange for unauthorized IPs
                      else:
                          color = QColor(255, 255, 200)  # Light yellow for other issues
          
                      for col in range(6):
                          item = self.logs_table.item(i, col)
                          if item:
                              item.setBackground(color)
          
              def on_filter_changed(self, value):
                  """Handle filter type change"""
                  if value == 'All':
                      self.filter_input.setEnabled(False)
                      self.filter_input.clear()
                  else:
                      self.filter_input.setEnabled(True)
                  self.apply_filter()
          
              def clear_logs(self):
                  """Clear all logs"""
                  self.firewall.logger.clear_logs()
                  self.refresh_logs()          [93m|--- FILE CONTENT END ---|[0m
        [92mmain_window.py[0m          [93m|--- FILE CONTENT START ---|[0m          [91m[CONTENT SKIPPED: Error reading file: 'charmap' codec can't encode character '\u2705' in position 3507: character maps to <undefined>][0m
        [92m__init__.py[0m          [93m|--- FILE CONTENT START ---|[0m          [93m|--- FILE CONTENT END ---|[0m
    [94m[security]/[0m        [92mdb_proxy.py[0m          [93m|--- FILE CONTENT START ---|[0m          # src/security/db_proxy.py
          """
          Transparent SQLite DB proxy wrapper.
          
          How it works:
          - Call install_sqlite_wrapper() early (before other modules call sqlite3.connect).
          - It monkeypatches sqlite3.connect so returned connections produce wrapped cursors.
          - WrappedCursor.execute()/executemany() run the injection detector.
            - If query is NOT suspicious -> executed on the real DB as normal.
            - If query IS suspicious -> the wrapper redirects execution to the honeypot DB
              (Settings.HONEYPOT_DB_PATH) and replaces the cursor so subsequent fetchall()
              or other cursor operations will operate on the honeypot results.
          This achieves a transparent, "plug-in" security layer: client code calls
          sqlite3.connect() and uses the API unchanged.
          """
          
          from __future__ import annotations
          import functools
          import logging
          import sqlite3 as _sqlite3
          import threading
          from typing import Any, Optional
          
          # Import your project's settings and detector
          try:
              from config.settings import Settings
          except Exception:
              # Fallback defaults if Settings not available
              class Settings:
                  HONEYPOT_DB_PATH = "honeypot_database.db"
          
          try:
              from security.injection_detector import InjectionDetector
          except Exception:
              # If the module isn't present yet, we provide a simple fallback detector.
              class InjectionDetector:
                  def detect_sql_injection(self, query: str):
                      return False, ""
                  def score_sql_risk(self, query: str):
                      return 0.0
          
          logger = logging.getLogger("db_proxy")
          logger.setLevel(logging.INFO)
          if not logger.handlers:
              ch = logging.StreamHandler()
              ch.setFormatter(logging.Formatter("[db_proxy] %(levelname)s: %(message)s"))
              logger.addHandler(ch)
          
          _detector_lock = threading.Lock()
          _detector: Optional[InjectionDetector] = None
          
          def _get_detector() -> InjectionDetector:
              global _detector
              if _detector is None:
                  with _detector_lock:
                      if _detector is None:
                          _detector = InjectionDetector()
              return _detector
          
          def install_sqlite_wrapper():
              """
              Replace sqlite3.connect with a wrapper that returns a WrappedConnection.
              Call this before other modules call sqlite3.connect().
              """
              real_connect = _sqlite3.connect
          
              @functools.wraps(real_connect)
              def wrapped_connect(*args, **kwargs):
                  # create a real sqlite connection
                  real_conn = real_connect(*args, **kwargs)
                  return WrappedConnection(real_conn, args, kwargs)
          
              _sqlite3.connect = wrapped_connect
              logger.info("Installed sqlite3 wrapper (transparent DB proxy)")
          
          class WrappedConnection:
              def __init__(self, real_conn: _sqlite3.Connection, ctor_args, ctor_kwargs):
                  self._real_conn = real_conn
                  self._ctor_args = ctor_args
                  self._ctor_kwargs = ctor_kwargs
                  # track honeypot connection per-wrapped-connection if we redirect
                  self._honeypot_conn: Optional[_sqlite3.Connection] = None
          
              def cursor(self, *args, **kwargs):
                  real_cur = self._real_conn.cursor(*args, **kwargs)
                  return WrappedCursor(real_cur, self)
          
              # Expose the most used connection methods transparently
              def commit(self):
                  # commit real DB only
                  return self._real_conn.commit()
          
              def rollback(self):
                  return self._real_conn.rollback()
          
              def close(self):
                  try:
                      # close any honeypot connection first
                      if self._honeypot_conn:
                          try:
                              self._honeypot_conn.close()
                          except Exception:
                              pass
                          self._honeypot_conn = None
                  finally:
                      return self._real_conn.close()
          
              def __getattr__(self, name):
                  return getattr(self._real_conn, name)
          
          class WrappedCursor:
              def __init__(self, real_cursor: _sqlite3.Cursor, conn_wrapper: WrappedConnection):
                  self._cur = real_cursor
                  self._conn_wrapper = conn_wrapper
                  self._is_on_honeypot = False
                  self._honeypot_cursor: Optional[_sqlite3.Cursor] = None
          
              def execute(self, query: str, params: Any = None):
                  """
                  Intercept query; if suspicious, redirect to honeypot DB.
                  """
                  detector = _get_detector()
                  try:
                      # Prefer score if available
                      score = 0.0
                      if hasattr(detector, "score_sql_risk"):
                          try:
                              score = float(detector.score_sql_risk(query))
                          except Exception:
                              score = 0.0
                      else:
                          # fallback to boolean detect
                          is_inj, _ = detector.detect_sql_injection(query)
                          score = 1.0 if is_inj else 0.0
                  except Exception as e:
                      logger.exception("Injection detector failed; treating query as safe by default: %s", e)
                      score = 0.0
          
                  # Threshold: treat score >= 0.6 as suspicious (redirect to honeypot)
                  suspicious = (score >= 0.6)
                  if suspicious:
                      logger.warning("Suspicious SQL detected (score=%.2f). Redirecting to honeypot: %s", score, _short(query))
                      # Open honeypot connection lazily
                      try:
                          if not self._conn_wrapper._honeypot_conn:
                              self._conn_wrapper._honeypot_conn = _sqlite3.connect(Settings.HONEYPOT_DB_PATH)
                          # create a real honeypot cursor and execute there
                          self._honeypot_cursor = self._conn_wrapper._honeypot_conn.cursor()
                          if params is None:
                              self._honeypot_cursor.execute(query)
                          else:
                              self._honeypot_cursor.execute(query, params)
                          self._is_on_honeypot = True
                          # replace the 'active' cursor so subsequent fetchall() uses honeypot results
                          self._cur = self._honeypot_cursor
                          return None  # same as sqlite cursor.execute()
                      except Exception as e:
                          logger.exception("Honeypot execution failed, falling back to real DB: %s", e)
                          # fall through to executing on real DB
                          suspicious = False
          
                  # Not suspicious (or fallback): execute on real DB cursor
                  if params is None:
                      return self._cur.execute(query)
                  else:
                      return self._cur.execute(query, params)
          
              def executemany(self, query: str, seq_of_params):
                  detector = _get_detector()
                  try:
                      score = 0.0
                      if hasattr(detector, "score_sql_risk"):
                          try:
                              score = float(detector.score_sql_risk(query))
                          except Exception:
                              score = 0.0
                      else:
                          is_inj, _ = detector.detect_sql_injection(query)
                          score = 1.0 if is_inj else 0.0
                  except Exception:
                      score = 0.0
          
                  suspicious = (score >= 0.6)
                  if suspicious:
                      logger.warning("Suspicious executemany (score=%.2f). Redirecting to honeypot: %s", score, _short(query))
                      try:
                          if not self._conn_wrapper._honeypot_conn:
                              self._conn_wrapper._honeypot_conn = _sqlite3.connect(Settings.HONEYPOT_DB_PATH)
                          self._honeypot_cursor = self._conn_wrapper._honeypot_conn.cursor()
                          return self._honeypot_cursor.executemany(query, seq_of_params)
                      except Exception as e:
                          logger.exception("Honeypot executemany failed; falling back to real DB: %s", e)
          
                  return self._cur.executemany(query, seq_of_params)
          
              # Allow fetchall/fetchone/etc to work (they operate on self._cur)
              def fetchall(self):
                  return self._cur.fetchall()
          
              def fetchone(self):
                  return self._cur.fetchone()
          
              def fetchmany(self, size: int = None):
                  if size is None:
                      return self._cur.fetchmany()
                  return self._cur.fetchmany(size)
          
              def close(self):
                  try:
                      if self._is_on_honeypot and self._honeypot_cursor:
                          try:
                              self._honeypot_cursor.close()
                          except Exception:
                              pass
                          self._honeypot_cursor = None
                          self._is_on_honeypot = False
                  finally:
                      return self._cur.close()
          
              def __getattr__(self, name):
                  # delegate other attributes to active cursor
                  return getattr(self._cur, name)
          
          def _short(x, n=160):
              try:
                  s = str(x)
                  return (s[:n] + "...") if len(s) > n else s
              except Exception:
                  return "<non-string>"          [93m|--- FILE CONTENT END ---|[0m
        [92mfirewall.py[0m          [93m|--- FILE CONTENT START ---|[0m          import sqlite3
          import datetime
          from typing import Dict, List, Tuple
          from faker import Faker
          import hashlib
          
          
          class DatabaseFirewall:
              """Main firewall class that intercepts and validates database access"""
          
              def __init__(self, real_db_path: str = "real_database.db",
                  honeypot_db_path: str = "honeypot_database.db"):
                  self.real_db_path = real_db_path
                  self.honeypot_db_path = honeypot_db_path
                  self.fake = Faker()
                  self.access_log = []
                  self.authorized_schedule = {} # Format: {app_id: [(start_time, end_time)]}
                  # Initialize databases
                  self._init_real_database()
                  self._init_honeypot_database()
          
              def _init_real_database(self):
                  """Initialize the real database with sample data"""
                  conn = sqlite3.connect(self.real_db_path)
                  cursor = conn.cursor()
                  cursor.execute('''
                      CREATE TABLE IF NOT EXISTS users (
                          id INTEGER PRIMARY KEY,
                          username TEXT,
                          email TEXT,
                          password TEXT,
                          balance REAL
                      )
                  ''')
                  cursor.execute("DELETE FROM users")
                  # add some sample accounts
                  users = [
                      ('admin', 'admin@example.com', hashlib.sha256(b'admin').hexdigest(), 10000.0),
                      ('alice', 'alice@example.com', hashlib.sha256(b'alice').hexdigest(), 5000.0)
                  ]
                  cursor.executemany('''
                      INSERT INTO users (username, email, password, balance)
                      VALUES (?, ?, ?, ?)
                  ''', users)
                  conn.commit()
                  conn.close()
          
              def _init_honeypot_database(self):
                  """Initialize honeypot with fake-ish data"""
                  conn = sqlite3.connect(self.honeypot_db_path)
                  cursor = conn.cursor()
                  cursor.execute('''
                      CREATE TABLE IF NOT EXISTS users (
                          id INTEGER PRIMARY KEY,
                          username TEXT,
                          email TEXT,
                          password TEXT,
                          balance REAL
                      )
                  ''')
                  # populate honeypot with some fake entries
                  cursor.execute("DELETE FROM users")
                  fake_rows = []
                  for i in range(1, 6):
                      uname = self.fake.user_name()
                      fake_rows.append((i, uname, self.fake.email(), hashlib.md5(self.fake.password().encode()).hexdigest(), round(self.fake.random.uniform(100, 1000), 2)))
                  cursor.executemany('''
                      INSERT INTO users (id, username, email, password, balance)
                      VALUES (?, ?, ?, ?, ?)
                  ''', fake_rows)
                  conn.commit()
                  conn.close()
          
              def register_authorized_access(self, app_id: str, start: datetime.time, end: datetime.time):
                  """Register allowed schedule for an app"""
                  self.authorized_schedule.setdefault(app_id, []).append((start, end))
          
              def _is_access_authorized(self, app_id: str, current_time: datetime.datetime) -> bool:
                  """Simple authorization check based on self.authorized_schedule"""
                  if app_id not in self.authorized_schedule:
                      # default allow nothing
                      return False
                  windows = self.authorized_schedule[app_id]
                  now = current_time.time()
                  for start, end in windows:
                      if start <= now <= end:
                          return True
                  return False
          
              def _generate_fake_data(self):
                  """Used to create honeytokens / decoy responses"""
                  return {
                      'username': self.fake.user_name(),
                      'email': self.fake.email(),
                      'note': self.fake.sentence()
                  }
          
              def _populate_honeypot(self, operation: str, query: str):
                  """Convenience wrapper to ensure honeypot has data"""
                  conn = sqlite3.connect(self.honeypot_db_path)
                  cursor = conn.cursor()
                  # ensure there is at least some fake data
                  cursor.execute("DELETE FROM users")
                  fake_rows = []
                  for i in range(1, 6):
                      uname = self.fake.user_name()
                      fake_rows.append((i, uname, self.fake.email(), hashlib.md5(self.fake.password().encode()).hexdigest(), round(self.fake.random.uniform(100, 1000), 2)))
                  cursor.executemany('''
                      INSERT INTO users (id, username, email, password, balance)
                      VALUES (?, ?, ?, ?, ?)
                  ''', fake_rows)
                  conn.commit()
                  conn.close()
          
              def _log_intrusion(self, app_id: str, ip_address: str, operation: str, query: str, timestamp: datetime.datetime):
                  entry = {
                      'timestamp': timestamp.isoformat(),
                      'app_id': app_id,
                      'ip_address': ip_address,
                      'operation': operation,
                      'query': query
                  }
                  self.access_log.append(entry)
          
              def _send_alert(self, log_entry: dict):
                  # Placeholder: integrate with alerts/alert_manager
                  print("ALERT:", log_entry)
          
              def execute_query(self, app_id: str, ip_address: str, operation: str,
                                query: str) -> Tuple[bool, List]:
                  """
                  Main method to execute database queries through the firewall
                  Returns: (is_authorized, results)
                  """
                  current_time = datetime.datetime.now()
          
                  # Check authorization
                  is_authorized = self._is_access_authorized(app_id, current_time)
          
                  if is_authorized:
                      # Execute on real database
                      conn = sqlite3.connect(self.real_db_path)
                      cursor = conn.cursor()
                      cursor.execute(query)
          
                      if operation.upper() in ['INSERT', 'UPDATE', 'DELETE']:
                          conn.commit()
                          results = []
                      else:
                          results = cursor.fetchall()
          
                      conn.close()
                      return True, results
          
                  else:
                      # Redirect to honeypot
                      self._log_intrusion(app_id, ip_address, operation, query, current_time)
                      self._populate_honeypot(operation, query)
          
                      # Execute on honeypot database
                      conn = sqlite3.connect(self.honeypot_db_path)
                      cursor = conn.cursor()
                      cursor.execute(query)
          
                      if operation.upper() in ['INSERT', 'UPDATE', 'DELETE']:
                          conn.commit()
                          results = []
                      else:
                          try:
                              results = cursor.fetchall()
                          except Exception:
                              results = []
                      conn.close()
                      return False, results          [93m|--- FILE CONTENT END ---|[0m
        [92mhoneypot.py[0m          [93m|--- FILE CONTENT START ---|[0m          """
          src/security/honeypot.py
          
          Lightweight honeypot / alerting module.
          
          Functions:
          - alert_on_suspicious(query, params, score, warn_only=False)
          
          This module intentionally keeps alerts simple (write to a log file and optionally
          simulate honeypot DB population). In a production system you'd wire this to:
          - persistent audit log, ELK/Graylog, Splunk, or alerting (PagerDuty/email/webhook)
          - a real honeypot DB instance with controlled fake data
          """
          
          import logging
          import os
          import json
          import datetime
          
          logger = logging.getLogger("honeypot")
          logger.setLevel(logging.DEBUG)
          if not logger.handlers:
              ch = logging.StreamHandler()
              ch.setFormatter(logging.Formatter("%(asctime)s %(levelname)s honeypot: %(message)s"))
              logger.addHandler(ch)
          
          # file to append alerts to (relative to project)
          _ALERT_FILE = os.environ.get("HONEYPOT_ALERT_FILE", "honeypot_alerts.log")
          
          
          def _append_alert(record: dict):
              try:
                  with open(_ALERT_FILE, "a", encoding="utf-8") as fh:
                      fh.write(json.dumps(record, default=str) + "\n")
              except Exception:
                  logger.exception("Failed to write honeypot alert file")
          
          
          def alert_on_suspicious(query: str, params: object = None, score: float = 1.0, warn_only: bool = False):
              """
              Called when db_proxy detects suspicious activity.
              - query: raw SQL text
              - params: parameters (may be None)
              - score: risk score 0..1
              - warn_only: if True, do not escalate beyond logging
              """
              rec = {
                  "timestamp": datetime.datetime.utcnow().isoformat() + "Z",
                  "score": float(score),
                  "query": str(query)[:2000],
                  "params_summary": _summarize_params(params),
                  "warn_only": bool(warn_only),
              }
              # write to file
              _append_alert(rec)
              # also log
              if warn_only:
                  logger.warning("Suspicious query logged (warn_only): score=%.3f query=%s", score, _short(query))
              else:
                  logger.error("Suspicious query ALERT: score=%.3f query=%s", score, _short(query))
          
              # TODO: trigger external alert (webhook/pagerduty) for high scores if desired
          
          
          def _short(x, n=160):
              try:
                  s = str(x)
                  return (s[:n] + "...") if len(s) > n else s
              except Exception:
                  return "<non-string>"
          
          
          def _summarize_params(params):
              try:
                  if params is None:
                      return None
                  if isinstance(params, (list, tuple)):
                      return [type(x).__name__ for x in params][:10]
                  return type(params).__name__
              except Exception:
                  return "params_unknown"          [93m|--- FILE CONTENT END ---|[0m
        [92minjection_detector.py[0m          [93m|--- FILE CONTENT START ---|[0m          # src/security/injection_detector.py
          """
          Injection detector for SQL queries.
          
          Provides both functional and class-based interfaces:
          - detect_sql_injection(query) -> (bool, reason)
          - score_sql_risk(query) -> float in [0.0, 1.0]
          - InjectionDetector class for compatibility
          """
          
          import re
          from typing import Tuple
          
          # Patterns that strongly indicate injection-like content
          _STRONG_PATTERNS = [
              r"\bUNION\b\s+\bSELECT\b",
              r"(;|\b--\b|\b/\*\b|\b\*/\b)",        # delimiters/comments
              r"\bOR\b\s+['\"]?\d+['\"]?\s*=\s*['\"]?\d+['\"]?",  # OR 1=1 etc
              r"\bAND\b\s+['\"]?\d+['\"]?\s*=\s*['\"]?\d+['\"]?",
              r"\bDROP\b\s+\bTABLE\b",
              r"\bDELETE\b\s+\bFROM\b",
              r"\bINSERT\b\s+\bINTO\b.*\bSELECT\b",  # suspicious complex insert-select
              r"sleep\s*\(",                         # timing attack
              r"benchmark\s*\(",                     # MySQL benchmark
              r"\bEXEC(UTE)?\b",
          ]
          
          # Weaker suspicious tokens
          _WEAK_PATTERNS = [
              r"\bINFORMATION_SCHEMA\b",
              r"\bPG_SLEEP\b",
              r"0x[0-9a-f]{6,}",    # hex blobs often in obfuscation
              r"char\(",            # obfuscation techniques
              r"cast\(",            # type casts often used in payloads
          ]
          
          RE_STRONG = [re.compile(p, re.IGNORECASE) for p in _STRONG_PATTERNS]
          RE_WEAK = [re.compile(p, re.IGNORECASE) for p in _WEAK_PATTERNS]
          
          
          def detect_sql_injection(query: str) -> Tuple[bool, str]:
              """
              Return (is_injection, reason_string)
              """
              if not query or not isinstance(query, str):
                  return False, ""
          
              q = query.strip()
          
              # Multiple statements (simple heuristic)
              if ";" in q:
                  cnt = q.count(";")
                  if cnt >= 1:
                      return True, "Multiple statements or semicolon found"
          
              # Strong patterns -> immediate detection
              for r in RE_STRONG:
                  if r.search(q):
                      return True, f"Strong pattern matched: {r.pattern}"
          
              # Weak patterns increase suspicion
              for r in RE_WEAK:
                  if r.search(q):
                      return True, f"Weak pattern matched: {r.pattern}"
          
              # Always-true boolean conditions
              if re.search(r"\bOR\b\s+['\"]?\d+['\"]?\s*=\s*['\"]?\d+", q, re.IGNORECASE):
                  return True, "Always-true OR condition detected"
          
              return False, ""
          
          
          def score_sql_risk(query: str) -> float:
              """
              Return a float in [0.0, 1.0] estimating likelihood of injection.
              """
              if not query or not isinstance(query, str):
                  return 0.0
              
              q = query.strip()
              score = 0.0
          
              # semicolon / multiple statements
              if ";" in q:
                  score += 0.5
          
              for r in RE_STRONG:
                  if r.search(q):
                      score += 0.6
              
              for r in RE_WEAK:
                  if r.search(q):
                      score += 0.2
          
              if re.search(r"\bOR\b\s+['\"]?\d+['\"]?\s*=\s*['\"]?\d+", q, re.IGNORECASE):
                  score += 0.6
          
              # cap at 1.0
              if score > 1.0:
                  score = 1.0
              
              return round(score, 3)
          
          
          class InjectionDetector:
              """
              Class-based interface for SQL injection detection.
              Provides compatibility with existing firewall code.
              """
              
              def __init__(self):
                  """Initialize the injection detector"""
                  pass
              
              def detect_sql_injection(self, query: str) -> Tuple[bool, str]:
                  """
                  Detect SQL injection patterns in a query.
                  
                  Args:
                      query: SQL query string to analyze
                      
                  Returns:
                      Tuple of (is_injection, reason)
                  """
                  return detect_sql_injection(query)
              
              def score_sql_risk(self, query: str) -> float:
                  """
                  Score the risk level of a SQL query.
                  
                  Args:
                      query: SQL query string to analyze
                      
                  Returns:
                      Risk score between 0.0 and 1.0
                  """
                  return score_sql_risk(query)          [93m|--- FILE CONTENT END ---|[0m
        [92mip_tracker.py[0m          [93m|--- FILE CONTENT START ---|[0m          from typing import Dict, List
          from datetime import datetime
          import ipaddress
          
          
          class IPTracker:
              def __init__(self):
                  self.tracked_ips = {}
                  self.blocked_ips = set()
          
              def track_ip(self, ip_address: str, app_id: str, operation: str):
                  """Track an IP address activity"""
                  if ip_address not in self.tracked_ips:
                      self.tracked_ips[ip_address] = {
                          'first_seen': datetime.now(),
                          'last_seen': datetime.now(),
                          'attempts': 0,
                          'operations': [],
                          'apps': set()
                      }
          
                  self.tracked_ips[ip_address]['last_seen'] = datetime.now()
                  self.tracked_ips[ip_address]['attempts'] += 1
                  self.tracked_ips[ip_address]['operations'].append({
                      'operation': operation,
                      'timestamp': datetime.now()
                  })
                  self.tracked_ips[ip_address]['apps'].add(app_id)
          
              def block_ip(self, ip_address: str):
                  """Add an IP address to the block list"""
                  self.blocked_ips.add(ip_address)
          
              def unblock_ip(self, ip_address: str):
                  """Remove an IP address from the block list"""
                  if ip_address in self.blocked_ips:
                      self.blocked_ips.remove(ip_address)
          
              def is_blocked(self, ip_address: str) -> bool:
                  """Check if an IP address is blocked"""
                  return ip_address in self.blocked_ips
          
              def get_ip_info(self, ip_address: str) -> Dict:
                  """Get information about a specific IP address"""
                  if ip_address not in self.tracked_ips:
                      return None
          
                  info = self.tracked_ips[ip_address].copy()
                  info['apps'] = list(info['apps'])
                  info['is_blocked'] = self.is_blocked(ip_address)
                  return info
          
              def get_all_tracked_ips(self) -> List[Dict]:
                  """Get information about all tracked IPs"""
                  result = []
                  for ip, info in self.tracked_ips.items():
                      ip_data = {
                          'ip_address': ip,
                          'first_seen': info['first_seen'],
                          'last_seen': info['last_seen'],
                          'attempts': info['attempts'],
                          'apps': list(info['apps']),
                          'is_blocked': self.is_blocked(ip)
                      }
                      result.append(ip_data)
                  return result
          
              def get_suspicious_ips(self, threshold: int = 5) -> List[str]:
                  """Get IPs with attempts exceeding threshold"""
                  suspicious = []
                  for ip, info in self.tracked_ips.items():
                      if info['attempts'] >= threshold:
                          suspicious.append(ip)
                  return suspicious
          
              def is_private_ip(self, ip_address: str) -> bool:
                  """Check if an IP address is private"""
                  try:
                      ip_obj = ipaddress.ip_address(ip_address)
                      return ip_obj.is_private
                  except:
                      return False
          
              def clear_tracking(self):
                  """Clear all tracking data"""
                  self.tracked_ips = {}
                  self.blocked_ips = set()          [93m|--- FILE CONTENT END ---|[0m
        [92mthreat_analyzer.py[0m          [93m|--- FILE CONTENT START ---|[0m          from typing import Dict, List
          from datetime import datetime, timedelta
          
          
          class ThreatAnalyzer:
              def __init__(self):
                  self.threat_history = []
                  self.ip_attempts = {}
          
              def analyze_threat_level(self, ip_address: str, reason: str) -> str:
                  """
                  Analyze threat level based on attack patterns and frequency
                  Returns: 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'
                  """
                  # Record the attempt
                  current_time = datetime.now()
                  if ip_address not in self.ip_attempts:
                      self.ip_attempts[ip_address] = []
                  
                  self.ip_attempts[ip_address].append({
                      'timestamp': current_time,
                      'reason': reason
                  })
          
                  # Clean old attempts (older than 1 hour)
                  self._clean_old_attempts(ip_address)
          
                  # Calculate threat level
                  recent_attempts = len(self.ip_attempts[ip_address])
                  
                  if recent_attempts >= 10:
                      return 'CRITICAL'
                  elif recent_attempts >= 5:
                      return 'HIGH'
                  elif recent_attempts >= 3:
                      return 'MEDIUM'
                  else:
                      return 'LOW'
          
              def _clean_old_attempts(self, ip_address: str):
                  """Remove attempts older than 1 hour"""
                  one_hour_ago = datetime.now() - timedelta(hours=1)
                  if ip_address in self.ip_attempts:
                      self.ip_attempts[ip_address] = [
                          attempt for attempt in self.ip_attempts[ip_address]
                          if attempt['timestamp'] > one_hour_ago
                      ]
          
              def get_threat_statistics(self) -> Dict:
                  """Get statistics about current threats"""
                  stats = {
                      'total_ips_tracked': len(self.ip_attempts),
                      'high_risk_ips': [],
                      'total_attempts': 0
                  }
          
                  for ip, attempts in self.ip_attempts.items():
                      attempt_count = len(attempts)
                      stats['total_attempts'] += attempt_count
                      if attempt_count >= 5:
                          stats['high_risk_ips'].append({
                              'ip': ip,
                              'attempts': attempt_count
                          })
          
                  return stats
          
              def is_blocked_ip(self, ip_address: str, threshold: int = 10) -> bool:
                  """Check if an IP should be blocked based on attempt threshold"""
                  if ip_address not in self.ip_attempts:
                      return False
                  return len(self.ip_attempts[ip_address]) >= threshold          [93m|--- FILE CONTENT END ---|[0m
        [92m__init__.py[0m          [93m|--- FILE CONTENT START ---|[0m          [93m|--- FILE CONTENT END ---|[0m
